[{"authors":["admin"],"categories":null,"content":"Currently, I am a Software Developer at Google working on Google Cloud. I am also an open-source developer, a maintainer of rustworkx, and a student at Georgia Tech's OMSCS.\nPreviously, I was at the University of British Columbia. I wrote my Honours Thesis supervised by Dr. Ramon Lawrence and my research focused on databases, particulary on Learned Indexes.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://ivaniscoding.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Currently, I am a Software Developer at Google working on Google Cloud. I am also an open-source developer, a maintainer of rustworkx, and a student at Georgia Tech's OMSCS.\nPreviously, I was at the University of British Columbia. I wrote my Honours Thesis supervised by Dr. Ramon Lawrence and my research focused on databases, particulary on Learned Indexes.","tags":null,"title":"Ivan Carvalho","type":"authors"},{"authors":null,"categories":["Coding Interview"],"content":"Entering the world of coding interviews can be daunting. Whether you are a recent graduate with a bachelor’s or master’s degree in Computer Science or a senior industry professional, questions may arise with regards to which programming language to use and which strategy to follow before and during your coding interview.\nThis guide will give a simple answer out of the many possible one for that question.\nTo keep things simple, I recommend the Python programming language. And to keep our strategy even simpler, I recommend writing all your solutions in a single line.\nWriting your code in one line can bring numerous benefits. Firstly, if there is a bug, you don’t need to worry about which line of code the error happened. Secondly, one line progams are concise. Combined with the fact that Python is similar to plain English, this strategy helps your interviewer understand your solution better. In fact, it is like reading one very long sentence with many commas.\nAre you still stressed about the coding interview and in doubt on how to code in a single line? You need not worry, because I will provide examples and tips throughout the rest of this article.\nRecursion is your friend Recursion is a powerful concept that allows us to reutilize code. Hence, it fits perfectly with Python solutions using one line of code.\nLet’s take for example the task of inverting a binary tree (link). This question is rumored to be a frequently asked questions for candidates that write package managers for macOS.\n In the example above, recursion does most of the work. To invert a binary tree, we swap the left and right nodes and then keep repeating the process. Clear and concise.\nConditional Operators are helfpul This detail was also in the last code snippet, but we can discuss it individually. Do not waste multiple lines writing if and else statements! In fact, Python lets you write conditional operators in a single line.\nConsider the following code that computes the depth of a binary tree (link) .\n Thanks to conditional operators, your code fits concisely in one line. The if and else statements let you handle correctly the base case for the recursion which is the empty tree node.\nLambdas are powerful Lambdas, also known as anonymous functions, let us define Python functions without wasting unnecessary lines.\nTake for example the task of finding the first palindrome in a list (link).\n Thanks to the lambda statement, we didn’t need to define a separate function to check for palindromes (x == x[::-1]).\nThe Walrus is a must  I told you about the Walrus and me, man\nYou know that we’re as close as can be, man\n- The Beatles  The walrus was Paul was introduced in PEP 572. Because the feature landed in Python 3.8, it is higly likely that you can use it as of 2024. The walrus lets us write less code, which is great.\nThe true power of the walrus, however, appears when it is combined with lambda functions, because it yields recursive lambdas. Now you don’t need to waste a separate line to define a recursive function!\nTake for example the task to check if a binary tree is symmetric (link).\n The lambda definition with the walrus operator (f := lambda) allows us to define a recursive function that solves the problem in a single line. The code does not need to waste lines in superfluous function definitions.\nThe standard library is one function call away Python is known for its included batteries i.e. libraries that ship with Python. They can be useful for coding interviews as well.\nThere is a misconception that you need your import statement in a separate line. But that is not necessary due to the __import__ function.\nI demonstrate that in the solution for calculating the majority element in an array (link) .\n Python has a built-in Counter class that handles this exact case. By using the standard library, we reused existing code and made our solution simpler without having to sacrifice an extra line for the import.\nThe wheel can be reinvented Sometimes your interviewer will explicitly forbid you from using the standard library. In those cases, it is likely take you can write similar code still in one line.\nTake for example the task of sorting an array from scratch (link). We can fit a Randomized Quicksort in one (very long) line.\n If the interviewer complains about using random.randint though, you can just read from /dev/random instead. And if they complain about opening /dev/random with the Python built-ins, you can use punched cards to execute code.\nBelieve in Yourself You might find harder questions along your coding interview journey. Do not panic. Believe in yourself and keep going. Look at the following solution for calculating block sums in a matrix (link).\n Sometimes I’ll start a line of code and I don’t even know where it’s going. I just hope I find it along the way. And pray there is no syntax error.\nConclusion If you have reached the end of the article, I want to kindly remind you to read the date of the publication of this article. Happy Aрrіl Fօօls’ Day! Do not take the content of this post seriously, it is all a ʝοκе. The contents of this post do not reflect my employer’s opinion on coding interviews. In fact, they don’t even represent mine.\n","date":1711965600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1711965600,"objectID":"80f7443fd19d5c74655a9fbfd99e2e40","permalink":"https://ivaniscoding.github.io/posts/codeinterview/","publishdate":"2024-04-01T06:00:00-04:00","relpermalink":"/posts/codeinterview/","section":"posts","summary":"How to get the job with one-liners","tags":["algorithms"],"title":"How to survive coding interviews with a single line of Python code","type":"posts"},{"authors":null,"categories":["Quantum"],"content":"This is my post about the Qiskit Mentorship Program. Since March, I started contributing to Qiskit and Retworkx. Overall, it has been a great experience and I plan to continue contributing after the mentorship ends.\nIn this post, I hope to answer some questions about the program. I will structure this as a Q\u0026amp;A instead of a detailed blogpost about transpile optimizations because I believe it makes more sense. If by chance you are interested in knowing more about Retworkx and the transpile passes that are in Qiskit, I invite you to send me a message on the Qiskit Slack.\nHence, let’s get started with the questions.\nQ: What is the Qiskit Mentorship Program? The Qiskit Mentorship Program is organized by the Qiskit Community and matches mentees to experienced contributors from Qiskit and IBM Quantum.\nIt runs for roughly three months, a period in which mentees work individually or as a team to work in a project that will be integrated to Qiskit. This was the first iteration of the mentorship program, and you can take a peak of the project proposals for this iteration here - there were many mentors and projects to choose from.\nThe mentorship is a great opportunity to start contributing to Qiskit and networkx with project maintainers, IBM researchers, and many other talented people.\nQ: What did you work on during the mentorship period? In my specific case, I worked on Retworkx. Retworkx is a graph theory library maintained by Qiskit, which was created with performance in mind.\nIt mind sound counterintuitive, but Qiskit uses graphs extensively. They are cleverly hidden from the end-user, but every quantum circuit is Qiskit is stored as a Directed Acyclic Graph (DAG). Take for example this circuit:\nThe same circuit can be represented in an equivalent form as a DAG:\nI hope this gives some insight on why DAGs are important to Qiskit. Every circuit is a DAG, and hence we need to manipulate them efficiently. That allows Qiskit to scale to handle deeper circuits and circuits with more qubits.\nHence, my mentorship was focused mainly on three things: optimizing graph algorithms in Retwork and transpile passes in Qiskit; adding new graph algorithms to Retworkx; and maintaining an open-source project in general (bug fixes, code reviews, code style, etc).\nNamely, my contributions were:\nPerformance \u0026amp; Optimization  Performance improvements for collect 2q blocks #6433 Add find successors by edge #319 Parallelize floyd warshall numpy with Rayon #291  Add New Methods and Algorithms  Add complement function #289 Add MST algorithms #282  Maintenance, Documentation and Bugfixes  Major rework in documentation #346 Format code with black #316 Fix floyd warshall numpy dispatcher #302  I will not dive deep into them, but I can affirm that after contributing I have a deeper understanding of how Qiskit works. That is very rewarding, and I might blog more about it later.\nQ: Why should people contribute to Qiskit? There are many reasons to choose from, I invite you to pick one from many:\n Impact: if your code is in Qiskit, it will be downloaded by thousands of people Purpose: help quantum computing grow via software development and research projects Connections: network with maintainers and researchers - a very good move to start in the QC field Personal Achievement: each contribution is a small victory, it is rewarding to overcome the challenges and see your work be accepted And the list goes on!  Q: Do you think your contributions will be relevant? Yes, I do. It is hard to measure, but I think most of the contributions to Qiskit are relevant, including. Do not let the fear that what you will do will not be important prevent you from starting. There is a lot of work to do in Qiskit - and they could use your help!\nTake for example the Retworkx API documentation. I wrote the new organization of the API documentation, it scales better and makes things easier to find. Retworkx has a few thousand users outside of Qiskit - they will read my work and hopefully find the docs clearer too! And so will people using Retworkx interally in Qiskit.\nQ: Do contributions need to be code? What are the options for people from a different background? No, contributions do not need to be code and Software Developers are not the only people that participate in the mentorship. I decided to do more software development because that is what I like. There are people from backgrounds . Some projects focus more on Technical Writing, Physics, Chemistry, or Finance for example.\nI will link to the The Ultimate Guide for Contributing to Qiskit — No Matter Your Background resource by Abby Mitchel. It outlines many ways to contribute - it can be writing code, creating a chapter on the textbook, translating documentation or even starting your own project using Qiskit.\nQ: How to get started? Ok, you have read me answering questions that lead to the conclusion: contributing to Qiskit is great. Perhaps you want to start doing it too. Where do you start? I think this can be split into two parts.\nWhat to work on?  Check the issues in the Qiskit repositories - e.g. Retworkx Issues. Select an issue which interests you - it could be one that you know how to solve or that you want to learn how to solve, for example Ask questions: talk to the maintainers and the user that opened the issue. What do you need to know to work on this? E.g. for code contributions, which part of the code do you need to change? Start working on it  Also, pro-tip: if you filter by Good First Issue, you will find beginner friendly issues. I recommend to start small with those begginer friendly issues and then keep growing it bigger.\nMoreover, if there is an idea you want to work on but is not in the repository issues: you can create your own ticket with the idea and explain it to maintainers. They will help you polish it such that you can start working on it and guide you. I always emphasize on talking to maintainers - they know the code and can help you spend your time in a smarter way.\nHow to start working on it?  Read the CONTRIBUTING file, each repo has their own e.g. this is Retowrkx's file - this will give you an idea of the development workflow Start coding - try to keep it focused on the specific issue you are working Submit a Pull Request with your work and maintainers will help you from there  More resources See How to Contribute to Open Source to see a general advice on how to contribute to open-source. Qiskit is an open-source project, so much of the advice transfer well.\n","date":1622750400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1622750400,"objectID":"707df03f5fffd3a53e1c3d8439d375e9","permalink":"https://ivaniscoding.github.io/posts/mentorship/","publishdate":"2021-06-03T12:00:00-08:00","relpermalink":"/posts/mentorship/","section":"posts","summary":"Q\u0026A about contributing to an open-source quantum computing library","tags":["quantum"],"title":"Qiskit Mentorship Program","type":"posts"},{"authors":null,"categories":null,"content":"","date":1613260800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613260800,"objectID":"2f23336989dd1b42bb6fc47649991eee","permalink":"https://ivaniscoding.github.io/project/asclepius/","publishdate":"2021-02-14T00:00:00Z","relpermalink":"/project/asclepius/","section":"project","summary":"A privacy-conscious health app that facilitates the flow of data among hospitals, patients, and their loved ones.","tags":["Demo"],"title":"\\@sclepius ![](/img/Badges/asclepius.svg)","type":"project"},{"authors":null,"categories":["Quantum"],"content":"This is the eighth post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to discuss Shor’s algorithm, an algorithm that can factorize big numbers quickly. For an integer \\(N\\), Shor’s algorithm can find a factor of it in \\(O((\\log_{} N)^{3})\\) which is an almost exponential speedup over classical algorithms. This algorithm brought a lot of interest into building quantum computers, because if an ideal quantum computer could be built, then the widely used public-key cryptography RSA scheme could be broken.\nA hybrid algorithm Shor’s algorithm is hybrid becasuse it mixes a classical part and a quantum part. In this blog post, we will discuss the mathematics behind the classical part and assume the quantum part as a black box. Later on, we will see that the speed up from Shor’s algorithm comes from the quantum part, where it solves the order finding problem i.e. finding the smallest \\(r\\) such that \\(a^{r} \\equiv 1 \\pmod N\\) faster than classical computers.\nFirstly, we need to define what the algorithm does. It solves the factorization problem: given an intenger \\(N\\), find two integers greater than one \\(P\\) and \\(Q\\) such that \\(PQ = N\\), or state that \\(N\\) is prime.\nSecondly, we need to define what the input of the algorithm is: it is \\(N\\), an odd integer that is neither a prime nor the power of a prime. These assumptions are necessary for the algorithm to work, and when they are not respected factorizing is still easy.\nIf \\(N\\) is even, we can pick \\(P = 2\\) and \\(Q = N/2\\) so the even case is straightforward.\nIf \\(N\\) is prime, we can check with primality tests such as Miller-Rabin’s for primality in a reasonable time complexity so this case is also easier than solving general factorization.\nIf \\(N\\) is the power of a prime, we can check for every \\(2 \\leq k \\leq \\log_{3}N\\) if \\(N^{1/k}\\) is an integer. If it is, then \\(P = N^{1/k}\\) and \\(Q = N^{(k-1)/k}\\) is a solution and the case for powers of primes is solved.\nLet’s now analyse the case when \\(N\\) is odd, not a prime nor the power of a prime that happens on the algorithm.\nMath concepts behind Shor’s algorithm To understand Shor’s algorithm, first we need to review modular arithmetic. We use the quotient-remainder theorem to write :\n\\[ a = N \\cdot k + r \\iff a \\equiv r \\pmod N \\iff N \\mid (a - r) \\]\nThen, we need to recall that if \\(a\\) and \\(N\\) are coprime, i.e. \\(\\gcd(a, N) = 1\\), there is a number \\(r\\) such that:\n\\[ a^{r} \\equiv 1 \\pmod N \\]\nNotice that the number \\(r\\) we defined so far is not unique: for example, if we take \\(t = 2r\\), then we have \\(a^{t} \\equiv 1\\) as well.\nTo prove that \\(r\\) exists, mathematicians generally use \\(\\phi(N)\\), the Euler’s totient function of \\(N\\). However, for Shor’s algorithm, we are not interested in an arbitrary \\(r\\): we want to find the smallest \\(r\\).\nWhy focus on the smallest \\(r\\) if it is easy to compute \\(\\phi(N)\\)? The fact is that the smallest \\(r\\) has a nice property that is key in our analysis. First, let’s rewrite our equation:\n\\[ a^{r} - 1 \\equiv 0 \\pmod N \\iff \\]\n\\[ (a^{r/2} + 1)(a^{r/2} - 1) \\equiv 0 \\pmod N \\iff \\]\n\\[ N \\mid (a^{r/2} + 1)(a^{r/2} - 1) \\]\nHere, we assumed that \\(r\\) is even, and that will be a requirement for our algorithm to work. Notice that \\(N \\nmid (a^{r/2} - 1)\\), because that would imply \\(a^{r/2} \\equiv 1\\) and violate our condition that \\(r\\) was the smallest. Thus, the prime factors of \\(N\\) are distributed among \\(a^{r/2} - 1\\) and \\(a^{r/2} + 1\\).\nThere are two cases. In the first one, we’re out of luck: if \\(N \\mid (a^{r/2} + 1)\\), then it might be that all the factors are on \\(a^{r/2} + 1\\) and we can conclude nothing about the prime factorization of \\(N\\).\nIn the second case, \\(N \\nmid (a^{r/2} + 1)\\) and we can make a conclusion: because \\(N\\) divides the product but not the numbers individually, at least one of \\(\\gcd(N, a^{r/2} + 1)\\) or \\(\\gcd(N, a^{r/2} - 1)\\) will be a non trivial factor of \\(N\\). Our factorization is done.\nThus, if finding \\(r\\) is done quickly, we can try multiple values for \\(a\\) until we found one that yields a factor. It can be shown that the probability that \\(a\\) works is at least \\(1/2\\), so with few attempts for \\(a\\) we will find a factor.\nAlgorithm and quantum subroutine Given the math concepts behind Shor’s algorithm, we can write the pseudo-code for the algorithm. Notice that in this step we are not worrying about the implementation of other parts of the algorithm: we assume that the classical parts of \\(\\gcd\\), primality-testing, checking if the k-th root is an integer are implemented and available for use. We also assume that the quantum subroutine for period finding is available for use. This yields the code:\n```{r} def shor_algorithm(N): “““Returns a pair of integers (P, Q) such that PQ = N for integer N”“”\nif N % 2 == 0: # even case return (N//2, 2) # trivial factorization if is_prime(N): # prime case return (N, 1) # N is prime, factors cannot be found if is_power_k(N): # prime power case k = find_power_k(N) # we find a k such that N**(1/k) is an integer P = N**(1/k) Q = N//P return (P, Q) # Now we can assume that the criteria for Shor\u0026#39;s algorithm is met while True: # Non-deterministic, we will try multiple values for a a = randint(2, N - 1) # pick random a if gcd(a, N) != 1: # Lucky case: a and N are not coprime! P = gcd(a, N) # gcd yields a non-trivial factor Q = N//P return (P, Q) r = order_finding(a, N) # quantum subroutine of the code if r % 2 == 0: continue # r is not even, try another value for a P = gcd(a**(r//2) - 1, N) if P != 1: Q = N//P # gcd yielded non trivial factor return (P, Q) ```\nImplementing Shor’s algorithm We can verify that Shor’s algorithm works using Python and running an experiment: in the Jupyter notebook below, we try to factorize some numbers. Notice that this code does not reach the optimal complexity, because order finding is done with classical computers instead of quantum computers. The code will be refined on the next blog posts.\n Next step The next step is to implement the quantum subroutine for period finding. To find the \\(r\\) for \\(a^{r} \\equiv 1 \\pmod N\\), we will need to learn two new things: the Phase Estimation algorithm and the Quantum Fourier Transform.\n","date":1595361600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1595361600,"objectID":"6e2b35fea7f493251d1279f636f8f1be","permalink":"https://ivaniscoding.github.io/posts/quantum8/","publishdate":"2020-07-21T12:00:00-08:00","relpermalink":"/posts/quantum8/","section":"posts","summary":"Factorizing numbers with quantum computers","tags":["quantum"],"title":"Quantum #8 - Mathematics Behind Shor's Algorithm","type":"posts"},{"authors":null,"categories":null,"content":"","date":1583452800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1583452800,"objectID":"0d9cd6a7a911d1069701c56d4d1513ec","permalink":"https://ivaniscoding.github.io/project/qgrooves/","publishdate":"2020-03-06T00:00:00Z","relpermalink":"/project/qgrooves/","section":"project","summary":"An app that lets users listen to qubits. It converts qubit states to sound waves, turning quantum algorithms into music.","tags":["Demo"],"title":"QGrooves ![](/img/Badges/qgrooves.svg)","type":"project"},{"authors":null,"categories":null,"content":"","date":1579392000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1579392000,"objectID":"679aabd4775065ce0ce50618d1570c04","permalink":"https://ivaniscoding.github.io/project/motiv_ai/","publishdate":"2020-01-19T00:00:00Z","relpermalink":"/project/motiv_ai/","section":"project","summary":"A voice-powered AI which helps users achieve their goals, and runs on both Alexa and Google Home devices.","tags":["Demo"],"title":"Motiv.ai ![](/img/Badges/motiv.svg)","type":"project"},{"authors":null,"categories":null,"content":"","date":1578873600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578873600,"objectID":"4cd2079d8b99884b79748a44546c1d69","permalink":"https://ivaniscoding.github.io/project/quantomoku/","publishdate":"2020-01-13T00:00:00Z","relpermalink":"/project/quantomoku/","section":"project","summary":"An educational game that teaches children basic concepts of quantum mechanics, and runs on real quantum computers.","tags":["Demo"],"title":"Quantomoku ![](/img/Badges/quantomoku.svg)","type":"project"},{"authors":null,"categories":null,"content":"","date":1578787200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578787200,"objectID":"5ad6abb92d6ef0a0a8d5e3043ac5f6cf","permalink":"https://ivaniscoding.github.io/project/quantum_kmeans/","publishdate":"2020-01-12T00:00:00Z","relpermalink":"/project/quantum_kmeans/","section":"project","summary":"An application of k-means clustering to U.S. electoral redistricting using D-Wave's quantum annealing computers.","tags":["Demo"],"title":"Quantum K-Means ![](/img/Badges/kmeans.svg)","type":"project"},{"authors":null,"categories":["Quantum"],"content":"This is the seventh post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to discuss Grover’s algorithm. It is an algorithm to solve unstructured search in \\(O(\\sqrt N)\\), which is a quadratic speedup over the classical \\(O(N)\\) solution.\nUnstructured Search Imagine that you have a hard problem to solve such that your best-known solutions is to try all the possibilities. That problem could be:\n Checking if two molecules are identical, i.e. solving graph isomorphism Finding the shortest route that passes through all cities, the travelling salesman problem  Classically, those are examples of unstructured search problems: the search space (i.e. possible solutions) has so little structure that the best strategy is just to try all possibilities.\nThe complexity of solving that problem depends on how big the search space is: if there are \\(N\\) elements to check, the algorithm needs to make \\(O(N)\\) to an oracle (i.e. the entity that verifies if a solution is valid). That is the best that can be done.\nThe quantum algorithm that will discuss today goes beyond: it can find the solution with \\(O(\\sqrt N)\\) checks. Considering that there is no structure in the search space, Grover’s algorithm provides an impressive speedup. Moreover, unlike the last two quantum algorithms we discussed, an unstructured search is the component of many real-world problems. Thus, Grover’s algorithm has immediate applications.\nFor our discussion today, we will pick a specific flavor of the search problem: we will try to find a needle in a haystack.\nNeedle in a haystack Imagine that you have a search space with \\(N\\) elements, with \\(N-1\\) straws that are useless, and exactly one needle that we are looking for.\nMathematically, the problem is described by a function \\(f\\):\n\\[ f(x) = 1 \\iff x = s \\]\n\\[ f(x) = 0 \\iff x \\neq s \\]\nIn which \\(s\\) is the solution string, i.e. the needle. Notice that \\(f\\) needs to be implemented by a quantum circuit, that we will call quantum oracle.\nSteps of the algorithm Now that we know the problem Grover’s algorithm solves, it is time to discuss it.\nAssumptions On this discussion, we will assume two things that might not always be true in a search problem:\n \\(N = 2^{n}\\), that is \\(N\\) is a power of two There is exactly one solution  Those assumptions are to simplify the discussion. Even though they are not always true, it is not hard to make a problem respect them.\nFor the first assumption, if we are given a \\(M\\) that is not a power of two, we can just augment the search space to a \\(N\\) that is a power of two and have :\n\\[ x \u0026gt; M \\implies f(x) = 0 \\]\nFor the second assumption, Grover’s algorithm can still find a solution when there is multiple: it is just the number of iterations \\(K\\) that will change.\nStep 1 Generate the superposition state:\n\\[ |\\psi\\rangle = \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}}|x\\rangle \\]\nAnd initialize the ancilla qubit to \\(\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}\\).\nNotice that on this step, each possible state \\(x\\) will have an equal probability of measurement, which is basically guessing the solution. The critical insight from Grover’s algorithm comes on the next step, in which we will try to improve the chance of measuring the solution.\nStep 2 Apply Grover’s iteration \\(K\\) times:\n Query the oracle. This is sometimes also called reflection around the solution. Invert about the mean. This is sometimes also called reflection around the superposition state.  The value \\(K\\) is given by \\(K \\approx \\frac{\\pi \\sqrt N}{4}\\). Thus, the algorithm makes \\(O(\\sqrt N)\\) queries to the oracle.\nStep 3 Measure the qubits. \\(s\\) will be the measurement with a high probability. A lower-bound for correctness is:\n\\[ P = 1 - \\frac{1}{N} \\]\nHence, for very big \\(N\\) our algorithm will guess the solution with a very high chance.\nGrover’s iteration At each iteration, Grover’s algorithm has a goal: to increase the amplitude \\(\\alpha_{s}\\) of the solution and to decrease the amplitude \\(\\alpha_{x}\\) of the non-solutions. To achieve it, it performs two specific steps as we will discuss.\nPhase kickback Consider that at an arbitrary iteration of the algorithm, we will have a state \\(|\\psi\\rangle\\):\n\\[ |\\psi\\rangle = \\sum_{x \\in \\{0, 1\\}^{n}}\\alpha_{x} |x\\rangle \\]\nGraphically, the amplitudes could be seen as:\nThe first step of the Grover iteration is to query the oracle. The oracle will be a transformation \\(|x\\rangle|a\\rangle \\rightarrow |x\\rangle|a \\oplus f(x)\\rangle\\).\nWe will now reuse a trick that was first discussed in Deutsch-Jozsa’s algorithm: because the ancilla is \\(\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}\\), then the phase will kickback in the form of a coefficient \\((-1)^{f(x)}\\), and the ancilla will remain unchanged.\nHence, that yields:\n\\[ U_{\\omega}|\\psi\\rangle = \\sum_{x \\in \\{0, 1\\}^{n}} (-1)^{f(x)} \\alpha_{x} |x\\rangle \\]\nNotice that this time, only one amplitude is negative: that of the solution. Graphically, it can be seen as:\nThe next step is to perform an inversion about the mean. The idea is that combining phase kickback with a mean inversion, we will make the amplitude of the solution grow while reducing the amplitude of nonsolutions.\nInversion about the mean An inversion about the mean is reflecting the terms of a sequence \\(C\\) according to the mean \\(\\overline{C}\\). That is, we will find a new sequence \\(D\\) such that each term is \\(C_{i}\\) reflected.\nImagine that you have an element \\(C_{i}\\). We will find a new element \\(D_{i}\\) such that the distance between \\(D_{i}\\) and \\(\\overline{C}\\) is the same as the distance between \\(C_{i}\\) and \\(\\overline{C}\\). Mathematically, that can be written as:\n\\[ |D_{i} - \\overline{C}| = |C_{i} - \\overline{C}| \\]\nSolving the equation and ignoring the case in which \\(C_{i} = D_{i}\\), we obtain:\n\\[ D_{i} = 2\\overline{C} - C_{i} \\]\nAfter the mean inversion transformation, \\(\\overline{D} = \\overline{C}\\) holds as well.\nAt this point, you might be asking: what does mean inversion has to do with quantum computing? To answer that question, an example will do. Suppose that we have the sequence \\(\\{1, 1, 1, 1\\}\\) and we flip the sign of the third 1, that is we have:\n\\[ C = \\{1, 1, -1, 1\\} \\]\nThe mean of this sequence is \\(\\frac{1}{2}\\). Now if we compute mean inversion using the formula given before, we obtain:\n\\[ D = \\{0, 0, 2, 0\\} \\]\nSomething very interesting occurred: during the inversion, the only negative value of the sequence became the most positive while the old positives values diminished.\nHence, mean inversion combined with phase kickback is exactly what we were looking for: it is going to make \\(\\alpha_{s}\\) increase and decrease \\(\\alpha_{x}\\) of the nonsolutions.\nContinuing the amplitude visualization we had before, mean inversion yields:\nTherefore, the idea is to perform phase kickback and mean inversion until \\(\\alpha_{s}\\) is maximized. We will not discuss the math behind, but it turns out that \\(\\frac{\\pi \\sqrt N}{4}\\) iterations suffice.\nImplementing the quantum oracle In real applications, the oracle would be a circuit that performs a meaningful computation: it could be solving the travelling salesman problem, trying to break an encryption key or just solving a hard problem in general.\nFor this example problem, we will emulate a real-world problem: we will have a function that has one value \\(s\\) such that \\(f(s) = 1\\) and that \\(f(x) = 0\\) for all other \\(x\\).\nClassically, it would look like:\ndef f(x):  if x == s:  return 1  else:  return 0 The question now is: how does a quantum computer check that the state \\(x\\) is equal to \\(s\\)? The answer is: we verify if the binary representation of \\(x\\) is identical to the binary representation of \\(s\\).\nTo do so, we use a multi-qubit Toffoli gate: we AND the equality of each bit. Because of the AND property, \\(f(x) = 1\\) if and only if each bit of \\(x\\) is equal to \\(s\\), otherwise \\(f(x) = 0\\). That implements exactly what we were looking for.\nA factor to consider is that if a bit is 0, we need to NOT it so when the AND is done the result is 1. Hence, the circuit implementing \\(f\\) for a string \\(s\\) looks like:\nNotice that after applying the Toffoli, we do not want to change \\(|x\\rangle\\) hence we apply NOT again on what was NOTed before.\nImplementing inversion about mean To implement inversion about the mean, we will use the Grover diffusion operator. I will not discuss it much, but the operator can be written as:\n\\[ \\mathcal{D} = -H^{\\otimes n}U_{s}H^{\\otimes n} \\]\nThe idea is to implement the formula \\(2\\overline{C} - C_{i}\\) using matrix multiplication. It can be shown that \\(\\mathcal{D} = 2|+\\rangle\\langle+| - I\\), which is the matrix equivalent of the formula we found for mean inversion.\nAn element of \\(\\mathcal{D}\\) we have not discussed yet is \\(U_{s}\\): it is similar to the oracle \\(U_{\\omega}\\). It implements a function \\(g(x)\\) such that \\(g(000...0) = 1\\) and \\(g(x) = 0\\) for all other \\(x\\).\nTherefore, we also use a multi-qubit Toffoli gate to implement \\(U_{s}\\) which yields the following circuit for \\(\\mathcal{D}\\):\nImplementing Grover’s algorithm We can verify that Grover’s algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try to find a needle in a haystack.\n ","date":1578010200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1578010200,"objectID":"3b24bbf23920678999936af30735c1b6","permalink":"https://ivaniscoding.github.io/posts/quantum7/","publishdate":"2020-01-02T16:10:00-08:00","relpermalink":"/posts/quantum7/","section":"posts","summary":"Finding a needle in a haystack with a quantum search algorithm","tags":["quantum"],"title":"Quantum #7 - Grover","type":"posts"},{"authors":null,"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"f3e956af5322488dde4f7d1ce42642db","permalink":"https://ivaniscoding.github.io/project/quantum/","publishdate":"2020-01-01T00:00:00Z","relpermalink":"/project/quantum/","section":"project","summary":"A hands-on approach to quantum computing: Jupyter notebooks discussing quantum algorithms.","tags":["Demo"],"title":"Quantum ![](/img/Badges/quantum.svg)","type":"project"},{"authors":null,"categories":["Quantum"],"content":"This is the sixth post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to discuss how to discover a hidden string in a black box using Bernstein-Vazirani’s algorithm. There is also a connection between this algorithm and Deutsch-Jozsa’s algorithm, which was discussed in the last post.\nDecoding a hidden string Imagine that you have a black box (or oracle) that implements a hidden function that takes n-bit strings and returns 0 or 1, that is \\(f: \\{0, 1\\}^{n} \\rightarrow \\{0, 1\\}\\). The output of the function is determined by a hidden string \\(s\\), following the expression:\n\\[ f(x) = s \\cdot x \\mod 2 \\]\nHow many queries are needed to discover \\(s\\)?\nTo clarify the notation used, by \\(s \\cdot x\\) we mean the bitwise dot product of \\(s\\) and \\(x\\). Mathematically, if \\(s = a_{0}a_{1}a_{2}...a_{n-1}\\) and \\(x = b_{0}b_{1}b_{2}...b_{n-1}\\) then we define:\n\\[ s \\cdot x = \\sum_{0}^{n-1} a_{i}b_{i} \\]\nFrom now on in the post, I will also write \\(s \\cdot x\\) instead of \\(s \\cdot x \\mod 2\\) for convenience. Some authors even define \\(s \\cdot x\\) as the sum mod 2.\nClassical approach Before discussing the quantum solution to the problem, it is important to understand the classical solution. We can interpret \\(f\\) as a function that computes the bitwise AND of \\(s\\) and \\(x\\), and then counts the parity of turned on bits on \\(s \\wedge x\\).\nHence, when we are trying to discover \\(s\\) by evaluating \\(f(x)\\), it is never advantageous to have \\(x\\) with many bits turned on because we only obtain the parity of it.\nA good strategy then is to use \\(x\\) with only one bit set on, that is \\(x \\in \\{100..., 010..., 001.., ...\\}\\). The Python code below implements exactly that idea:\ndef guess_hidden_string(f, n):   s = 0   for i in range(n):  result = f(2**i)  if result == 1:  s += 2**i   return s This approach needs n queries to discover the n-bit hidden string, and overall \\(O(n)\\) is the best we can achieve with classical computers. Can quantum computers do better?\nImplementing the quantum oracle Before we try to find a quantum solution, we will briefly discuss how to implement the quantum oracle because that step is needed to implement the actual algorithm.\nOne key fact when implementing the oracle was discussed in the section before: \\(f\\) can be interpreted as discussing the parity of set bits of the bitwise AND. Hence, we may write:\n\\[ f(x) = (\\sum_{0}^{n-1} a_{i} \\wedge b_{i}) \\mod 2 \\]\nRecalling that the XOR operator (\\(\\oplus\\)) can be seen as the plus operator mod 2, we can go even further and write:\n\\[ f(x) = (a_{0} \\wedge b_{0}) \\oplus (a_{1} \\wedge b_{1}) \\oplus ... \\oplus (a_{n-1} \\wedge b_{n-1}) \\]\nThe XOR operator is represented by the CNOT gate on quantum computing, because it takes \\(|a\\rangle\\) to \\(|a \\oplus b\\rangle\\). Thus, our quantum oracle looks like the following:\nFor every bit \\(a_{i} = 1\\) in \\(s\\), we apply the CNOT gate from the i-th qubit to the working qubit. That happens because if \\(a_{i} = 0\\), then \\(a_{i} \\wedge b_{i} = 0\\) and \\(x \\oplus 0 = x\\) thus we can ignore it. CNOT gates are used because they are the equivalent of \\(\\oplus\\), as discussed before.\nBernstein-Vazirani This time, we will start by giving the solution to the problem. We will very computationally that it works and then justify it mathematically.\nThe following circuit guesses the hidden string:\nFirstly, we change the working qubit from \\(|0\\rangle\\) to \\(|1\\rangle\\) by using the X gate.\nSecondly, we apply Hadamard gates to the n qubits. That state is then given to the quantum oracle.\nIn the next step, the oracle yields the \\(f(x)\\) for the working qubit of each state, and that qubit is discarded afterward.\nTo conclude the algorithm, we apply Hadamard gates again and measure the qubits. It is guaranteed that 100% of the measurements will be \\(s\\), the hidden string we were looking for. We will analyze later why \\(|s\\rangle\\) is the state that originates after querying the oracle.\nNotice that we discovered the hidden string using only one query to the oracle, compared to the \\(O(n)\\) queries required by the classical algorithm.\nImplementing the Bernstein-Vazirani algorithm We can verify that the Bernstein-Vazirani algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try to guess a hidden string from a black box.\n Analysis: why the circuit works The first step in the analysis is to notice that the circuit used in Bernstein-Vazirani’s algorithm is identical to the circuit in Deutsch-Jozsa’s algorithm. That is surprising at first because one algorithm works to find a hidden string and the other to distinguish between balanced and constant functions.\nNow, we will use a result from the discussion on the last post, to remember that the state after querying the oracle is:\n\\[ |\\psi\\rangle = \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}} (-1)^{f(x)}|x\\rangle \\]\nBut this time, we know that our oracle is described by \\(f(x) = s \\cdot x\\). Thus:\n\\[ |\\psi\\rangle = \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}} (-1)^{s \\cdot x}|x\\rangle \\]\nWe will now claim that:\n\\[ H^{\\otimes n} |\\psi\\rangle = |s\\rangle \\]\nThat is, that applying the Hadamard gate to each qubit takes us from \\(|\\psi\\rangle\\) to \\(|s\\rangle\\).\nTo prove so, we will work backwards. Because \\(H\\) is the inverse gate of itself, then \\(H^{\\otimes n}\\) is the inverse of \\(H^{\\otimes n}\\). Thus, proving our claim is equivalent to showing that:\n\\[ H^{\\otimes n} |s\\rangle = \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}} (-1)^{s \\cdot x}|x\\rangle \\]\nIt would be useful to find a formula for \\(H^{\\otimes n} |s\\rangle\\) . We can start by finding a formula for \\(H\\), that is:\n\\[ H |a\\rangle = \\frac{|0\\rangle + (-1)^{a}|1\\rangle}{\\sqrt 2} \\]\nThe identity can be proved by verification of \\(a = 0\\) and \\(a = 1\\). We can even go further and write:\n\\[ H |a\\rangle = \\frac{1}{\\sqrt 2} \\sum_{b \\in \\{0, 1\\}} (-1)^{ab}|b\\rangle \\]\nNow that we have an identity for \\(n = 1\\), it would be useful to generalize for greater values of n. For \\(n = 2\\), we can think of the multiple qubits as tensor products and thus:\n\\[ H^{\\otimes 2}|a,c\\rangle = (\\frac{1}{\\sqrt 2} \\sum_{b \\in \\{0, 1\\}} (-1)^{ab}|b\\rangle) \\otimes (\\frac{1}{\\sqrt 2} \\sum_{d \\in \\{0, 1\\}} (-1)^{cd}|c\\rangle) \\]\nWe may rewrite it in a formula closer to the \\(s \\cdot x\\) product we defined earlier, that is:\n\\[ H^{\\otimes 2}|s\\rangle = \\frac{1}{(\\sqrt 2)^{2}} \\sum_{x \\in \\{0, 1\\}^{2}} (-1)^{s_{0}x_{0} + s_{1}x_{1}}|x\\rangle \\]\nBecause of the cycle of powers of -1, \\((-1)^{a} = (-1)^{a \\mod 2}\\) and thus the -1 exponent is \\(s \\cdot x\\)! Therefore, we may generalize to all \\(n\\) (the proof can be done by induction):\n\\[ H^{\\otimes n}|s\\rangle = \\frac{1}{(\\sqrt 2)^{n}} \\sum_{x \\in \\{0, 1\\}^{n}} (-1)^{s\\cdot x}|x\\rangle \\]\nHence, our circuit works because it takes \\(|\\psi\\rangle\\) to \\(|s\\rangle\\) due to the inverse nature of \\(H^{\\otimes n}\\).\nThe connection between Deutsch-Jozsa’s and Bernstein-Vazirani’s algorithm becomes clearer then:\n \\(f(x) = s \\cdot x\\) is a balanced function (or constant if \\(s\\) is all zeroes)! If a black box from Deutsch-Jozsa’s returns a state \\(|s\\rangle\\) with 100% chance, then the black box implements \\(f(x) = s \\cdot x\\)  ","date":1577592600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577592600,"objectID":"0d62f3ec4b5fc486d7d0a777fc4c1cee","permalink":"https://ivaniscoding.github.io/posts/quantum6/","publishdate":"2019-12-28T20:10:00-08:00","relpermalink":"/posts/quantum6/","section":"posts","summary":"Guessing a hidden string using quantum computers","tags":["quantum"],"title":"Quantum #6 - Bernstein-Vazirani","type":"posts"},{"authors":null,"categories":["Quantum"],"content":"This is the fifth post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to continue the discussion of the Deutsch-Jozsa algorithm, starting off where we stopped on part 1.\nDeutsch-Jozsa problem After having introduced the Deutsch problem, we will now introduce the Deutsch-Jozsa which is a generalization of the Deutsch problem. In particular, the Deutsch problem is the case of Deutsch-Jozsa with \\(n = 1\\).\nImagine that you have a black box that implements a function from n-bit strings (e.g. 11010) to 0 or 1, that is \\(f : \\{0, 1 \\}^{n} \\rightarrow \\{0, 1\\}\\). It is guaranteed that \\(f\\) is either a balanced or a constant function. You can make a query to the black box with a value \\(v\\), and the black box will return \\(f(v)\\). How many queries are needed to decide if the function is constant or balanced?\nJust remembering definitions, a function is balanced when the number of values that have \\(f(v) = 0\\) is equal to the number of values that have \\(f(v) = 1\\).\nThis time, we have way more than 4 possible functions, more precisely \\(2(\\binom{2^{n}}{2^{n-1}} + 1)\\). Our classical strategy also needs more queries to classify the function. To deterministically determine the type of the function, we need \\(O(2^{n})\\) queries because the worst case is when we obtain \\(2^{n-1}\\) of 0s (or 1, it is symmetric) and still need an additional query to distinguish between balanced or constant.\nFrom a perspective using classical computers, that is (deterministically) the best we can do. A question that arises is: can quantum computers do better? It can be shown that yes, they can. And the speedup is impressive.\nGeneralazing the solution for multiple bits We now need to try to generalize our solution from \\(n = 1\\) to larger values of \\(n\\). It is worth trying the same solution but now using multiple bits, i.e. to apply a Hadamard to every qubit to generate all possible values, evaluate using the black box, and lastly apply Hadamard gates before measuring. The circuit we obtain looks like:\nWe now need to decide if the circuit provides criteria similar to the previous solution to differentiate between. It is helpful to expand the math to analyze that. After applying the Hadamard gates we have:\n\\[ |\\psi\\rangle = |00...0\\rangle|0\\rangle \\rightarrow H^{\\otimes N}|\\psi\\rangle \\otimes (\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}) \\]\n\\[ \\rightarrow \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}} |x\\rangle \\otimes (\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}) \\]\nWe then send the input to the blackbox, that yields:\n\\[ \\rightarrow \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}} |x\\rangle \\otimes (\\frac{|0 \\oplus f(x)\\rangle - |1 \\oplus f(x)\\rangle}{\\sqrt 2}) \\]\n\\[ \\rightarrow \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}} (-1)^{f(x)}|x\\rangle \\otimes (\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}) \\]\nLike in the last analysis, we used the identity \\(|0 \\oplus a \\rangle - |1 \\oplus a \\rangle = (-1)^{a}(|0\\rangle - |1\\rangle)\\). We also obtained a similar result: the last qubit does not change, so measuring it is useless and we will not worry about it afterwards.\nGiven that now we have a mathematical expression representing the state of the qubits, we can analyse the two possible cases before measuring.\nConstant case If \\(f\\) is constant, then all the \\(x\\) in the sum before will have the same sign, which can be summarized as:\n\\[ |\\psi\\rangle = \\pm \\frac{1}{\\sqrt 2 ^ {n}}\\sum_{x \\in \\{0, 1\\}^{n}} |x\\rangle \\]\nNotice that multiplying the whole expression by -1 does not affect the measurements because it is a global phase change. The state that happens on the balanced case after applying the black box is then:\n\\[ |\\psi\\rangle = (\\frac{|0\\rangle + |1\\rangle}{\\sqrt 2})^{\\otimes n} \\]\nNotice that when we apply the Hadamard gates before measuring, each \\(\\frac{|0\\rangle + |1\\rangle}{\\sqrt 2}\\) becomes \\(|0\\rangle\\) and therefore the final state is \\(|00...0\\rangle\\).\nHence, we are sure that if \\(f\\) is constant then all measurements will always be 0.\nBalanced case We now need to analyse the other case, when there is no guarantee that all \\(|x\\rangle\\) will have the same sign. Indeed, we do not know anything about \\(f\\) (just that the number of 0s and 1s is the same) so it is difficult to know the exact probability of an arbitrary state \\(|x\\rangle\\).\nOne thing we know though is that \\(|00...0\\rangle\\) is always the output of the other case, i.e. the constant case. We may then ask: what is the probability that this case, the balanced case, will output \\(|00...0\\rangle\\)?\nTo analyze that we need to calculate the coefficient \\(\\alpha\\) of \\(|\\psi\\rangle = \\alpha|00...0\\rangle + ...\\) after applying all the Hadamard gates, which can be seen as multiplying by \\(H^{\\otimes n}\\).\nOne key property of \\(H^{\\otimes n}\\) is that the first line, the line that will give the \\(\\alpha\\) of the final \\(|\\psi\\rangle\\), has constant terms i.e. they are equal. More exactly, all terms of the first line of \\(H^{\\otimes n}\\) are \\((\\sqrt 2) ^ {-n}\\). This fact can be shown by induction and I will just use it, not prove it.\nGiven that all terms of the first line are \\((\\sqrt 2) ^ {-n}\\), the \\(\\alpha\\) we obtain is:\n\\[ \\alpha = \\frac{1}{\\sqrt 2 ^ {n}} \\frac{1}{\\sqrt 2 ^ {n}} \\sum_{x \\in \\{0, 1\\}^{n}} (-1)^{f(x)} \\]\nNow the fact that the function is balanced becomes crucial. Because the number of \\(f(x) = 0\\) and \\(f(x) = 1\\) are equal, the sum above is zero! Hence, \\(\\alpha\\) is zero and therefore there is no \\(|00...0\\rangle\\) component in the final state. Because of that, we are guaranteed that not all measurements will be 0, which means that at least one of the measurements will be 1.\nThus, the circuit we used provides criteria to classify \\(f\\):\n If all the measurements are 0, then \\(f\\) is constant If at least one of the measurements is 1, then \\(f\\) is balanced  The problem has been solved! The most impressive fact is that only 1 query was used, instead of \\(O(2^{n})\\) queries. That is an exponential speedup.\nImplementing the Deutsch-Jozsa algorithm We can verify that the Deutsch-Jozsa algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try three cases for the black box and verify that our algorithm predicts correctly that it is balanced or constant.\n So what? You might ask: what is the point of the Deutsch-Jozsa algorithm? The algorithm solves a very artificial and useless problem. It has very little practical applications.\nThe algorithm, in my personal opinion, exemplifies the beauty of quantum computing: it provides an exponential speedup! Not only the speedup is impressive, but it is also unachievable by classical computers. It is one of the first algorithms from a yet-to-be-explored field.\nIt also exemplifies the less beautiful aspects of it. As of now, quantum computing… is useless. The Deutsch-Jozsa problem is a toy problem to show that two complexity classes for algorithms are different, and that is it. No applications. Not to mention that with Noisy Quantum Computers even running simple algorithms like Deutsch-Jozsa can have errors (qubits and gates are still not perfect).\nHowever, the algorithm still has historical importance and inspired other algorithms that have more practical applications, like Shor’s algorithm for factorizing numbers. Hence, it is still important to study the problem.\nA randomized approach In the initial discussion, we highlighted the deterministic factor. As a side note, we can have a probabilistic algorithm that solves the problem most of the time with an error rate \\(\\epsilon\\). If \\(k\\) queries are made to the black box, \\(\\epsilon = 2^{-(k - 1)}\\). Because the decrease in \\(\\epsilon\\) is exponential, with a constant and small value of \\(k\\) we can classify with great confidence. Below is Python code implementing that idea (\\(f\\) is the function, \\(n\\) is the number of bits and \\(k\\) is the number of tries before we stop).\nfrom random import randint  def balanced_or_constant(f, n, k):   first_guess = f(randint(0, 2**n - 1))   for i in range(k-1):  guess = f(randint(0, 2**n - 1))  if guess != first_guess:  return \u0026quot;balanced\u0026quot;   return \u0026quot;constant\u0026quot; ","date":1577520600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577520600,"objectID":"67c528da239285441d341227572c046d","permalink":"https://ivaniscoding.github.io/posts/quantum5/","publishdate":"2019-12-28T00:10:00-08:00","relpermalink":"/posts/quantum5/","section":"posts","summary":"Is there an advantage in using quantum computers?","tags":["quantum"],"title":"Quantum #5 - Deutsch-Jozsa (part 2)","type":"posts"},{"authors":null,"categories":["Quantum"],"content":"This is the fourth post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to discuss the Deutsch-Jozsa algorithm, which was one of the very first quantum algorithms. Even though it solves a very artificial problem, its main purpose is to answer: is there an advantage in using quantum computers? The answer is yes.\nDeutsch problem Before diving into the Deutsch-Jozsa algorithm, let’s discuss the Deutsch problem which is a special case solved by the algorithm. It is a problem that can be summarized as:\nImagine that you have a black box that implements a function \\(f : \\{0, 1 \\} \\rightarrow \\{0, 1\\}\\). You can make a query to the black box with a value \\(v\\), and the black box will return \\(f(v)\\). How many queries are needed to decide if the function is constant or balanced? A balanced function is when the number of values that have \\(f(v) = 0\\) is equal to the number of values that have \\(f(v) = 1\\).\nThere are four possible \\(f\\) functions, all listed below:\n  Function Values Classification    \\(f_{0}\\) \\(f(0) = 0\\) and \\(f(1) = 0\\) Constant  \\(f_{1}\\) \\(f(0) = 0\\) and \\(f(1) = 1\\) Balanced  \\(f_{2}\\) \\(f(0) = 1\\) and \\(f(1) = 0\\) Balanced  \\(f_{3}\\) \\(f(0) = 1\\) and \\(f(1) = 1\\) Constant    It turns out that to classify the function implemented by the black box, we need to use two queries. When we do one query, we go from four possible functions to two functions, one which will be balanced and the other constant. Thus, we need an additional query to decide which one it is, totaling two queries.\nFrom a perspective using classical computers, that is the best we can do. A question that arises is: can quantum computers do better? It can be shown yes, they can.\nQuantum black box Before we continue, it is important to discuss what a quantum black box is. It acts similarly to the classical black box we had before: it takes qubits and spits the result. Because the black box implements a function that might not have a unitary matrix and quantum circuits are composed only of unitary matrices, we need to use a working qubit to store the result of the black box.\nThus, we define the black box as a transformation \\(|v\\rangle|0\\rangle \\rightarrow |v\\rangle|f(v)\\rangle\\), or even more detailed \\(|v\\rangle|w\\rangle \\rightarrow |v\\rangle|w \\oplus f(v)\\rangle\\) to handle the case with 1 (\\(\\oplus\\) is the XOR operator).\nAn interesting aspect of the quantum black box is that it allows us to achieve something that would be impossible with a classical computer: ask \\(f(0)\\) and \\(f(1)\\) at the same time! How? Well, consider a state with a superposition such as \\(\\frac{(|0\\rangle + |1\\rangle)}{\\sqrt 2}\\). If we give that qubit to the black box, a part of our working qubit will have \\(f(0)\\) and the other will have \\(f(1)\\). Maybe then, we can find a clever way to recover both at the same time and classify the function with only one query!\nOne concern that might come now: is it even fair to compare a quantum black box to a classical black box? The answer is: it is reasonable. Even with a quantum black box, classical computers still need 2 queries because they cannot exploit superpositions, hence it is reasonable to compare.\nExploiting superposition Now that we know that we need to use superposition in our solution, it is tempting to use a circuit like the following:\nIn this circuit, we generate a superposition, then apply the black box and after we measure our result. It is a very simple circuit and the core ideas of the real solution are on it. Even though it seems promising, it fails. It cannot differentiate balanced functions.\nTo understand why, consider the case for constant. If the value is always 0, our measure for the qubit will also be always zero. If it is 1, similarly, it will always be one. But for balanced, we have 50% for each case so in practice we cannot differentiate constant and balanced functions.\nWe could try to measure the balanced case by, let’s say, applying a Hadamard gate :\nThis solves the problem for balanced functions: now, due to the Hadamard gate, they will always output the same measurement 100% of the time. But our constant functions will now measure 50% of the times 0 and 50% of the times 1, so we still have the same problem as before. We need a more elaborate solution.\nDeutsch algorithm We will now analyze the circuit that the following circuit solves the problem:\nTo understand why, we can expand the algebra of the circuit. We have the following state after applying the \\(X\\) and Hadamard gates:\n\\[ |\\psi\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt 2} \\otimes \\frac{|0\\rangle - |1\\rangle}{\\sqrt 2} \\]\nAfter applying the black box, we obtain:\n\\[ \\rightarrow \\frac{|0\\rangle (|0 \\oplus f(0)\\rangle - |1 \\oplus f(0)\\rangle)}{2} + \\frac{|1\\rangle (|0 \\oplus f(1)\\rangle - |1 \\oplus f(1)\\rangle)}{2} \\]\nWe are then going to use the following identity to help rewrite our expression in a convenient way:\n\\[ |0 \\oplus a \\rangle - |1 \\oplus a \\rangle = (-1)^{a}(|0\\rangle - |1\\rangle) \\]\nWe can verify that the expression is valid when \\(a\\) is 0 or 1. Therefore, we get:\n\\[ \\rightarrow \\frac{(-1)^{f(0)}|0\\rangle (|0\\rangle - |1\\rangle)}{2} + \\frac{(-1)^{f(1)}|1\\rangle (|0\\rangle - |1\\rangle)}{2} \\]\n\\[ \\rightarrow \\frac{(-1)^{f(0)}|0\\rangle + (-1)^{f(1)}|1\\rangle}{\\sqrt 2} \\otimes \\frac{|0\\rangle - |1\\rangle}{\\sqrt 2} \\]\nThis form is convenient because it tells us two things. The first is that the second qubit does not change, so measuring it is useless. The second is that the first qubit depends on the classification of the function:\n If \\(f\\) is constant, the qubit will be \\((\\pm 1)\\frac{|0\\rangle + |1\\rangle}{\\sqrt 2}\\). Because having a minus sign does not matter (it is a global phase change), we can say that the qubit will always be \\(\\frac{|0\\rangle + |1\\rangle}{\\sqrt 2}\\) If \\(f\\) is balanced, the qubit will be \\((\\pm 1)\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}\\). Because having a minus sign does not matter (it is a global phase change), we can say that the qubit will always be \\(\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}\\)  To differentiate between \\(\\frac{|0\\rangle + |1\\rangle}{\\sqrt 2}\\) and \\(\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}\\), we need to apply a Hadamard gate. The first case will become a \\(|0\\rangle\\) and the second case will become \\(|1\\rangle\\), so using the circuit we presented before we can decide using the rule:\n If the measurement of the first qubit is \\(0\\), we have a constant function Otherwise, if the measurement of the qubit is \\(1\\), we have a balanced function  The problem has been solved! With just one query, an achievement that would be impossible with classical computers.\nImplementing the Deutsch algorithm We can verify that the Deutsch algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try the four possible cases for the black box and verify that our algorithm predicts correctly that it is balanced or constant.\n Next step The next step is to generalize the problem from 1-bit functions to n-bit functions, and that is what will happen in the second part of the blog post about the Deutsch-Jozsa algorithm.\n","date":1577412000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577412000,"objectID":"9624abe814206d63e92c3fe00cab0040","permalink":"https://ivaniscoding.github.io/posts/quantum4/","publishdate":"2019-12-26T18:00:00-08:00","relpermalink":"/posts/quantum4/","section":"posts","summary":"Is there an advantage in using quantum computers?","tags":["quantum"],"title":"Quantum #4 - Deutsch-Jozsa (part 1)","type":"posts"},{"authors":null,"categories":["Quantum"],"content":"This is the third post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to discuss superdense coding, which can be seen as the opposite of quantum teleportation.\nSending bits with qubits Imagine that Alice wants to send two classical bits \\(b_{0}b_{1}\\) to Bob. Alice could do that in more standard ways, but instead, Alice chooses to send a qubit to Bob. Is there a way we can guarantee that Bob will always decode \\(b_{0}b_{1}\\)? The answer is yes, and to communicate in such a non-standard way, Alice and Bob just need to follow an algorithm that is called Superdense Coding:\nEntangle Alice’s and Bob’s qubit Encode the bits Alice wants to send using quantum gates, and then send the qubit to Bob Apply the same gates from the entanglement procedure, but in inverted order Measure the two qubits  Notice that superdense coding can be seen as the opposite of teleportation. In teleportation, we share an entangled state and send two classical bits to recover a qubit. Superdense coding, on the other hand, uses an entangled state and sends a qubit to recover two classical bits. Thus, the processes are complementary.\nPreparing the Bell state The first step of the algorithm is to prepare the entangled state \\(\\vert\\Phi^{+}\\rangle\\), one of the Bell states. We discussed that on the quantum teleportation, so if you want a detailed explanation I encourage you to check it out there. What we need to remember is that we work with the state:\n\\[ \\vert\\Phi^{+}\\rangle = \\frac{\\vert 00 \\rangle + \\vert 11 \\rangle}{\\sqrt 2} \\]\nThat is generated by the circuit:\nAfter generating \\(\\vert\\Phi^{+}\\rangle\\), we send one of the qubits to Alice and the other one to Bob.\nEncoding classical information on a qubit Now that Alice has one of the qubits of \\(\\vert\\Phi^{+}\\rangle\\), she can try to encode \\(b_{0}b_{1}\\) into the qubit by applying quantum gates.\nTo do so, she needs to find a clever way of applying a gate that after applying the inverted entanglement again, will give Bob the bits we were trying to send, i.e. the measurement of the first qubit will always be \\(b_{0}\\) and the second will always be \\(b_{1}\\).\nTo make it clearer, let’s take for example the \\(|00\\rangle\\) case. We need to find a gate \\(G\\) such that:\n\\[ (H \\otimes I)(CNOT)(G \\otimes I)\\vert\\Phi^{+}\\rangle = |00\\rangle \\]\nWe can then write the \\(G\\) matrix in the function of 4 unknown variables and recall that \\(G G^{\\dagger} = I\\) to solve for \\(G\\). It turns out that for \\(|00\\rangle\\), \\(G = I\\). That makes sense because applying the inverted entanglement circuit on the \\(\\vert\\Phi^{+}\\rangle\\) untangles it.\nWe would need to do the same for \\(|01\\rangle\\), \\(|10\\rangle\\), and \\(|11\\rangle\\). The table below summarizes the results we would get:\n  \\(b_{0}b_{1}\\) Gate to apply    \\(00\\) \\(I\\) (no gates)  \\(01\\) \\(X\\)  \\(10\\) \\(Z\\)  \\(11\\) \\(X\\) and then \\(Z\\)    One curious connection to notice between quantum teleportation and superdense coding is that the table to apply the gates based on the bits is identical for both algorithms.\nDecoding classical information from a qubit After Alice is done encoding, she sends her qubit to Bob. Bob applies then the same gates we used to generate\\(\\vert\\Phi^{+}\\rangle\\) but in inverted order. That is, we apply the CNOT gate and then Hadamard gate on the first qubit as in the circuit below:\nThen, Bob measures the qubits. Because of the way we designed the gates in the last section, we are sure that the measurement of the first qubit will be \\(b_{0}\\) and the second will be \\(b_{1}\\). Hence, Bob has successfully received two bits of classical information! With just 1 qubit.\nVerifying superdense coding computationally We can verify that superdense coding works using Qiskit and running an experiment: in the Jupyter notebook below, we try the 4 different cases of bits that we can send.\nEvery step explained above is done, and the results match our prediction.\n ","date":1577167200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577167200,"objectID":"1bf9637a1f56b49a07252be8cb17cbe0","permalink":"https://ivaniscoding.github.io/posts/quantum3/","publishdate":"2019-12-23T22:00:00-08:00","relpermalink":"/posts/quantum3/","section":"posts","summary":"Teleportation's less famous sibling","tags":["quantum"],"title":"Quantum #3 - Superdense Coding","type":"posts"},{"authors":null,"categories":["Quantum"],"content":"This is the second post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to discuss quantum teleportation, one of the most basic protocols for communication in quantum computing.\nTeleportation and the problem it solves Imagine that Alice has a qubit \\(| \\psi \\rangle = \\alpha | 0 \\rangle + \\beta | 1 \\rangle\\), where both \\(\\alpha\\) and \\(\\beta\\) are unknown. Alice needs to send the qubit to Bob that is located somewhere far away. How does Alice do that?\nOne simple answer could be to measure \\(\\alpha\\) and \\(\\beta\\) and send the information. However, that does not work because:\n We may need an infinite amount of bits to represent \\(\\alpha\\) and \\(\\beta\\) (e.g. think about encoding \\(\\pi\\) in binary, it has an infinite length) Every time we measure a qubit, it becomes either \\(|0\\rangle\\) or \\(|1\\rangle\\) and all its information is lost.  Having ruled out measurement, we may ask: is it even possible to send \\(|\\psi\\rangle\\)? The answer is, surprisingly, yes. To do so, we need two extra qubits, one for Alice and one for Bob, and to follow a simple algorithm:\nEntangle Alice’s and Bob’s qubit Apply a CNOT gate with \\(|\\psi\\rangle\\) as the control qubit and Alice’s qubit as the target Apply a Hadamard gate to \\(|\\psi\\rangle\\) and measure it, and measure Alice’s qubit Send the measurements to Bob through a classical communication channel Apply (or not) a \\(X\\) and/or \\(Z\\) gate based on the measurements  It may look like a lot to process at once, but if broken down, teleportation can make sense.\nPreparing the Bell state The first step of the algorithm is to prepare the entangled state \\(\\vert\\Phi^{+}\\rangle\\), one of the Bell states. The Bell states are the most entangled and commonly appear in many quantum algorithms. Out of the for Bell states, the one we are looking is:\n\\[ \\vert\\Phi^{+}\\rangle = \\frac{\\vert 00 \\rangle + \\vert 11 \\rangle}{\\sqrt 2} \\]\nTo do so, we start with the two-qubit state \\(\\vert 00 \\rangle\\), and use a Hadamard gate on the first qubit.\n\\[ \\vert 00 \\rangle \\rightarrow (\\frac{\\vert 0 \\rangle + \\vert 1 \\rangle}{\\sqrt 2}) \\otimes \\vert 0 \\rangle = \\frac{\\vert 00 \\rangle + \\vert 10 \\rangle}{\\sqrt 2} \\]\nNotice that the state we are right now is very close to our goal. We just need to have \\(|11\\rangle\\) instead of \\(|10\\rangle\\), so we use a CNOT with the first qubit as control and second as the target. Nothing happens to \\(|00\\rangle\\) because the control qubit is $|0$, but \\(|10\\rangle\\) becomes \\(|11\\rangle\\) because the control qubit is \\(|1\\rangle\\). Overall:\n\\[ \\vert 00 \\rangle \\rightarrow \\frac{\\vert 00 \\rangle + \\vert 10 \\rangle}{\\sqrt 2} \\rightarrow \\frac{\\vert 00 \\rangle + \\vert 11 \\rangle}{\\sqrt 2} \\]\nThe circuit that performs this step looks like:\nYou may ask: how do we perform the entanglement if the qubits are far apart? That is indeed a good question. The first answer to this question would be to entangle the qubits when they are together with Alice and then split them apart, sending one to Bob. In my opinion, this answer violates the essence of teleportation: we do not want to send qubits to Bob.\nThe second answer is: assume we can do it at long distances. We have not been discussing the plausibility to have a qubit or apply the gates, so we will leave for physicists to figure out how to physically achieve the entanglement.\nTeleportation procedure Now that we know how to generate \\(|\\Phi^{+}\\rangle\\), we have everything we need to do quantum teleportation. Considering our three-qubit system, we start with \\(|\\psi\\rangle \\otimes |\\Phi^{+}\\rangle\\).\nFirstly, we apply a CNOT gate with \\(|\\psi\\rangle\\) as the control, and Alice’s entangled qubit as the target. That yields:\n\\[ \\frac{\\alpha|000\\rangle + \\alpha|011\\rangle + \\beta|100\\rangle + \\beta|111\\rangle}{\\sqrt 2} \\rightarrow \\frac{\\alpha|000\\rangle + \\alpha|011\\rangle + \\beta|110\\rangle + \\beta|101\\rangle}{\\sqrt 2} \\]\nSecondly, we apply the Hadamard gate to the first qubit and we obtain:\n\\[ \\rightarrow \\frac{|00\\rangle (\\alpha|0 \\rangle+\\beta|1\\rangle) + |01\\rangle (\\alpha|1 \\rangle+\\beta|0\\rangle) + |10\\rangle (\\alpha|0 \\rangle-\\beta|1\\rangle) + |11\\rangle (\\alpha|1 \\rangle-\\beta|0\\rangle)}{2} \\]\nThirdly, we measure the first two qubits, i.e. those that are with Alice, and send the result to Bob. Notice that depending on the outcome, we know exactly the state of third qubit. For example, we know that if the outcome of the measurement is \\(10\\), then the last qubit is \\(\\alpha|0 \\rangle-\\beta|1\\rangle\\).\nLastly, we need to go from the qubit that we know now to \\(|\\psi\\rangle\\). Fortunately, that is simple. To achieve that, we need to apply the gates \\(X\\) and \\(Z\\) conditionally. The table below summarizes when we need to apply the gates:\n  Outcome Gate to apply    \\(00\\) \\(I\\) (no gates)  \\(01\\) \\(X\\)  \\(10\\) \\(Z\\)  \\(11\\) \\(X\\) and then \\(Z\\)    Even though the math might have looked complicated, the final circuit is simple. The last part of applying gates conditionally can be done by applying a Controlled X gate (which is another name for CNOT), and also applying a Controlled Z gate. Hence, the circuit that performs all 4 steps is:\nVerifying computationally that the procedure works We can verify that quantum teleportation works using Qiskit and running an experiment: in the Jupyter notebook bellow, we try to teleport \\(|\\psi\\rangle = \\frac{\\sqrt 3}{2}|0\\rangle + \\frac{1}{2}|1\\rangle\\) and analyse the results.\nEvery step explained above is done, and the results match our prediction.\n ","date":1577080800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577080800,"objectID":"b2a6122f0b7847d48662570b511f0662","permalink":"https://ivaniscoding.github.io/posts/quantum2/","publishdate":"2019-12-22T22:00:00-08:00","relpermalink":"/posts/quantum2/","section":"posts","summary":"Teleportation is not only in science fiction","tags":["quantum"],"title":"Quantum #2 - Teleportation","type":"posts"},{"authors":null,"categories":["Quantum"],"content":"This is the first post of a series of posts about Quantum Computing with Qiskit. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.\nThe goal of this post is to introduce a more hands-on approach to quantum computing using Qiskit. For a friendly introduction to quantum computing in general, I recommend the essay Quantum computing for the very curious by Matuschak and Nielsen.\nThe qubit Quantum computers are made of qubits like classical computers are made of bits. However, qubits vectors and thus they have components. There are two very important qubits \\(|0\\rangle\\) and \\(|1\\rangle\\) that relate to their classical 0 and 1 counterparts. In vector notation, they are:\n\\[ |0\\rangle = \\begin{bmatrix}1 \\\\ 0\\end{bmatrix} \\]\n\\[ |1\\rangle = \\begin{bmatrix}0 \\\\ 1\\end{bmatrix} \\]\nIn general, every qubit \\(|\\psi\\rangle\\) has a \\(|0\\rangle\\) component and a \\(|1\\rangle\\) component, that is:\n\\[ |\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle \\]\nWe can also write that superposition (or linear combination) in the matrix form.\n\\[ |\\psi\\rangle = \\begin{bmatrix}\\alpha \\\\ \\beta\\end{bmatrix} \\]\nIt is important to remember that \\(\\alpha\\) and \\(\\beta\\) may be complex numbers! Thus, the imaginary number \\(i\\) may appear in the components. For example, following qubit is valid:\n\\[ |\\psi\\rangle = \\begin{bmatrix}\\frac{1 + i}{\\sqrt 2} \\\\ 0\\end{bmatrix} \\]\nLastly, one key factor for qubits is that they are unitary vectors that is:\n\\[ || |\\psi\\rangle || = 1 \\]\nThus, we may visualize a qubit as a 3d vector in a sphere of radius 1:\nQuantum gates \u0026amp; Quantum Circuits A quantum circuit is a collection of qubits and classical bits. The building blocks of quantum circuits are quantum gates: they modify qubits and allow quantum computing to achieve arbitrary qubit states as we discussed before.\nIn Qiskit, a quantum circuit can be initialized by:\nfrom qiskit import * circuit = QuantumCircuit(n_qubits, n_classical_bits) In general, a gate \\(U\\) can be added to a circuit by:\ncircuit.u(target_qubit) A fact to notice is that there is an infinite number of qubit gates! A gate is any device that takes a qubit \\(|\\psi\\rangle\\) and outputs another valid qubit \\(|\\phi\\rangle\\). In general, we have that a gate \\(U\\) can be represented by a matrix:\n\\[ U = \\begin{bmatrix} a \u0026amp; b \\\\ c \u0026amp; d\\end{bmatrix} \\]\nBy applying the gate \\(U\\) to a qubit \\(|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\), we obtain:\n\\[ |\\phi\\rangle = U|\\psi\\rangle = (a\\cdot\\alpha + b\\cdot\\beta)|0\\rangle + (c\\cdot\\alpha + d\\cdot\\beta)|1\\rangle \\]\nNotice that \\(U\\) must preserve the length of \\(|\\psi\\rangle\\) in order for \\(|\\phi\\rangle\\) to be a valid qubit! Thus \\(U\\) is a special type of matrix called a unitary matrix. Mathematically:\n\\[ UU^{\\dagger} = I \\]\nWhere \\(U^{\\dagger}\\) is the conjugate transpose. It is important to see that \\(U^{\\dagger}\\) can undo the transformation from \\(U\\): it takes \\(|\\phi\\rangle\\) to \\(|\\psi\\rangle\\).\nBecause of the matrix multiplication property of the gates, applying multiple quantum gates such as \\(U_{a}\\) and then \\(U_{b}\\) is equivalent to applying a gate \\(G\\) such that:\n\\[ G = U_{a}U_{b} \\]\nIt is important to notice that gate composition also implies gate decomposition. The quantum gate you are applying might be a synthesis of other easier to implement gates in real life such that \\(G = U_{a}U_{b}U_{c}\\).\nEven though there is an infinite amount of gates, some are very famous because they are more used than others and have a special place in quantum computing and Qiskit. They are:\nThe Pauli-X gate The Pauli-X gate is the quantum equivalent of the NOT gate, that is it takes 0 to 1 and 1 to 0. Mathematically:\n\\[ |0\\rangle \\overset{X}{\\rightarrow} |1\\rangle \\]\n\\[ |1\\rangle \\overset{X}{\\rightarrow} |0\\rangle \\]\n\\[ \\alpha|0\\rangle + \\beta|1\\rangle \\overset{X}{\\rightarrow} \\beta|0\\rangle + \\alpha|1\\rangle \\]\nTo use the Pauli-X gate in Qiskit, it suffices to write:\ncircuit.x(target_qubit) Graphically, the gate is represented as:\nBecause \\(X\\) is a gate, it can be written as a matrix as we discussed before:\n\\[ X = \\begin{bmatrix} 0 \u0026amp; 1 \\\\ 1 \u0026amp; 0\\end{bmatrix} \\]\nAn important property of \\(X\\) is that \\(X = X^{\\dagger}\\), thus \\(X\\) is the inverse gate of itself! That means that if we apply twice the Pauli-X Gate to a qubit, we will still have the same qubit.\nThe Pauli-Z gate The Pauli-Z gate is a quantum gate that leaves the \\(|0\\rangle\\) component intact but flips the sign of the \\(|1\\rangle\\) component. Mathematically:\n\\[ |0\\rangle \\overset{Z}{\\rightarrow} |0\\rangle \\]\n\\[ |1\\rangle \\overset{Z}{\\rightarrow} -|1\\rangle \\]\n\\[ \\alpha|0\\rangle + \\beta|1\\rangle \\overset{Z}{\\rightarrow} \\alpha|0\\rangle - \\beta|1\\rangle \\]\nTo use the Pauli-Z gate in Qiskit, it suffices to write:\ncircuit.z(target_qubit) Graphically, the gate is represented as:\nThe matrix representation of \\(Z\\) is:\n\\[ Z = \\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; -1\\end{bmatrix} \\]\nAn important property of \\(Z\\) is that \\(Z = Z^{\\dagger}\\), thus \\(Z\\) is the inverse gate of itself! That means that if we apply twice the Pauli-Z Gate to a qubit, we will still have the same qubit.\nThe Pauli-Y gate The Pauli-Y gate is a gate that has only pure imaginary entries. It is similar to the \\(X\\) gate but has its entries multiplied by \\(i\\) and the top term is \\(-i\\). Mathematically, it acts as follows:\n\\[ |0\\rangle \\overset{Y}{\\rightarrow} i|1\\rangle \\]\n\\[ |1\\rangle \\overset{Y}{\\rightarrow} -i|0\\rangle \\]\n\\[ \\alpha|0\\rangle + \\beta|1\\rangle \\overset{Y}{\\rightarrow} -i\\beta|0\\rangle + i\\alpha|1\\rangle \\]\nTo use the Pauli-Y gate in Qiskit, it suffices to write:\ncircuit.y(target_qubit) Graphically, the gate is represented as:\nThe matrix representation of \\(Y\\) is:\n\\[ Y = \\begin{bmatrix} 0 \u0026amp; -i \\\\ i \u0026amp; 0\\end{bmatrix} \\]\nAn important property of \\(Y\\) is that \\(Y = Y^{\\dagger}\\), thus \\(Y\\) is the inverse gate of itself! That means that if we apply twice the Pauli-Y Gate to a qubit, we will still have the same qubit.\nThe Hadamard gate The Hadamard gate is a gate to generate superposition, and it is hard to find a classical equivalent of it: it is a quantum gate by nature. Given \\(|0\\rangle\\), it generates a mix of \\(|0\\rangle\\) and \\(|1\\rangle\\), and does the same for \\(|1\\rangle\\). Mathematically:\n\\[ |0\\rangle \\overset{H}{\\rightarrow} \\frac{|0\\rangle + |1\\rangle}{\\sqrt 2} \\]\n\\[ |1\\rangle \\overset{H}{\\rightarrow} \\frac{|0\\rangle - |1\\rangle}{\\sqrt 2} \\]\n\\[ \\alpha|0\\rangle + \\beta|1\\rangle \\overset{H}{\\rightarrow} \\frac{(\\alpha + \\beta)}{\\sqrt 2}|0\\rangle + \\frac{(\\alpha - \\beta)}{\\sqrt 2}|1\\rangle \\]\nNotice that \\(\\frac{|0\\rangle + |1\\rangle}{\\sqrt 2}\\) and \\(\\frac{|0\\rangle - |1\\rangle}{\\sqrt 2}\\) are so important because they can be seen as an alternative basis, that they deserve their own symbols:\n\\[ |+\\rangle= \\frac{|0\\rangle + |1\\rangle}{\\sqrt 2} \\]\n\\[ |-\\rangle= \\frac{|0\\rangle - |1\\rangle}{\\sqrt 2} \\]\nTo use the Hadamard gate in Qiskit, it suffices to write:\ncircuit.h(target_qubit) Graphically, the gate is represented as:\nThe matrix reprenstation of the Hadamard gate is:\n\\[ H = \\frac{1}{\\sqrt 2}\\begin{bmatrix} 1 \u0026amp; 1 \\\\ 1 \u0026amp; -1\\end{bmatrix} \\]\nAn important property of \\(H\\) is that \\(H = H^{\\dagger}\\), thus \\(H\\) is the inverse gate of itself! That means that if we apply twice the Hadamard gate to a qubit, we will still have the same qubit.\nExecuting a circuit in Qiskit In Qiskit, we need a backend to execute a quantum circuit. That backend might be either a real quantum computer or a simulator. The syntax to run a circuit is:\njob = execute(circuit, backend, shots=n_times_to_execute) There are three key simulators in Qiskit that you must be aware of:\n qasm_simulator: simulates the circuit and performs measurements unitary_simulator: simulates the circuit and outputs the unitary matrix that represents it statevector_simulator: simulates the circuit and outputs the state of the qubit  The syntax to obtain the specific backend with the simulator we want is:\nsimulator = Aer.get_backend(backend_name) Notice that after running the circuit either in a simulator in a real device, we would want the results! The code snippet below describes how to obtain it:\nresult = job.result() result.get_unitary() # if the backend is unitary_simulator result.get_statevecor() # if the backend is statevector_simulator Jupyter notebooks exemplifying the process are given below:\n  Measurements Even though qubits are a superposition of \\(|0\\rangle\\) and \\(|1\\rangle\\), when a measurement is made, the output will be either 0 or 1. For a given qubit \\(|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\), there is a \\(|\\alpha^{2}|\\) probability that the measurement will be 0 and a \\(|\\beta^{2}|\\) probability that the measurement will be 1.\nBecause the sum of the probabilities of all events is equal to one, we may write:\n\\[ |\\alpha^{2}| + |\\beta^{2}| = 1 \\]\nIn Qiskit, a measurement can be made using the following syntax:\ncircuit.measure(target_qubit, target_classical_bit) After executing the job in a real quantum computer or in a simulator, the obtained measurements will be available in a dictionary where the key is the measurement and the value is the count of the measurements:\nresult = job.result() measurement_counts = result.get_counts() In general, it is also useful to visualize the measurements using a histogram. That can be done through:\nfrom qiskit.visualization import plot_histogram plot_histogram(measurement_counts) A Jupyter notebook exemplifying the measurement process is given below:\n Multiple qubits So far we have discussed only systems with exactly one qubit! However, quantum circuits are generally composed of multiple qubits. For example, for a two-qubit system, there are four states: \\(|00\\rangle\\), \\(|01\\rangle\\), \\(|10\\rangle\\) and \\(|11\\rangle\\). A 2-qubit system can be described then as:\n\\[ |\\psi\\rangle = \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle \\]\nA system of n qubits will have \\(2^{n}\\) states, hence using the ket notation is more convenient than writing matrices with \\(2^{n}\\) entries.\nFor multiple qubit system, it is also common to use the tensor product (\\(\\otimes\\)) to describe the state. If \\(|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\) is a single qubit and \\(|\\phi\\rangle\\) is a qubit, then we define:\n\\[ |\\psi\\rangle \\otimes |\\phi\\rangle = \\begin{bmatrix}\\alpha|\\phi\\rangle \\\\ \\beta|\\phi\\rangle\\end{bmatrix} \\]\nSometimes also written \\(|\\psi\\rangle|\\phi\\rangle\\). Notice that \\(|00\\rangle = |0\\rangle \\otimes |0\\rangle\\). The same apply for more qubits: \\(|011\\rangle = |0\\rangle \\otimes |1\\rangle \\otimes |1\\rangle\\).\nTo make it clearer, an example is useful. If \\(|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle\\) and \\(|\\phi\\rangle = \\gamma|0\\rangle + \\delta|1\\rangle\\), then:\n\\[ |\\psi\\rangle \\otimes |\\phi\\rangle = \\alpha\\gamma|00\\rangle + \\alpha\\delta|01\\rangle + \\beta\\gamma|10\\rangle + \\beta\\delta|11\\rangle \\]\nOne last remark is: not every state can be written as a tensor product of qubits! Those states are called entangled. An example of an entangled state is:\n\\[ |\\Phi^{+}\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt 2} \\]\nMultiple-qubit gates In the first gate section, we discussed gates that operated on a single qubit. In this section, we will discuss gates that operate on two or more qubits. They are still unitary gates:\n\\[ UU^{\\dagger} = I \\]\nTheir dimensions, however, are different. A gate that operates on n qubits has dimensions of \\(2^{n} \\times 2^{n}\\). It is also relevant to know how to write single-qubit gates for multiple qubit systems: they are written using the tensor product such as \\(H \\otimes Z\\): in this example, we apply the Hadamard gate to the first qubit and the Pauli-Z gate to the second qubit.\nAgain, there is an infinite number of multiple qubit gates. Some that deserve special attention and have a special place in Qiskit are:\nControlled NOT gate The Controlled NOT gate applies the NOT gate (Pauli-X gate) to a target qubit based on a control qubit. If the control qubit is 1, then \\(X\\) is applied to the target. Otherwise, the target is not affected. Mathematically, considering the first qubit as control and the second one as a target:\n\\[ |00\\rangle \\overset{CX}\\rightarrow |00\\rangle \\]\n\\[ |01\\rangle \\overset{CX}\\rightarrow |01\\rangle \\]\n\\[ |10\\rangle \\overset{CX}\\rightarrow |11\\rangle \\]\n\\[ |11\\rangle \\overset{CX}\\rightarrow |10\\rangle \\]\n\\[ \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle \\overset{CX}\\rightarrow \\alpha|00\\rangle + \\beta|01\\rangle + \\delta|10\\rangle + \\gamma|11\\rangle \\]\nTo use the CNOT gate in Qiskit, it suffices to write:\ncircuit.cx(control, target) Graphically, it looks like:\nBecause of the properties of the \\(X\\) gate, the CNOT gate is the inverse of itself. Hence, if we apply twice CNOT to the same two qubits, the target qubit will not change.\nIn addition, it is worth mentioning that any gate can be made conditional using CNOT. Thus, there also exists the Controlled Z and Controlled Y gates. In Qiskit, they are available through:\ncircuit.cz(control, target) circuit.cy(control, target) Toffoli gate The Toffoli gate is the quantum equivalent of the logical AND gate. Even though it computes \\(a \\wedge b\\), it needs an extra qubit: \\(|a\\rangle|b\\rangle \\rightarrow |a\\rangle|a \\wedge b\\rangle\\) is not described by an unitary matrix. Thus, the Toffoli gates uses an extra qubit such that \\(|a\\rangle|b\\rangle|0\\rangle \\rightarrow |a\\rangle|b\\rangle|a \\wedge b\\rangle\\).\nBecause we need to handle the case when the working qubit is \\(|1\\rangle\\), the Toffoli gate is described by:\n\\[ |a\\rangle|b\\rangle|c\\rangle \\overset{CCX}\\rightarrow |a\\rangle|b\\rangle|c \\oplus (a \\wedge b)\\rangle \\]\nTo use the Toffoli gate in Qiskit, it suffices to write:\ncircuit.ccx(control_a, control_b, target_qubit) Graphically, it looks like:\nBecause of the properties of \\(\\oplus\\), the Toffoli is the inverse of itself. Thus, if we apply twice the Toffoli gate to the same 3 qubits, the working qubit will not change.\nTo consolidate those ideas, here is a Jupyter notebook that uses multiple-qubit gates:\n Uncomputation As we discussed in the previous session, we have seen that for calculating the AND of qubits \\(|a\\rangle\\) and \\(|b\\rangle\\), we need a working qubit to store \\(|a \\wedge b\\rangle\\).\nIt turns out that sometimes, to compute a generic function \\(f(a, b)\\), we may need even more working qubits to store intermediate results.\nFor example, imagine that you want to compute \\(a \\wedge b \\wedge c\\), the AND of three variables. You would need a qubit to compute \\(a \\wedge b\\) and then another qubit to compute \\((a \\wedge b) \\wedge c\\).\nNotice that we have very little interest in saving \\(a \\wedge b\\). In general, it is a good idea to clean the results (i.e. to reverse the qubit to \\(|0\\rangle\\)), because:\n We want to reuse resources It makes measurements more accurate (more qubits = more complex systems = harder measurements)  That process of cleaning is called uncomputation.\nBecause \\((a \\wedge b) \\oplus (a \\wedge b) = 0\\), that is the inverse of the Toffoli gate is the Toffoli gate itself, then we may build the following circuit to calculate the AND of three qubits using uncomputation:\nIn the circuit above, we use an intermediary qubit \\(|a \\wedge b \\rangle\\) to help us achieve \\(|a \\wedge b \\wedge c\\rangle\\), and then immediately clean it afterward. That way, the intermediary qubit goes back to \\(|0\\rangle\\) and can be reused later if necessary.\nThe Qiskit code that implements the calculation of the AND of three qubits is provided bellow, building exactly the circuit we described:\n ","date":1576123200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577774280,"objectID":"21277d420375216d103f5d4e0bf0763c","permalink":"https://ivaniscoding.github.io/posts/quantum1/","publishdate":"2019-12-11T20:00:00-08:00","relpermalink":"/posts/quantum1/","section":"posts","summary":"Hands-on quantum computing with Qiskit","tags":["quantum"],"title":"Quantum #1 - Basic Quantum Computing","type":"posts"},{"authors":null,"categories":["Divide and Conquer"],"content":"This is a post about one very interesting Divide-and-conquer technique. I call this the \u0026ldquo;All but one\u0026rdquo; trick because that's an accurate description of what it can be used for. I learned about this in the Brazilian ICPC Summer School in 2018, thanks to Tomasz Idziaszek and thought it would be a good addition to this blog. In this post, I will briefly explain the technique and show its application in one problem.\nThis is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as Merge Sort and Binary Search.\nThe problem it solves This trick is useful to solve the following kind of problem: Imagine there is a structure S with N elements. To build S, you add elements one at a time. You would like to know what S would look like if, for each element, we considered S without it. However, it is computationally expensive to remove an arbitrary single element.\nA naive approach to this problem that is very straightforward is to rebuild S multiple times without each element. Even though this approach works, a lot of computations are wasted because many times we have almost the same state for S. After analyzing this, a question arises: is there a more efficient way to do it?\nIf removing the last addition to S is fast, then the answer is yes. It uses a clever observation that follows nicely into a Divide-and-Conquer Algorithm.\nThe algorithm The idea for the algorithm can be described as follows: if we have a set of N elements, we split into two sets of roughly equal size. Then, for one of the halves, we will add all of its elements to S. Notice that by doing this, we arrive at the same conceptual problem for the other half: find S without a single element for each element.\nHence, we can continue the procedure until we arrive with a set of a single element. When that happens, we can answer the query about S without that element. The only missing point with that idea is that we need to answer the query for every element and not only for a single one. To solve this, we just need to change a few things when we recurse up.\nThe changes are:\n  Remove all additions that were made in the step when we recurse up.\n  Add the elements of the half that were not added at first, and recurse to the half that was added at first.\n  Lastly, we need to undo those add operations when we recurse back to maintain the fact that calling the Divide and Conquer function does not alter the state of S.\n  Now the algorithm works because we can guarantee that we will arrive at a situation with a single element for every element and that when that happens all the other elements will have been added to S.\nIf the operation of adding has a complexity of O(K) and the operation of undoing has a complexity of O(L), then the algorithm has an overall complexity of O(N*(K+L)*log(N)). A pseudo-implementation of the algorithm is given below.\nvoid DivideAndConquer(int s, int e){ // Base case: single element if(s == e){ // Answer your query ! return ; } int m = (s+e)/2; // we will split the set into two /* First part: add elements of the right, recurse to the left and undo */ for(int i = m+1; i\u0026lt;=e; i++){ // Adding elements of the right half add(i); } DivideAndConquer(s, m); // recursing to the left half for(int i = e; i\u0026gt;=m+1; i--){ // undo all the operations of addition undo(); } /* Second part: add elements of the left, recurse to the right and undo */ for(int i = s; i\u0026lt;=m; i++){ // Adding elements of the left half add(i); } DivideAndConquer(m+1, e); // recursing to the right half for(int i = m; i \u0026gt;= s; i--){ // undo all the operations of addition undo(); } }  Example Problem The problem we will analyze is Voltage from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2014). You may find the problem statement and a place to submit here and the original problem statement in Japanese here.\nA synthesis of the problem statement is : There is a circuit with N nodes and M resistors. Each node can be set either to low or high voltage, and current cannot flow through resistors connected to nodes of the same voltage. Calculate how many resistors can be removed such that if we remove only that resistors, there is current flowing in all other resistors.\nReduction to the trick and solution The problem can be reduced to the following one: check if without an edge E, the graph is bipartite.\nThe structure to verify if a graph is bipartite while adding edges is a modified Disjoint Set Union-Find. I will not be going into many details, but you may find more explanation about it in this CodeChef discussion.\nRemoving an arbitrary edge from the DSU is fairly difficult, but removing the last one is not due to the stack-like structure of the DSU. Hence, the problem we have fits in the range of the applications of the trick and can be solved in O(N*log(N)^2). The implementation using the technique follows:\n ","date":1551636000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1551636000,"objectID":"d86cdeff58e57464cd77b9990d12fc70","permalink":"https://ivaniscoding.github.io/posts/dctrick1/","publishdate":"2019-03-03T10:00:00-08:00","relpermalink":"/posts/dctrick1/","section":"posts","summary":"An introduction to an useuful Divide-and-conquer technique: All But One Trick","tags":["algorithms"],"title":"Divide-and-conquer Techniques #1 - All But One Trick","type":"posts"},{"authors":null,"categories":["Information Theory"],"content":"I am writing a series of posts about Information Theory problems. You may find the previous one here.\nThe problem we will analyze is Amusement Park from the Japanese Olympiad in Informatics Open Contest (JOI Open 2017). You may find the problem statement and a place to submit here.\nA synthesis of the problem statement is : You are given a connected graph of N vertices and M edges (60 \u0026lt;= N \u0026lt;= 10000, M \u0026lt;= 20000) . JOI-kun must tell the integer X ( 0 \u0026lt;= X \u0026lt;= 2^60 - 1) to IOI-chan, but he cannot do that directly. Instead, he will write either 0 or 1 in each vertex. IOI-chan can read the integer written on the vertex currently at and move to any adjacent vertex. Help IOI-chan discover X by using the smallest possible number of movements. You must submit two files:\n One that given the structure of the graph and the integer X, writes 0 or 1 on each vertex. Note that JOI-kun does not know the starting vertex of IOI-chan. One that given a starting vertex and the graph structure, uses the least number of moves such that with the integers written on the visited vertices it can recover the integer X.  The scoring of the subtasks is based on the maximum number of moves IOI-chan does. In order to score 100 points, you must find a solution that uses at most 120 moves.\nI will not discuss the first subtasks because I found a solution that in my opinion is conceptually simple (it is basically a DFS) and already scores 78 points going up to subtask 4. Thus, we will discuss the DFS idea and the final solution.\nA DFS approach : 78 points There are some initial steps that are common to almost all approaches to this problem. They are necessary in order to solve the problem because they take care of the basic : how to send X with 0's and 1's\nThe idea is : we will have to use the binary encoding of X to send it with 0's and 1's. The strategy will be as follows : we will assign for each vertex which of the 60 bits it represents; we must find a procedure that produces the same result for IOI-chan and JOI-kun, because we need to be sure that we are correctly receiving the message.\nThe next step of this idea is : we need to find an efficient way of moving between the vertices such that we can recover the 60 bits quickly. When we get all the bits, we stop moving and report X. In order to achieve this, we have to also think about the way we assign the bit for each vertex, because this assignment heavily impacts in the number of movements.\nThe final step is : it is easier to solve this problem on a tree. Because of the tree properties, it is simple to find a correct way to assign the bits to the vertices and it is less complicated to decide where to move compared to a general graph. Due to the fact that our graph is connected, we can always find a spanning tree of the graph and transform the general graph into a tree.\nAn algorithm that finds a spanning tree and also finds an efficient way of choosing the bits is the Depth-First Search. Let's take a look :\nWe start the algorithm by doing the DFS from any vertex of the graph. There are two key ideas that make the algorithm efficient:\n If a vertex was the (i)-th vertex to be discovered by the DFS, we define its discovery time as (i - 1). The bit that we will assign for this vertex will be (i - 1) modulo 60. We keep the edges used to discover of a new vertex as the edges of our spanning tree. Thus, we build the tree as we assign the bits  By doing that, the only remaining step is to find an efficient way to move in order to quickly discover all the 60 bits.\nHowever, the way we move will also be heavily inspired by the DFS. Suppose that we are currently at a vertex v and let T be the subtree of v considering that the tree is rooted at the starting vertex of the DFS. There are two cases:\n The size of T is bigger than or equal to 60. We just follow the DFS order and stop when all the 60 bits are found. The size of T is smaller than 60. We follow the DFS order and then return to the parent vertex of v, p. In p we do something similar but in a different order : instead of following the DFS from the first discovered child, we follow the DFS order from v and consider the array of children to be circular. Let's exemplify : if [1,2,3,4] was the ordering and you came from 3, them the order will be [3,4,2,1].  This algorithm uses at most 160 movements and scores 78 points. It was harder to think and explain the algorithm then to implement it. You may find the partial solution here.\nA smart subtree approach : 100 points In the final solution, we will also stick to the idea of solving the problem on a tree and reducing a general graph to its spanning tree. However, we will tweak the moving part of our algorithm to be more efficient.\nFrom now on, when we talk about subtrees , think of them as a connected acyclic subgraph rather than a subtree of a rooted tree. Suppose that we have a subtree of exactly 60 vertices . If we run the DFS algorithm on this subtree, we will be able to find X with 120 moves or less for all the vertices of the subtree.\nIf we could assign for each vertex a subtree of size 60 such that all the bits of X are represented in the subtree, then our problem is solved. Let's focus on finding a way of doing that.\nSuppose we have already found the spanning tree and found an arbitrary subtree T of size 60. For all vertices of the subtree, we assign T as its subtree. Then, we will try to assign a subtree to the neighbors of the vertices of the subtree that have not yet been assigned a subtree.\nThe idea is as follows. Let u be the vertex without an assigned subtree and v its neighbor that has been assigned the subtree T. To find subtree for u, we copy T and remove an arbitrary leaf of the tree that is not v. Then, we connect u to v in the new subtree T* and assign the bit of the removed leaf to u. The image above shows this idea for a smaller subtree : we pick any of the leaves (in this it was the one numbered 6, but it could be 5) and remove it. Then, we connect the new vertex to its neighbor in the subtree an assign the 6th bit to the new vertex.\nWe must run the routine above until all vertices are assigned a subtree. Because the graph is connected, it will always be possible to assign a subtree to each vertex.\nIn the decoding part as IOI-chan , we run the DFS idea from our previous algorithm in the subtree of the starting vertex. IOI-chan will make at most 120 moves.\nIn my final implementation, I opted to use a BFS to generate a spanning tree instead of the DFS. Despite that, the algorithm is exactly the same as the one described above.\n ","date":1535475600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535475600,"objectID":"f749f21503a91feaad6f5ac76a089388","permalink":"https://ivaniscoding.github.io/posts/informationtheory6/","publishdate":"2018-08-28T14:00:00-03:00","relpermalink":"/posts/informationtheory6/","section":"posts","summary":"Analysis of Amusement Park from the Japanese Open Contest 2017","tags":["algorithms"],"title":"Information Theory #6 - Amusement Park","type":"posts"},{"authors":null,"categories":["Information Theory"],"content":"I am writing a series of posts about Information Theory problems. You may find the previous one here.\nThe problem we will analyze is City from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2017). You may find the problem statement and a place to submit here .\nA synthesis of the problem statement is : you are given a rooted tree of N vertices (N \u0026lt;= 250000) that has a depth that is at most 18. You must write an integer on each node so that given only the integers written on X and Y, without knowing the structure of the tree, you can answer the question : is X on the path from Y to the root, Y on the path from X to the root or neither of them?\nThe scoring of the problem is based on the maximum integer you write on each node. There is also a subtask for N \u0026lt;= 10.\nSubtask 1 : N \u0026lt;= 10 (8 points) In this subtask, the graph is small and the maximum integer does not matter as long it is smaller than 2^60 - 1.\nBecause of this, we may choose a suboptimal strategy to solve the problem. The simplest one is to encode the vertex and the whole adjacency matrix on the integer we send.\nWe use the binary encoding to send the current node (this uses 4 bits) and use another 45 bits to send the matrix. Then, we run a DFS to see which case happens\nL \u0026lt;= 2^36 - 1 : 22 points With very big N, it is impossible to send the adjacency matrix. So we will focus on another technique to solve the problem.\nThis technique is commonly called \u0026ldquo;Euler Tour on a Tree\u0026rdquo; , even tough it is not exactly an Euler Tour. You can interpret it as noticing a special property of the initial and final time when you do a DFS on the tree.\nThe image above represents the \u0026ldquo;Euler Tour\u0026rdquo;. Every time you enter a vertex v, you increase the DFS counter and says this is number is the start time of v . At the end of the DFS on v, we also save the DFS counter and says it is the end time of v. The vector in the image represents this DFS ordering.\nThe cool thing about this is that it allows us to check if a vertex u is on the subtree of a vertex v easily. Because the vertices of the subtree form a contiguous subarray in the DFS order array, we can simply check if the start of u is contained in the interval [s,e] where s is the start time of v and e the end time of v.\nIf you think a little bit about it, checking if a vertex v is on a subtree of another is exactly the same as checking if that another vertex is on the path from v to the root. So we found a solution to the problem we want to solve!\nFor each vertex, we send an integer that represents the start and end time of the DFS. To do that, we send 18 bits for the start and another 18 bits for the end. In the decoding part, we simply recover the starts and ends and run the interval check described above.\nThe maximum number if 2^36 - 1 , thus we score 22 points.\nAn unused property So far we did not the property that the depth of the tree is at most 18. The solution described above works for any tree, and therefore does not exploit the special property of the depth.\nBecause the maximum depth is 18, every node has at most 18 ancestors and is therefore contained in at most 18 intervals. Thus, the sum of the lengths of all intervals is at most 18*N. So on average each interval is at most 18. That is not much.\nIt seems to be a waste to send 18 bits of the end when we could send the size, which is on average 5 bits. So we will do exactly that : instead of sending the end, we send the size of the interval.\nThis optimization alone does not affect our punctuation, because there are causes in which we will still send integers up to 2**36 - 1. However, this idea is a crucial step to solve the problem.\nAn efficient way of sending the size : 100 points solution We need to optimize the way we send the size. In a perfect environment, we could create a smaller dictionary that represented the sizes and send the position in that dictionary.\nHowever, it is difficult to adjust a dictionary to the sizes of the interval. We will try a different approach : adjust the interval size to the dictionary. But how do we do that ?\nSuppose that the interval size is a. How do we fit that size to the dictionary , if it is not in it? Let b be the smallest integer of the dictionary greater than our equal to a. We can always add some extra leaves as dummy vertices in order to reach the size b. The image above exemplifies that, by adding two leaves to reach the size 5 from the original size 3.\nIn practice, we are adding empty spaces to our DFS array. The challenge now is to build that dictionary of sizes.\nBuilding the dictionary : 100 points solution The challenge of finding a dictionary of sizes is that it should not add many extra vertices, because in that case the start of the vertices would be big and thus the dictionary would need to be small.\nIf the total number of vertices (original and dummy) of the final solution is close to 2^K, then we must construct a dictionary of size 2^(28 - K) .\nAdditionally , this dictionary should vary gradually. A function that varies gradually is a power function, so we can describe our dictionary as a set of {r^0, r^1, r^2\u0026hellip;} for some number r. The optimal r is the solution for r^(2^(28 - K)) = 2^K\nIf you experiment with K, you may find that K = 20 is a good choice. Therefore, the maximum number of vertices if 2^20 and the dictionary size is 2^8 = 256.\nThe value of r is 2^(20/256) ≈ 1.055645 (we must truncate because we cannot represent an irrational number in an exact decimal form).\nBecause r is not an integer, our dictionary is not exactly described by a power function, but by an approximation. Let A be our dictionary and a0 = 0 the first element. We say that ai = max{ a(i-1) + 1, ai*r } , where ai*r is rounded down.\nIn the final code, I opted to send the difference between the start and the end instead of the size. The result is identical, tough.\n ","date":1535418000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535418000,"objectID":"8d63aeeeec749f2faa2b96bcf7384afc","permalink":"https://ivaniscoding.github.io/posts/informationtheory5/","publishdate":"2018-08-27T22:00:00-03:00","relpermalink":"/posts/informationtheory5/","section":"posts","summary":"Analysis of City from the Japanese Olympiad in Informatics Spring Camp 2017","tags":["algorithms"],"title":"Information Theory #5 - City","type":"posts"},{"authors":null,"categories":["Information Theory"],"content":"I am writing a series of posts about Information Theory problems. You may find the previous one here.\nThe problem we will analyze is Airline Route Map from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement and a place to submit here .\nA synthesis of the problem statement is : Alice needs to send to Bob an undirected graph of N vertices (N \u0026lt;= 1000) and M edges (M \u0026lt;= N*(N-1)/2). However, the information Alice sends suffers a series of shuffles before Bob receives it\n The number of the vertices are changed. So each of the N vertices will receive a new unique number from 0 to N-1. The edge list is shuffled. The edges remain consistent to the information you sent (if you sent A-\u0026gt;B, then it will mean A* -\u0026gt; B*, where A* and B* are the new numbers for A and B) , but their order on the edge list is not the same. The direction of the edge is changed. If it was A-\u0026gt;B , then you may receive A*-\u0026gt;B* or B*-\u0026gt;A*  You may add or remove vertices and edges when you are sending the graph as Alice. When Bob receives the shuffled information, he needs to recove the original graph Alice wanted to send. You must submit two files:\n One that given the undirected graph we want to send, generates a new graph and sends it. One that given the shuffled sent graph, recovers the original one The scoring is based on the number of extra vertices you sent. The final subtasks uses only 12 extra vertices to recover the graph.  This time I will not focus on the subtasks but only at two solutions : one that uses 13 vertices and the improvement of this solution that uses 12 vertices.\nA question : add or remove edges ? We are allowed to send any graph, so we must choose if we will add or remove edges (or do both). It turns out that it is very hard to recover information of edges that were not sent using few additional vertices. So it is better to send the original graph with some additional vertices that will help to recover the original numbering of the vertices.\nFirst step : how to recover the numbers ? The first challenge is to recover the original numbers with such few extra vertices. This requires an efficient way of sending information.\nIt turns that sending the binary representation of the numbers is a good idea. To do that, we create 10 extra vertices, one for each possible set bit of a number. Then, we connect the i-th extra vertex to the numbers whose i-th bit is set.\nThe image above does not show all the bits, but represent the connections of vertex 6 : it has an edge to the vertices that represent 2^1 and 2^2, but not to the one that is 2^0.\nSecond step : identifying the bit vertices The next challenge is to identify those special vertices. My idea to solve this was to create an additional vertex that is connected to all vertices of the graph, except to the bit ones.\nIn addition to that, I also connected the bit vertices to form a chain , connecting the i-th one to the (i+1)-th one.\nSo now we only need to identify the 10th bit vertex and the special vertex that is connected to all the nodes. If we do that, we can always discover the next bit of the chain and we have solve our problem.\nThird step : identifying the last bit vertex and the special vertex We have already used 11 extra vertices, so we do not want to use a lot more in order to identify these two vertices. So we must find some special property or implicit information that can helps us decode without sending many vertices.\nOne important piece of information that we have not used so far is the degree of the vertices. If we analyze the degrees, we discover an important property : for N \u0026gt;= 3, all of the vertices but two will always have their degree bigger than or equal to 2. The only two vertices that sometimes can break the rule are the vertex 0, when it does not have any edge in the original graph, and the 10th bit vertex when N \u0026lt;= 512.\nTherefore, it is a good idea to use two extra vertices with degree one to try identify the special and bit vertex, because they will be unique in our graph. With the extra one degree vertex, the 10th bit vertex no longer can have a degree one. The only remaining vertex that can mess up with our idea is 0.\nHowever, it is easy to overcome the problem with 0 : we can simply make the graph 1-indexed instead of 0-indexed. That way, 0 will become one and have a set bit, thus having a degree of at least two.\nIn the end , we do as follows : we make the graph 1-indexed and add the two 1-degree vertices. Then , we identify the two vertices that are connected to the 1-degree vertices and distinguish the special vertex based on the degree (the special one will always have more edges). Then , we process our chain of bits, discover the original numbering for each vertex and report the original graph. This algorithm uses 13 additional vertices and scores 91 points, which is a very good result.\nFourth step : final optimization In order to fully solve the problem, we must get rid of exactly one extra vertex. Therefore, we will need to use again implicit information that we did not use before.\nIt turns out that we do not need the 1-degree vertex to identify the last bit vertex. Of all the bit vertices (that can be easily identified because of the special vertex), it will always be the one that has the smallest degree.\nBecause of that, we drop the 1-degree vertex that connects to the last bit and tweak the algorithm we used before. Notice that by doing this, the 10th bit vertex can sometimes have only one edge, but with some thinking we can handle this case.\nIn my implementation of this idea, I hard coded small cases to avoid corner cases. The remaining part of the code implements exactly the same idea as described above.\n ","date":1535324400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535324400,"objectID":"ef57506513f96141b7ab90030bcdb2b8","permalink":"https://ivaniscoding.github.io/posts/informationtheory4/","publishdate":"2018-08-26T20:00:00-03:00","relpermalink":"/posts/informationtheory4/","section":"posts","summary":"Analysis of Airline Route Map from the Japanese Olympiad in Informatics Spring Camp 2018","tags":["algorithms"],"title":"Information Theory #4 - Airline Route Map","type":"posts"},{"authors":null,"categories":["Information Theory"],"content":"I am writing a series of posts about Information Theory problems. You may find the previous one here.\nThe problem we will analyze is Broken Device from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2017). You may find the problem statement and a place to submit here.\nA synthesis of the problem statement is : Anna wants to send a 60-bit integer to Bruno. She has a device that can send a sequence of 150 numbers that are either 0 or 1. The twist is that L (0 \u0026lt;= L \u0026lt;= 40) of the positions of the device are broken and can only send 0. Bruno receives the sequence Anna sent, but the does not know the broken positions. You must submit two files:\n One that given the integer X we want to send and the K broken positions, generates a sequence of length 150 that can be decoded. One that given the sequence generated by the previous procedure, decodes the integer X without knowing the K broken positions.  The subtasks are based on the maximum number of broken positions your algorithm can handle. Let's see some ideas for different K's.\nK = 0 : 0 points This is not a subtask, but you need to know how to solve this case in order to solve the full problem. The idea is very simple : send the binary encoding of X. We will use the binary encoding in all other subtasks , but you need to keep this idea in mind.\nWe use the first 60 positions to send the encoding and leave the other 90 unused.\nK = 1 : 8 points Because there is a broken place, we might not be able to send X using the 60 first positions. However, it will not be difficult to overcome that.\nThe key idea is to send a signal meaning that this is the place the binary representation starts. That is, the first number 1 of the sequence will mean \u0026ldquo;The following 60 numbers are the binary encoding of X\u0026rdquo;.\nIn order to use this idea, we need to be sure that there will 61 adjacent positions that are not broken. Because K = 1, we know that this is true.\nK = 15 : 41 points We will use a different strategy to send the binary encoding of X. The first step of our algorithm is to divide our 150 sequence into 75 buckets of size 2. The image bellow represents this idea , where grey is \u0026ldquo;0\u0026rdquo; and black is \u0026ldquo;1\u0026rdquo;.\nThis will allow us to use an encoding that is less affected by the broken places, because we will not need that a lot of adjacent non-broken positions.\nOur encoding will use every 2 positions to send at most one bit. Notice that sometimes we may not send any information because of the broken places, but that is okay.\nWe will send the bits in order. If we receive \u0026ldquo;00\u0026rdquo;, then we did not send any information. If we receive \u0026ldquo;10\u0026rdquo;, this means that the next bit is \u0026ldquo;0\u0026rdquo;, and if we receive \u0026ldquo;11\u0026rdquo;, this means that the next bit is \u0026ldquo;1\u0026rdquo;.\nBy using this encoding , we can send up to 75 bits if there weren't any broken places. When there is at least one broken position in a bucket, in the worst case, we lose that bucket.\nConsidering we need to send 60 bits, we can afford to lose up to 15 buckets. So we solve to K up to 15.\nIntermediary K's : 41+ points We can improve the previous solution to handle more broken positions.\nThe first improvement is to find a meaning for \u0026ldquo;01\u0026rdquo;, something that we did not. By meaning we are not only talking about \u0026ldquo;1\u0026rdquo; or \u0026ldquo;0\u0026rdquo;, but other creative ideas like repeating previous numbers.\nThe second improvement is to use randomization in order to avoid the worst case of our algorithm:\n We may shuffle the position of the bits, in order to prevent the worst case where each broken position is on a different bucket We may change the integer we are sending by XORing it with a random number. This prevents cases where all numbers are 1 or 0, which can be bad for some ideas. To recover the original integer on the decoding part, we simply XOR the number we found with the random number  We need to carefully implement these ideas because we need to be able to revert the changes in the decoding part.\nK = 40 : 100 points The final solution is somewhat similar to the 41 points solution, but instead uses buckets of size 3.\nWith buckets of size 3 , we can create an encoding that sends up to 2 bits per bucket. Inefficient implementations of this idea do not score full points, but do better than the 41 point solution. I will go straight to the efficient implementation of the idea, but you may take sometime to create a encoding on your own.\nBecause of the size, we will use a encoding-table that is more resistant to broken places. The special property of the table is that it will allow us to send 2 bits of information in the case there are no broken places and 1 bit of information in the case there is one broken place.\nBecause of that, we can always send 60 bits regardless of the configuration. One possible table is the following :\nMy implementation of this idea:\n ","date":1535209200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535209200,"objectID":"acdfa229b2631f23215ca770f5e8bc95","permalink":"https://ivaniscoding.github.io/posts/informationtheory3/","publishdate":"2018-08-25T12:00:00-03:00","relpermalink":"/posts/informationtheory3/","section":"posts","summary":"Analysis of Broken Device from the Japanese Olympiad in Informatics Spring Camp 2017","tags":["algorithms"],"title":"Information Theory #3 - Broken Device","type":"posts"},{"authors":null,"categories":["Information Theory"],"content":"I am writing a series of posts about Information Theory problems. You may find the previous one here.\nThe problem we will analyze is Navigation from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2015). You may find the problem statement and a place to submit here.\nA synthesis of the problem statement is : Anna lives in an island that is part of the IOI islands, that can be represented by an acyclic connected graph. Bruno will visit Anna, but he does not know the whole structure of the tree. He only knows the adjacent islands to the island he is currently at. To help Bruno , Anna will write an integer on each island such that Brunno can go to Anna's island using the short possible path.\nWe must submit two files:\n One that given the structure of the tree and the island Anna lives, writes a number on each island One that given the current island and its number, the adjacent islands to that island and their respective number, goes from that island to the one closest to Anna's island. In the case Bruno is already on Anna's island, you must not move.  The subtasks are based on the maximum number you wrote on the vertices of the tree.\nSubtask 1 : No restrictions For all subtasks , we will root the tree at Anna's island.\nThe idea for this subtask is to write on each node its distance from the root of the tree when we are encoding. The image above exemplifies this idea.\nWhen we are decoding, we just go to the node whose number is the smallest.\nSubtask 2 : use numbers 0, 1 and 2 We need to use something completely different from our previous solution.\nInstead of writing the distances, we will create a table telling wether we should or shouldn't go to a node based on the number of the current node.\nThis table should be complementary : if 0-\u0026gt;1 means go, 1-\u0026gt;0 means do not go. Because of that, we discard 0-\u0026gt;0 , 1-\u0026gt;1 and 2-\u0026gt;2. Even tough we have 6 possibilites, it is possible to find a table that does what we want.\nTo mark each node with the correct integer, we start by doing a DFS from the root. We can choose any integer for the root, so we choose 0 . At each step, we write for the children of our current vertex the number such that it means \u0026ldquo;Don't go\u0026rdquo;.\nDecoding is easy because of the table. The only case we need to be aware is for the root, because in that case we will find only \u0026ldquo;Don't go\u0026rdquo;, so we must return the own vertex in that case.\nSubtasks 3 and 4 : 0 and 1 With only two numbers , it is impossible to find a table like the previous one. In order to solve the problem , we must try a different strategy or find some implicit information that we have not used so far.\nIn this case, we will go with the second option. At the current point, we have not taken advantage of the fact that the number of the vertices remain the same. That is a lot of information !\nOur previous solution relied heavily on the idea of the complementary table. We need to find some information that is complementary and uses the number of the vertices.\nAn operator that does exactly that is the less than operator. If (a \u0026lt; b) equals true, then (a \u0026gt; b) equals false. This was the implicit information we were looking for.\nIn order to decide wether we should or shouldn't go from vertex A to B, we will calculate the following value : v = (integer written on A) + (integer written on B) + (A \u0026lt; B). If v is an even number, then we do not go. If v is an odd number, then we go.\nBecause of the complementary nature of the less operator, if v means \u0026ldquo;Go\u0026rdquo; to A, then it will mean \u0026ldquo;Don't go\u0026rdquo; to B.\nTo mark the correct integer on each node, we start by doing a DFS from the root. For each children, we choose the correct integer such that we write \u0026ldquo;Don't go\u0026rdquo; from the current node.\nEven tough there was a lot of thinking , the final code is very simple. Wow!\n ","date":1535140800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535140800,"objectID":"c68e0afd24147e9521faca933995b2b7","permalink":"https://ivaniscoding.github.io/posts/informationtheory2/","publishdate":"2018-08-24T17:00:00-03:00","relpermalink":"/posts/informationtheory2/","section":"posts","summary":"Analysis of Navigation from the Japanese Olympiad in Informatics Spring Camp 2015","tags":["algorithms"],"title":"Information Theory #2 - Navigation","type":"posts"},{"authors":null,"categories":["Information Theory"],"content":"Information Theory problems are not common and that is why I am writing about them.\nThey generally consist of two parts : encoding and decoding. It seems to be simple in theory, but problem setters get very creative when adding restrictions that make simple things hard.\nEach problem is unique, however there are some aspects that seem to be shared by many problems:\n It is important to know what you need to send It relevant to know which information will be available to both the encoder and decoder Binary encoding is an efficient way of sending data  The problem we will analyze is Coins from the Practice Section of the International Olympiad in Informatics (IOI 2017 Practice). You may find the problem statement and a place to submit here . I have chosen this one because it is neither too easy nor too hard, so it is the ideal one to start.\nA synthesis of the problem statement is : you have a number C (0 \u0026lt;= C \u0026lt; 64) and an array of 64 numbers that are either 0 or 1. In the encoding part, you may change the status of at least one number and at most K numbers of the array. In the decoding part, you receive the array already with the changes and you must answer the number C.\nWe will focus on the subtasks 3, 4 and 5.\nSubtask 3 : K = 64  The idea of this task is to calculate the number C by the number of 1's in the array. Thus, we flip 0's to 1's until we have C 1's in our array.\nNotice that we must always flip at least one coin. So in the case the number of 1's is already equal to C, we need to flip the same coin twice.\nSubtask 4 : K = 8 The idea above wastes lots of implicit information that is shared between the encoder and decoder. In order to reduce the number of flips, we must use that information.\nBecause the position of the numbers of the array do not change, we can use the first 8 coins to send the binary representation of the number C. So we need to flip at most 8 coins, and not 64 like before.\nNotice again that in the case the 8 first coins already correspond to the binary encoding of C, we need to flip the same coin twice because we must flip some coin.\nSubtask 5 : K = 1 Honestly, I was a bit surprised when the problem asked for a solution that uses only one coin flip. I did not expect such a efficient solution at first. However, after thinking about some bitwise operators, I was able to design an algorithm that did the job.\nFirstly , we will need to define a new decoding function for the array. This function may seem a little bit strange at first, but is has a very special property that solves the problem.\nLet A be the array we receive. f(A) = i1^i2^\u0026hellip;ik where \u0026ldquo;^\u0026rdquo; is the bitwise XOR operator and i1,i2 \u0026hellip; ik the positions that are \u0026ldquo;1\u0026rdquo; on the array. In the case A has no \u0026ldquo;1\u0026rdquo;, f(A) = 0.\nThe first special property is that result of the function is always an integer x such that 0 \u0026lt;= x \u0026lt;= 63. The second is that when we flip the coin j of A and obtain the array A*, the value f(A*) = f(A)^j , regardless of the state of position j in the array A.\nBecause 0 \u0026lt;= x \u0026lt;= 63 and 0 \u0026lt;= C \u0026lt;= 63, we can prove that there is an y , 0 \u0026lt;= y \u0026lt;= 63, such that x^y.\nThis leads to the solution. We calculate the value of f(Aj*) for Aj* identical to A , except for the j-th coin that is flipped, for all 0 \u0026lt;= j \u0026lt;= 63. One of the j's will lead to a configuration whose function value is C, so we return that j as the solution.\nA further improvement is that we can know the value of j even quicker. Because of the XOR properties, j = f(A)^C is the position our previous algorithm would find.\nThe final code could not be simpler.\n ","date":1535126400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535126400,"objectID":"f1b38490e96e7882f7937ded84faf996","permalink":"https://ivaniscoding.github.io/posts/informationtheory1/","publishdate":"2018-08-24T13:00:00-03:00","relpermalink":"/posts/informationtheory1/","section":"posts","summary":"Analysis of Coins from the Practice Section of the International Olympiad in Informatics 2017","tags":["algorithms"],"title":"Information Theory #1 - Coins","type":"posts"},{"authors":null,"categories":["Divide and Conquer"],"content":"This is the fourth post of a series that focuses on Divide and Conquer. If you want to check the previous one, click here.\nThe problem we will analyze is ICC from the Central-European Olympiad in Informatics (CEOI 2016). You may find the problem statement here and a place to submit the solution here.\nA synthesis of the problem statement is : there are N cities numbered from 1 to N. At each pass, we build a new road between two cities such that there is no cycle between them. You must guess the new road by asking the following question : is there an edge from a vertex of set A to a vertex of set B? The total number of queries for the N-1 passes must not exceed M queries. There are five subtasks with different (N,M) pairs, but N = 100 and M = 1625 for the last one.\nThe fact that the statement mentions roads and cities heavily suggests that this is a graph problem. Indeed, it is one!\n Every city is a vertex Every road is an edge Our graph is a forest At each pass, we add an edge between vertices of different forests Just by modeling the problem with a graph we arrive at the most simple solution:  O(N^3) : 7 points At each pass, we query all possible edges. Notice that the possible edges do not include edges that connect two vertices of the same forest because of the acyclic property of our graph. In order to maintain that, we use an Union-Find data structure.\nTo check wether or not there is an edge between two vertices, we do a query with unitary sets containing these vertices.\nThe complexity analysis is not complicated. There are O(N^2) edges and O(N) passes, so the total number of queries is O(N^3).\nO(N^2) : 18 points To reduce the number of queries, we will not try to discover directly the pair of vertices that is connected by the new edge. Instead, we will try to discover for each vertex if it is the one with a new edge.\nTo do that we do the following query : we put the vertex we are considering now in a unitary set and all the vertices that are not on the subtree of this vertex. The image above exemplifies this.\nThere will be two vertices that have new edges. These were the vertices we wanted to know and the new edge connect those vertices. The overall complexity is O(N) per pass and there are O(N) passes, so in total its O(N^2).\nRoom for improvement : the start of D\u0026amp;C\nSuppose that we found the first vertex that has a new edge. We can use a Divide and Conquer algorithm to find the other one because we know it is on the set we have just asked about.\nLet's exemplify the algorithm with an example. Suppose we discovered that the vertex 1 has the new edge and the other vertex is on the set {2,3,4,5,6}. We split the set into L = {2,3,4} and R = {5,6} and do the query with sets {1} and L. If there is an edge between 1 and L , then we can discard R because there is only one edge. Similarly, if there is not, we discard L and continue with R. We continue to do that until we end with a set with only one element : the last element is the other vertex of the edge.\nSo our \u0026ldquo;Divide\u0026rdquo; part is to split the set into two halves L and R and do the query between the known vertex and L. The \u0026ldquo;Conquer\u0026rdquo; part is to discard L or R based on the result of our query. The base case is the unitary set.\nThis improvement alone does not give any extra points. However, the idea of the final solution uses this improvement.\nA desire : the perfect environment Suppose we had two sets A and B and we knew that there is a new edge from a vertex of set A to one on set B. If this happened , we could adapt the above algorithm to discover the two vertices very quickly.\nIf we fixed the set A for all the queries and did the above procedure on B, we would find the vertex that has the edge on B. We could also fix B and run the algorithm on A, discovering the vertex on A.\nSo the D\u0026amp;C part of the problem has ended. If we could find those two sets, the problem would be solved. But can we?\nThe answer is fortunately yes.\nO(N*log(N) + N*K) : 61 points The first idea two find the two sets is to use some randomization. Suppose that we put the connected components we have so far (represented by the head of the component) in a sequence and randomly shuffle the sequence. Then , we split the sequence into two halves. The probability that the components whose vertices form the new edge are on different halves if of 50%. We then construct two sets : A with the vertices of the components on the first half and B with the remaining ones. If there is an edge from A to B , we stop the shuffling and run the D\u0026amp;C algorithm. Otherwise, we continue until we arrive in a partition.\nThe number of passes algorithm is not defined. However, we could say that on average it will need K passes. A good estimative of K is a K that gives a probability close to 1 that the partition will be found. Because 1 - (0.5)**10 \u0026gt;= 99.9%, K = 10 seems to be a reasonable one.\nThe overall complexity is O(log(N) + K) per pass and therefore O(N*log(N) + N*K) total complexity.\nO(N*log(N)) : 90 points The final solutions uses a quicker approach to arrive at the partition.\nThe partition used is based on a simple principle with a clever application. The idea is : every number written in its binary form has at least one different bit if we compare it to another number.\nYou may take a look at the image above with the representation of {0,1,2,3} in binary base and convince yourself. The formal proof is not that hard, but I will omit it.\nBecause of the principle above, the following strategy will find a partition : first, we assign a integer from 0 to C-1 for each component.\nThen, for each bit, we separe the vertex into two sets A and B according to the state of that bit. A contains the vertices whose component number has the bit we are considering turned off and B contains the vertices whose component number has the bit turned on. We test this partition : if it works, then we run the D\u0026amp;C algorithm; if it does not, we follow to the next bit. By doing that, we achieve O(log(N)) to discover the partition which is a small improvement against the last algorithm, but scores more points because of the tight query limit.\nO(N*log(N)) : 100 points The solution mentioned above is 99% similar to the final solution. The only diference is that in order to achieve 100 points you need to do some micro optimizations.\nThe first idea to reduce the number of queries is to shuffle the order that you choose the bit to do the partition. The grader is adaptative and tries to achieve the worst case complexity if you always ask about the bits in order, so shuffling prevents this from happening. If you implement this idea alone you should score 100 points.\nThe second idea is to save a query per iteration when doing the partition. Imagine there are K bits to try the partition and you have tried K-1 of them. You do not need to check if the last one will find a valid partition, because it must. This is a small gain but helps.\nMy solution to this problem :\n ","date":1535058000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535058000,"objectID":"dc521c53bbee7d2c23240e241ba64afe","permalink":"https://ivaniscoding.github.io/posts/divideandconquer4/","publishdate":"2018-08-23T18:00:00-03:00","relpermalink":"/posts/divideandconquer4/","section":"posts","summary":"Analysis of ICC from the Central-European Olympiad in Informatics 2016","tags":["algorithms"],"title":"Divide and Conquer #4 - ICC","type":"posts"},{"authors":null,"categories":["Divide and Conquer"],"content":"This is the third post of a series that focuses on Divide and Conquer. If you want to check the previous one, click here.\nThe problem we will analyze is Library from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement here and a place to submit here.\nA synthesis of the problem statement is : you have an array of size N (N \u0026lt;= 1000) that is a permutation of 1,2,3\u0026hellip; N. At the beginning you do not know the configuration of the array. However, you are allowed to make up to 20000 queries which count the number of subarrays of the subset of numbers you are querying. After that, you must output one of the two possible configurations of the array.\nOur first step in order to solve the problem is to transform it into a graph problem:\n Every number of the array is a vertex There is an edge between every two adjacent numbers in the array Our query answers the number of connected components of the subgraph we chose for that query.  This first steps leads very quickly to the solution to subtask 1:\nO(N^2) : 19 points We simply try to discover all edges of the graph. To check wether or not there is an edge , we do a query with only two elements. If there is one connected component, then there is an edge. Otherwise, there is not an edge.\nAfter that, you can do a BFS/DFS starting from one of the two vertices with degree one and find one of the two possible answers.\nO(N*log(N)) : 100 points We have about 20 queries per vertex in order to discover the configuration of the array. This heavily suggests around O(log(N)) queries per vertex, which is a hint that Divide and Conquer might work.\nThe first step of our algorithm will be adding the vertices in order :\nWhen we adding the i-th vertex, the other i-1 vertices form C connected components. Each component has two endpoints (note that the endpoints can be equal when there is only one element). You may think of these components as floating subarrays whose order is still to be defined. In the image, there is an example for a situation where we are adding the vertex 8.\nThere are three possible cases for our newly added vertex :\n Zeroth case : there is no edge between i and the other components , therefore i is a part of a new connected component and the total number of components is increased. First case : there is exactly one edge of i to one of the endpoints of the components. The number of components remains the same. Second case : there are exactly two edges between i and two endpoints of different components. Therefore we merge two components in this step and the total number decreases by one.  To make the last two cases clearer, you may look at the examples above of the first and second case , respectively.\nThe first query we will make for our new vertex is asking about the configuration with all the C components and the vertex. The answer of the query uniquely determines the case : if there are C+1 components, then we know it is case 0 and we can continue our algorithm; if there are C components, then we know it is case 1 and we need to discover the component the i-th vertex is connecting and which vertex it is connecting to; the last option is that there are C - 1 components, in which we need to discover the two components and the two distinct endpoints.\nThe next step of our solution is to create a D\u0026amp;C algorithm for the first case. It turns out that this algorithm is very similar to the algorithm of our last two posts :\nWe split the set of the components we have into two halves, L and R. We then try a configuration with the components of L and the i-th vertex. If there are |L| + 1 components in that configuration, then there is no edge between the i-th vertex and the components of L and we discard all components of L , because we know that the edge is on R. Otherwise, the number of components is |L| and we discard all components of R because of the same concept.\nNotice that when we do an iteration, we discard half of the components and arrive at the same problem we had before. If we continue to do that, we will eventually reach the case where there is only one component : this is our base case and the last component is the one we are looking for.\nAfter that, we need to discover the vertex that connects with the i-th one. This is very simple and can be done with one query : try to check if there is an edge between the i-th vertex and one of the endpoints the same way we did in the previous solution. If there is one, then we found the edge. If there is not, then the edge will be between the other endpoint and the i-th vertex. After that, you must not forget to update the component you found and its endpoints.\nThe last step of our algorithm is to create a D\u0026amp;C algorithm for the second case. This part is a little bit more complicated compared to the last one, but not that much.\nThe \u0026ldquo;Divide\u0026rdquo; part of our algorithm is identical to the last one. We split the set we are querying into two sets L and R. The change is on the \u0026ldquo;Conquer\u0026rdquo; part, because now there are three possible results for our query with L plus i-th vertex.\n |L| - 1 components : the two edges are on L. We discard R and recurse into the same problem we had, that is , a set in case 2. |L| + 1 components : the two edges are on R. We discard L and recurse into the same problem we had. |L| components : there is one edge on L and consequently one on R. We recurse into two independent problems, which is to find exactly one edge in a set. This is the first case of our algorithm!  Therefore, the \u0026ldquo;Conquer\u0026rdquo; step may recurse into one problem of case 2 or two problems of case one. Our base case will be the same as case 1.\nAfter we discovered the two components, we need to discover the vertices we connect to. We do exactly the same procedure as in case 1, but we need to be more careful when updating and merging the components.\nA code that implements the idea and scores 100 points follows:\n ","date":1535040000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1535040000,"objectID":"28bb3b7d265533844cf1630c0defbbe5","permalink":"https://ivaniscoding.github.io/posts/divideandconquer3/","publishdate":"2018-08-23T13:00:00-03:00","relpermalink":"/posts/divideandconquer3/","section":"posts","summary":"Analysis of Library from the Japanese Olympiad in Informatics Spring Camp 2018","tags":["algorithms"],"title":"Divide and Conquer #3 - Library","type":"posts"},{"authors":null,"categories":["Divide and Conquer"],"content":"This is the second post of a series that focuses on Divide and Conquer. If you want to check the previous one, click here.\nThe problem we will analyze is Cave from the International Olympiad in Informatics (IOI 2013). You may find the problem statement here and a place to submit here.\nA synthesis of the problem statement is : you have N (1 \u0026lt;= N \u0026lt;= 5000) switches and doors. Each switch is linked to a door and has two possible configurations (0 or 1) : one that opens the connected door and one that does not. You can try up to 70000 configurations of switches and see the last door that is open. After those tries you must return the connected door to each switch and also its correct state.\nThere are 5 subtask in this problem. Subtasks 1 and 2 are the ones that give the most crucial hints in order to arrive to the full solution. However, I will use a different strategy to get the 100 points : we will focus on the first door.\nThe reason for that is that you do not need to know any information about the other doors in order to know about the first one. Therefore, it seems to be a good approach to focus on it.\nOur first problem is to discover the correct state of the switch that opens the first door.\nTo solve this, we will try a configuration where all switches are set to the same configuration. Let's exemplify that with an image. Imagine that each switch is a position in our sequence of blocks, that the color blue represents the state \u0026ldquo;0\u0026rdquo; and that the color yellow represents \u0026ldquo;1\u0026rdquo;. If we try a configuration with all blocks having the blue color and it opens the first door, then the switch that opens the first door must be blue; otherwise, the first door would not be open. In the case the configuration fails to open the door, then the switch must be yellow.\nOur second problem is then to discover which switch opens the first door. There are three approaches to discover the position of the switch : by doing a complete search, by bucketing switches and by using a Divide and Conquer approach.\nThe simplest idea is to do the complete search : we test all switches one by one. When we are trying a switch, we set it to the correct color and all the others to the complementary color.\nIf the configuration with only the i-th switch set opens the first door, then this is the switch we are looking for. Otherwise, we continue to try other switches. An image helps us exemplify the idea again : first we test only the first switch with the correct color blue. In that case it did not work out, so we must try the second switch with the blue color. Then we discover that this configuration opens the first door and we assign the first door to the second switch.\nA refinement of the idea above is to use buckets in order to do less queries.\nWe group the switches into B buckets of roughly the same size. Then we apply the complete search idea , but with buckets instead : we set all the switches of the current bucket we are testing to the correct state and all the other ones to the complementary state. By doing this, we will discover the bucket that contains the desired switch. After that, we do a complete search on the switches of that bucket. The total number of queries is B + N/B. The value of B that minimizes the sum is sqrt(N), so this is a considerable gain if we consider that the idea is not that much different from the O(N) approach.\nThe most efficient idea will then be Divide and Conquer. The key idea of our algorithm will be that there is one and only one switch that opens the first door.\nThe \u0026ldquo;Divide\u0026rdquo; part of our algorithm will be as follows : we split the current set of switches we are considering into two halves. We then try a configuration with the switches of the first half set to the correct state and all other switches set to the complementary state.\nThe \u0026ldquo;Conquer\u0026rdquo; part is based in the result of our query. If the mentioned configuration opens the first door, then the switch we are looking for is on the first half and we discard all the switches of the other half. If it does not, then we discard all the ones from the first half and stick with the ones from the second half. Let's make an example with the set {1,2,3,4,5,6}. We split the set into L = {1,2,3} and R = {4,5,6} and try the configuration as described above and exemplified by the image above. Imagine that this configuration does not open the first door : then , we discard L and our set is now {4,5,6}.\nWe continue the procedure and split the set in {4,5} and {6}. If we discover that {4,5} opens the door, than we discard {6}. Then we split {4,5} into {4} and {5} and do the query again.\nWe continue the procedure until we arrive into a set that contains a single switch. This the base case of our D\u0026amp;C recursion : the final element must be the switch we are looking for.\nThe analysis of our idea is based on the depth of the recursion tree : because at each step we discard half of the nodes, then the maximal depth if log2(N).\nSo we arrived at a fast solution to discovering the correct state and switch that opens the first door. However, we still need to take care of the other N-1 doors. This will not be very different from our current idea.\nThe tweak is indeed very simple : we find the informations for the doors in order (1,2,3 and so on\u0026hellip;). When we are doing our queries for the i-th door, we remove the switches that opens the other i-1 doors from the set of candidates and set them to the correct states we discovered in the previous iterations of our algorithm. Therefore, discovering the correct state and switch that opens the i-th door with the information about the i-1 previous doors is equivalent to the problem of solving for the first door.\nHere is a code that implements the D\u0026amp;C algorithm and scores 100 points :\n ","date":1534946400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1534946400,"objectID":"2e5bf5d8a18f676e6808c37f911096ae","permalink":"https://ivaniscoding.github.io/posts/divideandconquer2/","publishdate":"2018-08-22T11:00:00-03:00","relpermalink":"/posts/divideandconquer2/","section":"posts","summary":"Analysis of Cave from the International Olympiad in Informatics 2013","tags":["algorithms"],"title":"Divide and Conquer #2 - Cave","type":"posts"},{"authors":null,"categories":["Divide and Conquer"],"content":"This is the first post of a series of posts about Divide and Conquer. The idea is to share this simple yet very powerful approach to solve some problems.\nThis is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as Merge Sort and Binary Search.\nThe problem we will analyze is Carnival from the Central-European Olympiad in Informatics (CEOI 2014). You may find the problem statement here and a place to submit the solution here.\nAfter reading the problem statement it seems very smart to model it with a graph:\n Every person is represented as a vertex in our graph. Every costume is represented by a color in our graph. Each vertex has only one color. Every vertex is part of a connected component of vertex with the same color. This connected component is a clique. When we organize a party, we query the number of distinct colors of the set of vertices we chose.  Modeling the problem with the graph helps us arrive at the first partial solution:\nO(N^2) queries : 20 points A direct approach to solve the problem is to discover all the edges of the graph. To discover if there is an edge between two vertices, we organize a party with these two vertices. If there are two costumes, then they are of different colors and there is no edge. Otherwise, they share the same color and there is an edge between them.\nOptimized O(N^2) : 100 points There are some optimizations to make the previous solution work faster.\nThe first idea is to choose a head to each component we know so far and always ask questions with it . Because of the clique property, it does not matter which pair of vertices we query : any of them will do the work. This saves lots of questions\nThe second idea is to add vertices gradually. We will first query 1, then 2, 3 and so on. This allow us to the following query : organize a party with the H heads we know so far and the i-th vertex we are adding. If in this party there are H + 1 costumes, then we know that the i-th vertex has no edge to any of those heads and is therefore a head of its own component. In the other case there will be H costumes and we need to query all the possible edges to discover the component of the i-th vertex.\nTo make it clearer , see this example : we are adding vertex 6 and we know there are 4 head nodes : 1,3,4,5. If we organize the party and there are 5 costumes, then vertex 6 must have a color different from the other 4 vertices. In the other case, with 4 costumes, 6 must have the same color of one of those vertices. In that case, we find the color of 6 by testing an edge with each head.\nThe number of queries is still quadratic because of the case were the i-th vertex is not a new head. However, the constant is heavily reduced. This probably was not the intended solution, but it works.\nO(N*sqrt(N)) : 100 points An idea to optimize the previous solution is to group the heads into buckets. We do the first query with all the H heads to discover wether the i-th vertex is a new head or not in the same way as before.\nBut the second part changes. Instead of manually testing all edges with the heads, we group them into B buckets with H/B per bucket. Then we organized parties with the i-th vertex and all heads of each bucket. If there are H/B + 1 costumes, then we proceed to the next bucket. Otherwise, we test the edge with all the heads of this bucket.\nThis gives B + H/B queries per vertex. The value of the that minimizes this sum is sqrt(H). Therefore we achieve the complexity of O(N*sqrt(N)), better than the last one.\nO(N*log(N)) : 100 points The title of this post includes \u0026ldquo;Divide and Conquer\u0026rdquo; and so far none of the solutions used it, so at some moment D\u0026amp;C must appear. This is the moment!\nThe principle we will use is the same from the previous solutions. However, we will use it way more efficiently. The idea of querying H heads plus the i-th vertex and deciding wether or not there is a edge based on the answer will be our base.\nTo start, we do the now usual query with all heads like in the previous solution.\nIf there is an edge, then we start to use D\u0026amp;C. The \u0026ldquo;Divide\u0026rdquo; part of our algorithm will be to partition our set of heads in two halves, L and R and querying the heads of L and the i-th vertex.\nThe \u0026ldquo;Conquer\u0026rdquo; part of our algorithm is based on the result of our query and the fact that there is only one edge between the i-th vertex and the whole set. If that edge is on the set L, then we can discard all the heads of R. If that edge is not on that set, then it must be on R,because there is exactly one edge so we discard all heads of L.\nLet's make another example with adding 6 , knowing heads 1,3,4,5. We split the heads in {1,3} and {4,5} and do the query {1,3,6}. Suppose we received that there are 3 colors in the set. Then there is no edge between 6 and {1,3} and we now solve the problem with the set {4,5}.\nIf we continue to do the procedure of discarding a half in each iteration, we will eventually reach our base case : the set has only one element. Therefore , there must be an edge between the i-th vertex and the last element.\nIf we want to analyze the complexity , we must think about the depth of the recursion we designed. In each iteration, we discard H/2 heads so the depth will be at most log2(H). Thus the overall number of queries is O(N*log(N)).\nMy implementation of this idea:\n ","date":1534896000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1534896000,"objectID":"42e3c868327e21cfff539267debeea80","permalink":"https://ivaniscoding.github.io/posts/divideandconquer1/","publishdate":"2018-08-21T21:00:00-03:00","relpermalink":"/posts/divideandconquer1/","section":"posts","summary":"Analysis of Carnival from the Central-European Olympiad in Informatics 2014","tags":["algorithms"],"title":"Divide and Conquer #1 - Carnival","type":"posts"},{"authors":null,"categories":null,"content":"","date":1527811200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1527811200,"objectID":"39ccd56c63538d5361997b4fae88b8bc","permalink":"https://ivaniscoding.github.io/project/olympiad_solutions/","publishdate":"2018-06-01T00:00:00Z","relpermalink":"/project/olympiad_solutions/","section":"project","summary":"Solutions in C++ to more than 1500 algorithmic problems from previous programming competitions.","tags":["Demo"],"title":"Olympiad Solutions ![](/img/Badges/olympiad.svg)","type":"project"},{"authors":null,"categories":null,"content":"","date":1514768400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514768400,"objectID":"a57e956b5a69825dab6e23813ccd93f1","permalink":"https://ivaniscoding.github.io/project/dragonstore/","publishdate":"2018-01-01T01:00:00Z","relpermalink":"/project/dragonstore/","section":"project","summary":"An e-commerce website for selling digital games that is automatically deployed to the cloud by Github Actions.","tags":["Demo"],"title":"DragonStore ![](/img/Badges/dragonstore.svg)","type":"project"},{"authors":null,"categories":null,"content":"  https://ivaniscoding.github.io/  ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6083a88ee3411b0d17ce02d738f69d47","permalink":"https://ivaniscoding.github.io/about/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/about/","section":"","summary":"  https://ivaniscoding.github.io/  ","tags":null,"title":"","type":"page"}]