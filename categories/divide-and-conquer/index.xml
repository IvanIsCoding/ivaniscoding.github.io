<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Divide and Conquer | Ivan Carvalho</title>
    <link>https://ivaniscoding.github.io/categories/divide-and-conquer/</link>
      <atom:link href="https://ivaniscoding.github.io/categories/divide-and-conquer/index.xml" rel="self" type="application/rss+xml" />
    <description>Divide and Conquer</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 03 Mar 2019 10:00:00 -0800</lastBuildDate>
    <image>
      <url>https://ivaniscoding.github.io/images/icon_hud7c04f8250daa34436c1572b3b03bb6e_328675_512x512_fill_lanczos_center_2.png</url>
      <title>Divide and Conquer</title>
      <link>https://ivaniscoding.github.io/categories/divide-and-conquer/</link>
    </image>
    
    <item>
      <title>Divide-and-conquer Techniques #1 - All But One Trick</title>
      <link>https://ivaniscoding.github.io/posts/dctrick1/</link>
      <pubDate>Sun, 03 Mar 2019 10:00:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/dctrick1/</guid>
      <description>&lt;p&gt;This is a post about one very interesting Divide-and-conquer technique. I call this the &amp;ldquo;All but one&amp;rdquo; trick because that&#39;s an accurate description
of what it can be used for. I learned about this in the &lt;a href=&#34;http://maratona.ic.unicamp.br/BrazilianICPCSummerSchool2018/&#34;&gt;Brazilian ICPC Summer School in 2018&lt;/a&gt;, thanks to &lt;a href=&#34;https://www.mimuw.edu.pl/~idziaszek/index.html&#34;&gt;Tomasz Idziaszek&lt;/a&gt; and thought it would be
a good addition to this blog. In this post, I will briefly explain the technique and show its application in one problem.&lt;/p&gt;
&lt;p&gt;This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Merge_sort&#34;&gt;Merge Sort&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search&#34;&gt;Binary Search&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;the-problem-it-solves&#34;&gt;The problem it solves&lt;/h1&gt;
&lt;p&gt;This trick is useful to solve the following kind of problem: Imagine there is a structure &lt;strong&gt;S&lt;/strong&gt; with &lt;strong&gt;N&lt;/strong&gt; elements. To build &lt;strong&gt;S&lt;/strong&gt;, you add elements one at a time. You would like to know what
&lt;strong&gt;S&lt;/strong&gt; would look like if, for each element, we considered &lt;strong&gt;S&lt;/strong&gt; without it. However, it is computationally expensive to remove an arbitrary single element.&lt;/p&gt;
&lt;p&gt;A naive approach to this problem that is very straightforward is to rebuild &lt;strong&gt;S&lt;/strong&gt; multiple times without each element. Even though this approach works,
a lot of computations are wasted because many times we have almost the same state for &lt;strong&gt;S&lt;/strong&gt;. After analyzing this, a question arises: is there a more efficient way to do it?&lt;/p&gt;
&lt;p&gt;If removing the last addition to &lt;strong&gt;S&lt;/strong&gt; is fast, then the answer is yes. It uses a clever observation that follows nicely into a Divide-and-Conquer Algorithm.&lt;/p&gt;
&lt;h1 id=&#34;the-algorithm&#34;&gt;The algorithm&lt;/h1&gt;
&lt;p&gt;The idea for the algorithm can be described as follows: if we have a set of &lt;strong&gt;N&lt;/strong&gt; elements, we split into two sets of roughly equal size. Then, for one of the halves, we will add all of its elements to &lt;strong&gt;S&lt;/strong&gt;. Notice that by doing this, we arrive at the same conceptual problem for the other half: find &lt;strong&gt;S&lt;/strong&gt; without a single element for each element.&lt;/p&gt;
&lt;p&gt;Hence, we can continue the procedure until we arrive with a set of a single element. When that happens, we can answer the query about &lt;strong&gt;S&lt;/strong&gt; without that element. The only missing point with that idea is that we need to answer the query for every element and not only for a single one. To solve this, we just need to change a few things when we recurse up.&lt;/p&gt;
&lt;p&gt;The changes are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Remove all additions that were made in the step when we recurse up.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add the elements of the half that were not added at first, and recurse to the half that was added at first.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lastly, we need to undo those add operations when we recurse back to maintain the fact that calling the Divide and Conquer function does not alter the state of &lt;strong&gt;S&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now the algorithm works because we can guarantee that we will arrive at a situation with a single element for every element and that when that happens all the other elements will have been added to &lt;strong&gt;S&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If the operation of adding has a complexity of &lt;strong&gt;O(K)&lt;/strong&gt; and the operation of undoing has a complexity of &lt;strong&gt;O(L)&lt;/strong&gt;, then the algorithm has an overall complexity of &lt;strong&gt;O(N*(K+L)*log(N))&lt;/strong&gt;. A pseudo-implementation of the algorithm is given below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void DivideAndConquer(int s, int e){

    // Base case: single element
    if(s == e){
        // Answer your query !
        return ;
    }

    int m = (s+e)/2; // we will split the set into two

    /* 
    First part: add elements of the right,
    recurse to the left and undo
    */

    for(int i = m+1; i&amp;lt;=e; i++){
        // Adding elements of the right half
        add(i);
    }

    DivideAndConquer(s, m); // recursing to the left half

    for(int i = e; i&amp;gt;=m+1; i--){
        // undo all the operations of addition
        undo();
    }

    /*
    Second part: add elements of the left,
    recurse to the right and undo
    */

    for(int i = s; i&amp;lt;=m; i++){
        // Adding elements of the left half
        add(i);
    }

    DivideAndConquer(m+1, e); // recursing to the right half

    for(int i = m; i &amp;gt;= s; i--){
        // undo all the operations of addition
        undo();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;example-problem&#34;&gt;Example Problem&lt;/h1&gt;
&lt;p&gt;The problem we will analyze is Voltage from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2014). You may find the problem statement and a place to submit &lt;a href=&#34;https://dunjudge.me/analysis/problems/763/&#34;&gt;here&lt;/a&gt; and the original problem statement in Japanese &lt;a href=&#34;https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d3.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : There is a circuit with &lt;strong&gt;N&lt;/strong&gt; nodes and &lt;strong&gt;M&lt;/strong&gt; resistors. Each node can be set either to low or high voltage, and current cannot flow through resistors connected to nodes of the same voltage. Calculate how many resistors can be removed such that if we remove only that resistors, there is current flowing in all other resistors.&lt;/p&gt;
&lt;h1 id=&#34;reduction-to-the-trick-and-solution&#34;&gt;Reduction to the trick and solution&lt;/h1&gt;
&lt;p&gt;The problem can be reduced to the following one: check if without an edge &lt;strong&gt;E&lt;/strong&gt;, the graph is bipartite.&lt;/p&gt;
&lt;p&gt;The structure to verify if a graph is bipartite while adding edges is a modified &lt;a href=&#34;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&#34;&gt;Disjoint Set Union-Find&lt;/a&gt;. I will not be going into many details, but you may find more explanation about it in this &lt;a href=&#34;https://discuss.codechef.com/questions/131944/bipartite-checking-using-dsu&#34;&gt;CodeChef discussion&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Removing an arbitrary edge from the DSU is fairly difficult, but removing the last one is not due to the stack-like structure of the DSU. Hence, the problem we have fits in the range of the applications of the trick and can be solved in &lt;strong&gt;O(N*log(N)^2)&lt;/strong&gt;. The implementation using the technique follows:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/d435ce4634fd54ff99428ee15e9730d7.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #4 - ICC</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer4/</link>
      <pubDate>Thu, 23 Aug 2018 18:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer4/</guid>
      <description>&lt;p&gt;This is the fourth post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer3/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is ICC from the Central-European Olympiad in Informatics (CEOI 2016). You may find the problem statement here and a place to submit the solution &lt;a href=&#34;http://www.ceoi2016.ro/wp-content/uploads/2016/08/icc-statement.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : there are N cities numbered from 1 to N. At each pass, we build a new road between two cities such that there is no cycle between them. You must guess the new road by asking the following question : is there an edge from a vertex of set A to a vertex of set B? The total number of queries for the N-1 passes must not exceed M queries. There are five subtasks with different (N,M) pairs, but N = 100 and M = 1625 for the last one.&lt;/p&gt;
&lt;p&gt;The fact that the statement mentions roads and cities heavily suggests that this is a graph problem. Indeed, it is one!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/arvore1.png&#34; alt=&#34;Graph representation of the problem&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every city is a vertex&lt;/li&gt;
&lt;li&gt;Every road is an edge&lt;/li&gt;
&lt;li&gt;Our graph is a forest&lt;/li&gt;
&lt;li&gt;At each pass, we add an edge between vertices of different forests&lt;/li&gt;
&lt;li&gt;Just by modeling the problem with a graph we arrive at the most simple solution:&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;on3--7-points&#34;&gt;O(N^3) : 7 points&lt;/h2&gt;
&lt;p&gt;At each pass, we query all possible edges. Notice that the possible edges do not include edges that connect two vertices of the same forest because of the acyclic property of our graph. In order to maintain that, we use an Union-Find data structure.&lt;/p&gt;
&lt;p&gt;To check wether or not there is an edge between two vertices, we do a query with unitary sets containing these vertices.&lt;/p&gt;
&lt;p&gt;The complexity analysis is not complicated. There are O(N^2) edges and O(N) passes, so the total number of queries is O(N^3).&lt;/p&gt;
&lt;h2 id=&#34;on2--18-points&#34;&gt;O(N^2) : 18 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/quadratico.png&#34; alt=&#34;One-versus all idea&#34;&gt;&lt;/p&gt;
&lt;p&gt;To reduce the number of queries, we will not try to discover directly the pair of vertices that is connected by the new edge. Instead, we will try to discover for each vertex if it is the one with a new edge.&lt;/p&gt;
&lt;p&gt;To do that we do the following query : we put the vertex we are considering now in a unitary set and all the vertices that are not on the subtree of this vertex. The image above exemplifies this.&lt;/p&gt;
&lt;p&gt;There will be two vertices that have new edges. These were the vertices we wanted to know and the new edge connect those vertices. The overall complexity is O(N) per pass and there are O(N) passes, so in total its O(N^2).&lt;/p&gt;
&lt;p&gt;Room for improvement : the start of D&amp;amp;C&lt;/p&gt;
&lt;p&gt;Suppose that we found the first vertex that has a new edge. We can use a Divide and Conquer algorithm to find the other one because we know it is on the set we have just asked about.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/icc0.png&#34; alt=&#34;Refining the idea&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&#39;s exemplify the algorithm with an example. Suppose we discovered that the vertex 1 has the new edge and the other vertex is on the set {2,3,4,5,6}. We split the set into L = {2,3,4} and R = {5,6} and do the query with sets {1} and L. If there is an edge between 1 and L , then we can discard R because there is only one edge. Similarly, if there is not, we discard L and continue with R. We continue to do that until we end with a set with only one element : the last element is the other vertex of the edge.&lt;/p&gt;
&lt;p&gt;So our &amp;ldquo;Divide&amp;rdquo; part is to split the set into two halves L and R and do the query between the known vertex and L. The &amp;ldquo;Conquer&amp;rdquo; part is to discard L or R based on the result of our query. The base case is the unitary set.&lt;/p&gt;
&lt;p&gt;This improvement alone does not give any extra points. However, the idea of the final solution uses this improvement.&lt;/p&gt;
&lt;p&gt;A desire : the perfect environment &lt;/p&gt;
&lt;p&gt;Suppose we had two sets A and B and we knew that there is a new edge from a vertex of set A to one on set B. If this happened , we could adapt the above algorithm to discover the two vertices very quickly.&lt;/p&gt;
&lt;p&gt;If we fixed the set A for all the queries and did the above procedure on B, we would find the vertex that has the edge on B. We could also fix B and run the algorithm on A, discovering the vertex on A.&lt;/p&gt;
&lt;p&gt;So the D&amp;amp;C part of the problem has ended. If we could find those two sets, the problem would be solved. But can we?&lt;/p&gt;
&lt;p&gt;The answer is fortunately yes.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--nk--61-points&#34;&gt;O(N*log(N) + N*K) : 61 points&lt;/h2&gt;
&lt;p&gt;The first idea two find the two sets is to use some randomization. Suppose that we put the connected components we have so far (represented by the head of the component) in a sequence and randomly shuffle the sequence. Then , we split the sequence into two halves. The probability that the components whose vertices form the new edge are on different halves if of 50%. We then construct two sets : A with the vertices of the components on the first half and B with the remaining ones. If there is an edge from A to B , we stop the shuffling and run the D&amp;amp;C algorithm. Otherwise, we continue until we arrive in a partition.&lt;/p&gt;
&lt;p&gt;The number of passes algorithm is not defined. However, we could say that on average it will need K passes. A good estimative of K is a K that gives a probability close to 1 that the partition will be found. Because 1 - (0.5)**10 &amp;gt;= 99.9%, K = 10 seems to be a reasonable one.&lt;/p&gt;
&lt;p&gt;The overall complexity is O(log(N) + K) per pass and therefore O(N*log(N) + N*K) total complexity.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--90-points&#34;&gt;O(N*log(N)) : 90 points&lt;/h2&gt;
&lt;p&gt;The final solutions uses a quicker approach to arrive at the partition.&lt;/p&gt;
&lt;p&gt;The partition used is based on a simple principle with a clever application. The idea is : every number written in its binary form has at least one different bit if we compare it to another number.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/binary.png&#34; alt=&#34;Bit representation example&#34;&gt;&lt;/p&gt;
&lt;p&gt;You may take a look at the image above with the representation of {0,1,2,3} in binary base and convince yourself. The formal proof is not that hard, but I will omit it.&lt;/p&gt;
&lt;p&gt;Because of the principle above, the following strategy will find a partition : first, we assign a integer from 0 to C-1 for each component.&lt;/p&gt;
&lt;p&gt;Then, for each bit, we separe the vertex into two sets A and B according to the state of that bit. A contains the vertices whose component number has the bit we are considering turned off and B contains the vertices whose component number has the bit turned on. We test this partition : if it works, then we run the D&amp;amp;C algorithm; if it does not, we follow to the next bit. By doing that, we achieve O(log(N)) to discover the partition which is a small improvement against the last algorithm, but scores more points because of the tight query limit.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;The solution mentioned above is 99% similar to the final solution. The only diference is that in order to achieve 100 points you need to do some micro optimizations.&lt;/p&gt;
&lt;p&gt;The first idea to reduce the number of queries is to shuffle the order that you choose the bit to do the partition. The grader is adaptative and tries to achieve the worst case complexity if you always ask about the bits in order, so shuffling prevents this from happening. If you implement this idea alone you should score 100 points.&lt;/p&gt;
&lt;p&gt;The second idea is to save a query per iteration when doing the partition. Imagine there are K bits to try the partition and you have tried K-1 of them. You do not need to check if the last one will find a valid partition, because it must. This is a small gain but helps.&lt;/p&gt;
&lt;p&gt;My solution to this problem :&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/fe07e32dc71523ee3f234d6487bb8c1a.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #3 - Library</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer3/</link>
      <pubDate>Thu, 23 Aug 2018 13:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer3/</guid>
      <description>&lt;p&gt;This is the third post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer2/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Library from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement &lt;a href=&#34;https://www.ioi-jp.org/camp/2018/2018-sp-tasks/day4/library-en.pdf&#34;&gt;here&lt;/a&gt; and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI18_library&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have an array of size N (N &amp;lt;= 1000) that is a permutation of 1,2,3&amp;hellip; N. At the beginning you do not know the configuration of the array. However, you are allowed to make up to 20000 queries which count the number of subarrays of the subset of numbers you are querying. After that, you must output one of the two possible configurations of the array.&lt;/p&gt;
&lt;p&gt;Our first step in order to solve the problem is to transform it into a graph problem:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/library0.png&#34; alt=&#34;Graph representation of the problem&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every number of the array is a vertex&lt;/li&gt;
&lt;li&gt;There is an edge between every two adjacent numbers in the array&lt;/li&gt;
&lt;li&gt;Our query answers the number of connected components of the subgraph we chose for that query.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This first steps leads very quickly to the solution to subtask 1:&lt;/p&gt;
&lt;h2 id=&#34;on2--19-points&#34;&gt;O(N^2) : 19 points&lt;/h2&gt;
&lt;p&gt;We simply try to discover all edges of the graph. To check wether or not there is an edge , we do a query with only two elements. If there is one connected component, then there is an edge. Otherwise, there is not an edge.&lt;/p&gt;
&lt;p&gt;After that, you can do a BFS/DFS starting from one of the two vertices with degree one and find one of the two possible answers.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;We have about 20 queries per vertex in order to discover the configuration of the array. This heavily suggests around O(log(N)) queries per vertex, which is a hint that Divide and Conquer might work.&lt;/p&gt;
&lt;p&gt;The first step of our algorithm will be adding the vertices in order :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/floating.png&#34; alt=&#34;Floating graph componnents&#34;&gt;&lt;/p&gt;
&lt;p&gt;When we adding the i-th vertex, the other i-1 vertices form C  connected components. Each component has two endpoints (note that the endpoints can be equal when there is only one element). You may think of these components as floating subarrays whose order is still to be defined. In the image, there is an example for a situation where we are adding the vertex 8.&lt;/p&gt;
&lt;p&gt;There are three possible cases for our newly added vertex :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zeroth case : there is no edge between i and the other components , therefore i is a part of a new connected component and the total number of components is increased.&lt;/li&gt;
&lt;li&gt;First case : there is exactly one edge of i to one of the endpoints of the components. The number of components remains the same.&lt;/li&gt;
&lt;li&gt;Second case : there are exactly two edges between i and two endpoints of different components. Therefore we merge two components in this step and the total number decreases by one.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/caso1.png&#34; alt=&#34;Possible cases&#34;&gt;&lt;/p&gt;
&lt;p&gt;To make the last two cases clearer, you may look at the examples above of the first and second case , respectively.&lt;/p&gt;
&lt;p&gt;The first query we will make for our new vertex is asking about the configuration with all the C  components and the vertex. The answer of the query uniquely determines the case : if there are C+1 components, then we know it is case 0 and we can continue our algorithm; if there are C components, then we know it is case 1 and we need to discover the component the i-th vertex is connecting and which vertex it is connecting to; the last option is that there are C - 1 components, in which we need to discover the two components and the two distinct endpoints.&lt;/p&gt;
&lt;p&gt;The next step of our solution is to create a D&amp;amp;C algorithm for the first case. It turns out that this algorithm is very similar to the algorithm of our last two posts :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/dc0.png&#34; alt=&#34;Divide and Conquer appears again&#34;&gt;&lt;/p&gt;
&lt;p&gt;We split the set of the components we have into two halves, L and R. We then try a configuration with the components of L and the i-th vertex. If there are |L| + 1 components in that configuration, then there is no edge between the i-th vertex and the components of L and we discard all components of L , because we know that the edge is on R. Otherwise, the number of components is |L| and we discard all components of R because of the same concept.&lt;/p&gt;
&lt;p&gt;Notice that when we do an iteration, we discard half of the components and arrive at the same problem we had before. If we continue to do that, we will eventually reach the case where there is only one component : this is our base case and the last component is the one we are looking for.&lt;/p&gt;
&lt;p&gt;After that, we need to discover the vertex that connects with the i-th one. This is very simple and can be done with one query : try to check if there is an edge between the i-th vertex and one of the endpoints the same way we did in the previous solution. If there is one, then we found the edge. If there is not, then the edge will be between the other endpoint and the i-th vertex. After that, you must not forget to update the component you found and its endpoints.&lt;/p&gt;
&lt;p&gt;The last step of our algorithm is to create a D&amp;amp;C algorithm for the second case. This part is a little bit more complicated compared to the last one, but not that much.&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Divide&amp;rdquo; part of our algorithm is identical to the last one. We split the set we are querying into two sets L and R. The change is on the &amp;ldquo;Conquer&amp;rdquo; part, because now there are three possible results for our query with L plus i-th vertex.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;|L| - 1 components : the two edges are on L. We discard R and recurse into the same problem we had, that is , a set in case 2.&lt;/li&gt;
&lt;li&gt;|L| + 1 components : the two edges are on R. We discard L and recurse into the same problem we had.&lt;/li&gt;
&lt;li&gt;|L| components : there is one edge on L and consequently one on R. We recurse into two independent problems, which is to find exactly one edge in a set. This is the first case of our algorithm!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Therefore, the &amp;ldquo;Conquer&amp;rdquo; step may recurse into one problem of case 2 or two problems of case one. Our base case will be the same as case 1.&lt;/p&gt;
&lt;p&gt;After we discovered the two components, we need to discover the vertices we connect to. We do exactly the same procedure as in case 1, but we need to be more careful when updating and merging the components.&lt;/p&gt;
&lt;p&gt;A code that implements the idea and scores 100 points follows:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/79fa951989731f161542868c8c51cc7f.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #2 - Cave</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer2/</link>
      <pubDate>Wed, 22 Aug 2018 11:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer2/</guid>
      <description>&lt;p&gt;This is the second post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer1/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Cave from the International Olympiad in Informatics (IOI 2013). You may find the problem statement &lt;a href=&#34;https://ioinformatics.org/files/ioi2013problem4.pdf&#34;&gt;here&lt;/a&gt; and a place to submit &lt;a href=&#34;https://dmoj.ca/problem/ioi13p4&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have N (1 &amp;lt;= N &amp;lt;= 5000) switches and doors. Each switch is linked to a door and has two possible configurations (0 or 1) : one that opens the connected door and one that does not. You can try up to 70000 configurations of switches and see the last door that is open. After those tries you must return the connected door to each switch and also its correct state.&lt;/p&gt;
&lt;p&gt;There are 5 subtask in this problem. Subtasks 1 and 2 are the ones that give the most crucial hints in order to arrive to the full solution. However, I will use a different strategy to get the 100 points : we will focus on the first door.&lt;/p&gt;
&lt;p&gt;The reason for that is that you do not need to know any information about the other doors in order to know about the first one. Therefore, it seems to be a good approach to focus on it.&lt;/p&gt;
&lt;p&gt;Our first problem is to discover the correct state of the switch that opens the first door.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/divide0.png&#34; alt=&#34;Initial State&#34;&gt;&lt;/p&gt;
&lt;p&gt;To solve this, we will try a configuration where all switches are set to the same configuration. Let&#39;s exemplify that with an image. Imagine that each switch is a position in our sequence of blocks, that the color blue represents the state &amp;ldquo;0&amp;rdquo; and that the color yellow represents &amp;ldquo;1&amp;rdquo;. If we try a configuration with all blocks having the blue color and it opens the first door, then the switch that opens the first door must be blue; otherwise, the first door would not be open. In the case the configuration fails to open the door, then the switch must be yellow.&lt;/p&gt;
&lt;p&gt;Our second problem is then to discover which switch opens the first door. There are three approaches to discover the position of the switch : by doing a complete search, by bucketing switches and by using a Divide and Conquer approach.&lt;/p&gt;
&lt;p&gt;The simplest idea is to do the complete search : we test all switches one by one. When we are trying a switch, we set it to the correct color and all the others to the complementary color.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave51.png&#34; alt=&#34;Brute Force&#34;&gt;
&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave71.png&#34; alt=&#34;Brute Force&#34;&gt;&lt;/p&gt;
&lt;p&gt;If the configuration with only the i-th switch set opens the first door, then this is the switch we are looking for. Otherwise, we continue to try other switches. An image helps us exemplify the idea again : first we test only the first switch with the correct color blue. In that case it did not work out, so we must try the second switch with the blue color. Then we discover that this configuration opens the first door and we assign the first door to the second switch.&lt;/p&gt;
&lt;p&gt;A refinement of the idea above is to use buckets in order to do less queries.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/bucket2.png&#34; alt=&#34;Buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;We group the switches into B buckets of roughly the same size. Then we apply the complete search idea , but with buckets instead : we set all the switches of the current bucket we are testing to the correct state and all the other ones to the complementary state. By doing this, we will discover the bucket that contains the desired switch. After that, we do a complete search on the switches of that bucket. The total number of queries is B + N/B. The value of B that minimizes the sum is sqrt(N), so this is a considerable gain if we consider that the idea is not that much different from the O(N) approach.&lt;/p&gt;
&lt;p&gt;The most efficient idea will then be Divide and Conquer. The key idea of our algorithm will be that there is one and only one switch that opens the first door.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave1.png&#34; alt=&#34;First step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Divide&amp;rdquo; part of our algorithm will be as follows : we split the current set of switches we are considering into two halves. We then try a configuration with the switches of the first half set to the correct state and all other switches set to the complementary state.&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Conquer&amp;rdquo; part is based in the result of our query. If the mentioned configuration opens the first door, then the switch we are looking for is on the first half and we discard all the switches of the other half. If it does not, then we discard all the ones from the first half and stick with the ones from the second half. Let&#39;s make an example with the set {1,2,3,4,5,6}. We split the set into L = {1,2,3} and R = {4,5,6} and try the configuration as described above and exemplified by the image above. Imagine that this configuration does not open the first door : then , we discard L and our set is now {4,5,6}.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave2.png&#34; alt=&#34;Second step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;We continue the procedure and split the set  in {4,5} and {6}. If we discover that {4,5} opens the door, than we discard {6}. Then we split {4,5} into {4} and {5} and do the query again.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave3.png&#34; alt=&#34;Third step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;We continue the procedure until we arrive into a set that contains a single switch. This the base case of our D&amp;amp;C recursion : the final element must be the switch we are looking for.&lt;/p&gt;
&lt;p&gt;The analysis of our idea is based on the depth of the recursion tree : because at each step we discard half of the nodes, then the maximal depth if log2(N).&lt;/p&gt;
&lt;p&gt;So we arrived at a fast solution to discovering the correct state and switch that opens the first door. However, we still need to take care of the other N-1 doors. This will not be very different from our current idea.&lt;/p&gt;
&lt;p&gt;The tweak is indeed very simple : we find the informations for the doors in order (1,2,3 and so on&amp;hellip;). When we are doing our queries for the i-th door, we remove the switches that opens the other i-1 doors from the set of candidates and set them to the correct states we discovered in the previous iterations of our algorithm. Therefore, discovering the correct state and switch that opens the i-th door with the information about the i-1 previous doors is equivalent to the problem of solving for the first door.&lt;/p&gt;
&lt;p&gt;Here is a code that implements the D&amp;amp;C algorithm and scores 100 points :&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/959274b5107c0542116a195f966f789e.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #1 - Carnival</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer1/</link>
      <pubDate>Tue, 21 Aug 2018 21:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer1/</guid>
      <description>&lt;p&gt;This is the first post of a series of posts about Divide and Conquer. The idea is to share this simple yet very powerful approach to solve some problems.&lt;/p&gt;
&lt;p&gt;This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Merge_sort&#34;&gt;Merge Sort&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search&#34;&gt;Binary Search&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Carnival from the Central-European Olympiad in Informatics (CEOI 2014). You may find the problem statement &lt;a href=&#34;http://ceoi2014.informatik-olympiade.de/wp-content/uploads/2014/06/carnival.pdf&#34;&gt;here&lt;/a&gt; and a place to submit the solution &lt;a href=&#34;https://oj.uz/problem/view/CEOI14_carnival&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After reading the problem statement it seems very smart to model it with a graph:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/teste.png&#34; alt=&#34;Testing&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every person is represented as a vertex in our graph.&lt;/li&gt;
&lt;li&gt;Every costume is represented by a color in our graph. Each vertex has only one color.&lt;/li&gt;
&lt;li&gt;Every vertex is part of a connected component of vertex with the same color. This connected component is a clique.&lt;/li&gt;
&lt;li&gt;When we organize a party, we query the number of distinct colors of the set of vertices we chose.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Modeling the problem with the graph helps us arrive at the first partial solution:&lt;/p&gt;
&lt;h2 id=&#34;on2-queries--20-points&#34;&gt;O(N^2) queries : 20 points&lt;/h2&gt;
&lt;p&gt;A direct approach to solve the problem is to discover all the edges of the graph. To discover if there is an edge between two vertices, we organize a party with these two vertices. If there are two costumes, then they are of different colors and there is no edge. Otherwise, they share the same color and there is an edge between them.&lt;/p&gt;
&lt;h2 id=&#34;optimized-on2--100-points&#34;&gt;Optimized O(N^2) : 100 points&lt;/h2&gt;
&lt;p&gt;There are some optimizations to make the previous solution work faster.&lt;/p&gt;
&lt;p&gt;The first idea is to choose a head to each component we know so far and always ask questions with it . Because of the clique property, it does not matter which pair of vertices we query : any of them will  do the work. This saves lots of questions&lt;/p&gt;
&lt;p&gt;The second idea is to add vertices gradually. We will first query 1, then 2, 3 and so on. This allow us to the following query : organize a party with the H heads we know so far and the i-th vertex we are adding. If in this party there are H + 1 costumes, then we know that the i-th vertex has no edge to any of those heads and is therefore a head of its own component. In the other case there will be H costumes and we need to query all the possible edges to discover the component of the i-th vertex.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa0.png&#34; alt=&#34;First Step&#34;&gt;&lt;/p&gt;
&lt;p&gt;To make it clearer , see this example : we are adding vertex 6 and we know there are 4 head nodes : 1,3,4,5. If we organize the party and there are 5 costumes, then vertex 6 must have a color different from the other 4 vertices. In the other case, with 4 costumes, 6 must have the same color of one of those vertices. In that case, we find the color of 6 by testing an edge with each head.&lt;/p&gt;
&lt;p&gt;The number of queries is still quadratic because of the case were the i-th vertex is not a new head. However, the constant is heavily reduced. This probably was not the intended solution, but it works.&lt;/p&gt;
&lt;h2 id=&#34;onsqrtn--100-points&#34;&gt;O(N*sqrt(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/bucket.png&#34; alt=&#34;Splitting the nodes into buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;An idea to optimize the previous solution is to group the heads into buckets. We do the first query with all the H heads to discover wether the i-th vertex is a new head or not in the same way as before.&lt;/p&gt;
&lt;p&gt;But the second part changes. Instead of manually testing all edges with the heads, we group them into B buckets with H/B per bucket. Then we organized parties with the i-th vertex and all heads of each bucket. If there are H/B + 1 costumes, then we proceed to the next bucket. Otherwise, we test the edge with all the heads of this bucket.&lt;/p&gt;
&lt;p&gt;This gives B + H/B queries per vertex. The value of the that minimizes this sum is sqrt(H). Therefore we achieve the complexity of O(N*sqrt(N)), better than the last one.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;The title of this post includes &amp;ldquo;Divide and Conquer&amp;rdquo; and so far none of the solutions used it, so at some moment D&amp;amp;C must appear. This is the moment!&lt;/p&gt;
&lt;p&gt;The principle we will use is the same from the previous solutions. However, we will use it way more efficiently.  The idea of querying &lt;strong&gt;H&lt;/strong&gt; heads plus the i-th vertex and deciding wether or not there is a edge based on the answer will be our base.&lt;/p&gt;
&lt;p&gt;To start, we do the now usual query with all heads like in the previous solution.&lt;/p&gt;
&lt;p&gt;If there is an edge, then we start to use D&amp;amp;C. The &amp;ldquo;Divide&amp;rdquo; part of our algorithm will be to partition our set of heads in two halves, L and R and querying the heads of L and the i-th vertex.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa1.png&#34; alt=&#34;Splitting the node into halves&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Conquer&amp;rdquo; part of our algorithm is based on the result of our query and the fact that there is only one edge between the i-th vertex and the whole set. If that edge is on the set &lt;strong&gt;L&lt;/strong&gt;, then we can discard all the heads of &lt;strong&gt;R&lt;/strong&gt;. If that edge is not on that set, then it must be on &lt;strong&gt;R&lt;/strong&gt;,because there is exactly one edge so we discard all heads of &lt;strong&gt;L&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&#39;s make another example with adding 6 , knowing heads 1,3,4,5. We split the heads in {1,3} and {4,5} and do the query {1,3,6}. Suppose we received that there are 3 colors in the set. Then there is no edge between 6 and {1,3} and we now solve the problem with the set {4,5}.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa3.png&#34; alt=&#34;Next step of halving the set&#34;&gt;&lt;/p&gt;
&lt;p&gt;If we continue to do the procedure of discarding a half in each iteration, we will eventually reach our base case : the set has only one element. Therefore , there must be an edge between the i-th vertex and the last element.&lt;/p&gt;
&lt;p&gt;If we want to analyze the complexity , we must think about the depth of the recursion we designed. In each iteration, we discard &lt;strong&gt;H/2&lt;/strong&gt; heads so the depth will be at most &lt;strong&gt;log2(H)&lt;/strong&gt;. Thus the overall number of queries is &lt;strong&gt;O(N*log(N))&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;My implementation of this idea:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/c297207d7b297eb4ba829502125121f7.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
  </channel>
</rss>
