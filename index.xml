<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ivan Carvalho</title>
    <link>https://ivaniscoding.github.io/</link>
      <atom:link href="https://ivaniscoding.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Ivan Carvalho</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Sun, 12 Jan 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://ivaniscoding.github.io/images/icon_hud7c04f8250daa34436c1572b3b03bb6e_328675_512x512_fill_lanczos_center_2.png</url>
      <title>Ivan Carvalho</title>
      <link>https://ivaniscoding.github.io/</link>
    </image>
    
    <item>
      <title>Quantomoku ![](/img/Badges/quantomoku.svg)</title>
      <link>https://ivaniscoding.github.io/project/quantomoku/</link>
      <pubDate>Sun, 12 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://ivaniscoding.github.io/project/quantomoku/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Quantum #7 - Grover</title>
      <link>https://ivaniscoding.github.io/posts/quantum7/</link>
      <pubDate>Thu, 02 Jan 2020 16:10:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/quantum7/</guid>
      <description>&lt;p&gt;This is the seventh post of a series of posts about Quantum Computing with &lt;a href=&#34;https://qiskit.org/&#34;&gt;Qiskit&lt;/a&gt;. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.&lt;/p&gt;
&lt;p&gt;The goal of this post is to discuss Grover’s algorithm. It is an algorithm to solve unstructured search in &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt N)\)&lt;/span&gt;, which is a quadratic speedup over the classical &lt;span class=&#34;math inline&#34;&gt;\(O(N)\)&lt;/span&gt; solution.&lt;/p&gt;
&lt;h2 id=&#34;unstructured-search&#34;&gt;Unstructured Search&lt;/h2&gt;
&lt;p&gt;Imagine that you have a hard problem to solve such that your best-known solutions is to try all the possibilities. That problem could be:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Checking if two molecules are identical, i.e. solving &lt;a href=&#34;https://en.wikipedia.org/wiki/Graph_isomorphism_problem&#34;&gt;graph isomorphism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Finding the shortest route that passes through all cities, the &lt;a href=&#34;https://en.wikipedia.org/wiki/Travelling_salesman_problem&#34;&gt;travelling salesman problem&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Classically, those are examples of unstructured search problems: the search space (i.e. possible solutions) has so little structure that the best strategy is just to try all possibilities.&lt;/p&gt;
&lt;p&gt;The complexity of solving that problem depends on how big the search space is: if there are &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; elements to check, the algorithm needs to make &lt;span class=&#34;math inline&#34;&gt;\(O(N)\)&lt;/span&gt; to an oracle (i.e. the entity that verifies if a solution is valid). That is the best that can be done.&lt;/p&gt;
&lt;p&gt;The quantum algorithm that will discuss today goes beyond: it can find the solution with &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt N)\)&lt;/span&gt; checks. Considering that there is no structure in the search space, Grover’s algorithm provides an impressive speedup. Moreover, unlike the last two quantum algorithms we discussed, an unstructured search is the component of many real-world problems. Thus, Grover’s algorithm has immediate applications.&lt;/p&gt;
&lt;p&gt;For our discussion today, we will pick a specific flavor of the search problem: we will try to find a needle in a haystack.&lt;/p&gt;
&lt;h3 id=&#34;needle-in-a-haystack&#34;&gt;Needle in a haystack&lt;/h3&gt;
&lt;p&gt;Imagine that you have a search space with &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; elements, with &lt;span class=&#34;math inline&#34;&gt;\(N-1\)&lt;/span&gt; straws that are useless, and exactly one needle that we are looking for.&lt;/p&gt;
&lt;p&gt;Mathematically, the problem is described by a function &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(x) = 1 \iff x = s
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(x) = 0 \iff x \neq s
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In which &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; is the solution string, i.e. the needle. Notice that &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; needs to be implemented by a quantum circuit, that we will call quantum oracle.&lt;/p&gt;
&lt;h2 id=&#34;steps-of-the-algorithm&#34;&gt;Steps of the algorithm&lt;/h2&gt;
&lt;p&gt;Now that we know the problem Grover’s algorithm solves, it is time to discuss it.&lt;/p&gt;
&lt;h3 id=&#34;assumptions&#34;&gt;Assumptions&lt;/h3&gt;
&lt;p&gt;On this discussion, we will assume two things that might not always be true in a search problem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(N = 2^{n}\)&lt;/span&gt;, that is &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; is a power of two&lt;/li&gt;
&lt;li&gt;There is exactly one solution&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Those assumptions are to simplify the discussion. Even though they are not always true, it is not hard to make a problem respect them.&lt;/p&gt;
&lt;p&gt;For the first assumption, if we are given a &lt;span class=&#34;math inline&#34;&gt;\(M\)&lt;/span&gt; that is not a power of two, we can just augment the search space to a &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; that is a power of two and have :&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
x &amp;gt; M \implies f(x) = 0
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;For the second assumption, Grover’s algorithm can still find a solution when there is multiple: it is just the number of iterations &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; that will change.&lt;/p&gt;
&lt;h3 id=&#34;step-1&#34;&gt;Step 1&lt;/h3&gt;
&lt;p&gt;Generate the superposition state:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}}|x\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;And initialize the ancilla qubit to &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Notice that on this step, each possible state &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; will have an equal probability of measurement, which is basically guessing the solution. The critical insight from Grover’s algorithm comes on the next step, in which we will try to improve the chance of measuring the solution.&lt;/p&gt;
&lt;h3 id=&#34;step-2&#34;&gt;Step 2&lt;/h3&gt;
&lt;p&gt;Apply Grover’s iteration &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; times:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Query the oracle. This is sometimes also called reflection around the solution.&lt;/li&gt;
&lt;li&gt;Invert about the mean. This is sometimes also called reflection around the superposition state.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The value &lt;span class=&#34;math inline&#34;&gt;\(K\)&lt;/span&gt; is given by &lt;span class=&#34;math inline&#34;&gt;\(K \approx \frac{\pi \sqrt N}{4}\)&lt;/span&gt;. Thus, the algorithm makes &lt;span class=&#34;math inline&#34;&gt;\(O(\sqrt N)\)&lt;/span&gt; queries to the oracle.&lt;/p&gt;
&lt;h3 id=&#34;step-3&#34;&gt;Step 3&lt;/h3&gt;
&lt;p&gt;Measure the qubits. &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; will be the measurement with a high probability. A lower-bound for correctness is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
P = 1 - \frac{1}{N}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Hence, for very big &lt;span class=&#34;math inline&#34;&gt;\(N\)&lt;/span&gt; our algorithm will guess the solution with a very high chance.&lt;/p&gt;
&lt;h2 id=&#34;grovers-iteration&#34;&gt;Grover’s iteration&lt;/h2&gt;
&lt;p&gt;At each iteration, Grover’s algorithm has a goal: to increase the amplitude &lt;span class=&#34;math inline&#34;&gt;\(\alpha_{s}\)&lt;/span&gt; of the solution and to decrease the amplitude &lt;span class=&#34;math inline&#34;&gt;\(\alpha_{x}\)&lt;/span&gt; of the non-solutions. To achieve it, it performs two specific steps as we will discuss.&lt;/p&gt;
&lt;h3 id=&#34;phase-kickback&#34;&gt;Phase kickback&lt;/h3&gt;
&lt;p&gt;Consider that at an arbitrary iteration of the algorithm, we will have a state &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \sum_{x \in \{0, 1\}^{n}}\alpha_{x} |x\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Graphically, the amplitudes could be seen as:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum7/Amplitude_Start.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The first step of the Grover iteration is to query the oracle. The oracle will be a transformation &lt;span class=&#34;math inline&#34;&gt;\(|x\rangle|a\rangle \rightarrow |x\rangle|a \oplus f(x)\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;We will now reuse a trick that was first discussed in &lt;a href=&#34;https://ivaniscoding.github.io/posts/quantum4/&#34;&gt;Deutsch-Jozsa’s algorithm&lt;/a&gt;: because the ancilla is &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)&lt;/span&gt;, then the phase will kickback in the form of a coefficient &lt;span class=&#34;math inline&#34;&gt;\((-1)^{f(x)}\)&lt;/span&gt;, and the ancilla will remain unchanged.&lt;/p&gt;
&lt;p&gt;Hence, that yields:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
U_{\omega}|\psi\rangle = \sum_{x \in \{0, 1\}^{n}} (-1)^{f(x)} \alpha_{x} |x\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice that this time, only one amplitude is negative: that of the solution. Graphically, it can be seen as:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum7/Amplitude_Kickback.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The next step is to perform an inversion about the mean. The idea is that combining phase kickback with a mean inversion, we will make the amplitude of the solution grow while reducing the amplitude of nonsolutions.&lt;/p&gt;
&lt;h3 id=&#34;inversion-about-the-mean&#34;&gt;Inversion about the mean&lt;/h3&gt;
&lt;p&gt;An inversion about the mean is reflecting the terms of a sequence &lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt; according to the mean &lt;span class=&#34;math inline&#34;&gt;\(\overline{C}\)&lt;/span&gt;. That is, we will find a new sequence &lt;span class=&#34;math inline&#34;&gt;\(D\)&lt;/span&gt; such that each term is &lt;span class=&#34;math inline&#34;&gt;\(C_{i}\)&lt;/span&gt; reflected.&lt;/p&gt;
&lt;p&gt;Imagine that you have an element &lt;span class=&#34;math inline&#34;&gt;\(C_{i}\)&lt;/span&gt;. We will find a new element &lt;span class=&#34;math inline&#34;&gt;\(D_{i}\)&lt;/span&gt; such that the distance between &lt;span class=&#34;math inline&#34;&gt;\(D_{i}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\overline{C}\)&lt;/span&gt; is the same as the distance between &lt;span class=&#34;math inline&#34;&gt;\(C_{i}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\overline{C}\)&lt;/span&gt;. Mathematically, that can be written as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|D_{i} - \overline{C}| = |C_{i} - \overline{C}|
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Solving the equation and ignoring the case in which &lt;span class=&#34;math inline&#34;&gt;\(C_{i} = D_{i}\)&lt;/span&gt;, we obtain:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
D_{i} = 2\overline{C} - C_{i}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;After the mean inversion transformation, &lt;span class=&#34;math inline&#34;&gt;\(\overline{D} = \overline{C}\)&lt;/span&gt; holds as well.&lt;/p&gt;
&lt;p&gt;At this point, you might be asking: what does mean inversion has to do with quantum computing? To answer that question, an example will do. Suppose that we have the sequence &lt;span class=&#34;math inline&#34;&gt;\(\{1, 1, 1, 1\}\)&lt;/span&gt; and we flip the sign of the third 1, that is we have:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
C = \{1, 1, -1, 1\}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The mean of this sequence is &lt;span class=&#34;math inline&#34;&gt;\(\frac{1}{2}\)&lt;/span&gt;. Now if we compute mean inversion using the formula given before, we obtain:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
D = \{0, 0, 2, 0\}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Something very interesting occurred: during the inversion, the only negative value of the sequence became the most positive while the old positives values diminished.&lt;/p&gt;
&lt;p&gt;Hence, mean inversion combined with phase kickback is exactly what we were looking for: it is going to make &lt;span class=&#34;math inline&#34;&gt;\(\alpha_{s}\)&lt;/span&gt; increase and decrease &lt;span class=&#34;math inline&#34;&gt;\(\alpha_{x}\)&lt;/span&gt; of the nonsolutions.&lt;/p&gt;
&lt;p&gt;Continuing the amplitude visualization we had before, mean inversion yields:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum7/Amplitude_Mean_Inverted.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Therefore, the idea is to perform phase kickback and mean inversion until &lt;span class=&#34;math inline&#34;&gt;\(\alpha_{s}\)&lt;/span&gt; is maximized. We will not discuss the math behind, but it turns out that &lt;span class=&#34;math inline&#34;&gt;\(\frac{\pi \sqrt N}{4}\)&lt;/span&gt; iterations suffice.&lt;/p&gt;
&lt;h2 id=&#34;implementing-the-quantum-oracle&#34;&gt;Implementing the quantum oracle&lt;/h2&gt;
&lt;p&gt;In real applications, the oracle would be a circuit that performs a meaningful computation: it could be solving the travelling salesman problem, trying to break an encryption key or just solving a hard problem in general.&lt;/p&gt;
&lt;p&gt;For this example problem, we will emulate a real-world problem: we will have a function that has one value &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; such that &lt;span class=&#34;math inline&#34;&gt;\(f(s) = 1\)&lt;/span&gt; and that &lt;span class=&#34;math inline&#34;&gt;\(f(x) = 0\)&lt;/span&gt; for all other &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Classically, it would look like:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-1&#34; title=&#34;1&#34;&gt;&lt;span class=&#34;kw&#34;&gt;def&lt;/span&gt; f(x):&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-2&#34; title=&#34;2&#34;&gt;    &lt;span class=&#34;cf&#34;&gt;if&lt;/span&gt; x &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; s:&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-3&#34; title=&#34;3&#34;&gt;        &lt;span class=&#34;cf&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-4&#34; title=&#34;4&#34;&gt;    &lt;span class=&#34;cf&#34;&gt;else&lt;/span&gt;:&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-5&#34; title=&#34;5&#34;&gt;        &lt;span class=&#34;cf&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The question now is: how does a quantum computer check that the state &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; is equal to &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;? The answer is: we verify if the binary representation of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; is identical to the binary representation of &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To do so, we use a multi-qubit Toffoli gate: we AND the equality of each bit. Because of the AND property, &lt;span class=&#34;math inline&#34;&gt;\(f(x) = 1\)&lt;/span&gt; if and only if each bit of &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; is equal to &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;, otherwise &lt;span class=&#34;math inline&#34;&gt;\(f(x) = 0\)&lt;/span&gt;. That implements exactly what we were looking for.&lt;/p&gt;
&lt;p&gt;A factor to consider is that if a bit is 0, we need to NOT it so when the AND is done the result is 1. Hence, the circuit implementing &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; for a string &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum7/Q7C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Notice that after applying the Toffoli, we do not want to change &lt;span class=&#34;math inline&#34;&gt;\(|x\rangle\)&lt;/span&gt; hence we apply NOT again on what was NOTed before.&lt;/p&gt;
&lt;h2 id=&#34;implementing-inversion-about-mean&#34;&gt;Implementing inversion about mean&lt;/h2&gt;
&lt;p&gt;To implement inversion about the mean, we will use the Grover diffusion operator. I will not discuss it much, but the operator can be written as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\mathcal{D} = -H^{\otimes n}U_{s}H^{\otimes n}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The idea is to implement the formula &lt;span class=&#34;math inline&#34;&gt;\(2\overline{C} - C_{i}\)&lt;/span&gt; using matrix multiplication. It can be shown that &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{D} = 2|+\rangle\langle+| - I\)&lt;/span&gt;, which is the matrix equivalent of the formula we found for mean inversion.&lt;/p&gt;
&lt;p&gt;An element of &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{D}\)&lt;/span&gt; we have not discussed yet is &lt;span class=&#34;math inline&#34;&gt;\(U_{s}\)&lt;/span&gt;: it is similar to the oracle &lt;span class=&#34;math inline&#34;&gt;\(U_{\omega}\)&lt;/span&gt;. It implements a function &lt;span class=&#34;math inline&#34;&gt;\(g(x)\)&lt;/span&gt; such that &lt;span class=&#34;math inline&#34;&gt;\(g(000...0) = 1\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(g(x) = 0\)&lt;/span&gt; for all other &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Therefore, we also use a multi-qubit Toffoli gate to implement &lt;span class=&#34;math inline&#34;&gt;\(U_{s}\)&lt;/span&gt; which yields the following circuit for &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{D}\)&lt;/span&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum7/Q7C1.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;implementing-grovers-algorithm&#34;&gt;Implementing Grover’s algorithm&lt;/h2&gt;
&lt;p&gt;We can verify that Grover’s algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try to find a needle in a haystack.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/089dc60e14775f2eca548e2f14930d94.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Quantum ![](/img/Badges/quantum.svg)</title>
      <link>https://ivaniscoding.github.io/project/quantum/</link>
      <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
      <guid>https://ivaniscoding.github.io/project/quantum/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Quantum #6 - Bernstein-Vazirani</title>
      <link>https://ivaniscoding.github.io/posts/quantum6/</link>
      <pubDate>Sat, 28 Dec 2019 20:10:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/quantum6/</guid>
      <description>&lt;p&gt;This is the sixth post of a series of posts about Quantum Computing with &lt;a href=&#34;https://qiskit.org/&#34;&gt;Qiskit&lt;/a&gt;. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.&lt;/p&gt;
&lt;p&gt;The goal of this post is to discuss how to discover a hidden string in a black box using Bernstein-Vazirani’s algorithm. There is also a connection between this algorithm and Deutsch-Jozsa’s algorithm, which was discussed in the last &lt;a href=&#34;https://ivaniscoding.github.io/posts/quantum5/&#34;&gt;post&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;decoding-a-hidden-string&#34;&gt;Decoding a hidden string&lt;/h2&gt;
&lt;p&gt;Imagine that you have a black box (or oracle) that implements a hidden function that takes n-bit strings and returns 0 or 1, that is &lt;span class=&#34;math inline&#34;&gt;\(f: \{0, 1\}^{n} \rightarrow \{0, 1\}\)&lt;/span&gt;. The output of the function is determined by a hidden string &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;, following the expression:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(x) = s \cdot x \mod 2
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;How many queries are needed to discover &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;?&lt;/p&gt;
&lt;p&gt;To clarify the notation used, by &lt;span class=&#34;math inline&#34;&gt;\(s \cdot x\)&lt;/span&gt; we mean the bitwise dot product of &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;. Mathematically, if &lt;span class=&#34;math inline&#34;&gt;\(s = a_{0}a_{1}a_{2}...a_{n-1}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(x = b_{0}b_{1}b_{2}...b_{n-1}\)&lt;/span&gt; then we define:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
s \cdot x = \sum_{0}^{n-1} a_{i}b_{i}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;From now on in the post, I will also write &lt;span class=&#34;math inline&#34;&gt;\(s \cdot x\)&lt;/span&gt; instead of &lt;span class=&#34;math inline&#34;&gt;\(s \cdot x \mod 2\)&lt;/span&gt; for convenience. Some authors even define &lt;span class=&#34;math inline&#34;&gt;\(s \cdot x\)&lt;/span&gt; as the sum mod 2.&lt;/p&gt;
&lt;h2 id=&#34;classical-approach&#34;&gt;Classical approach&lt;/h2&gt;
&lt;p&gt;Before discussing the quantum solution to the problem, it is important to understand the classical solution. We can interpret &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; as a function that computes the bitwise AND of &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;, and then counts the parity of turned on bits on &lt;span class=&#34;math inline&#34;&gt;\(s \wedge x\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Hence, when we are trying to discover &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; by evaluating &lt;span class=&#34;math inline&#34;&gt;\(f(x)\)&lt;/span&gt;, it is never advantageous to have &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; with many bits turned on because we only obtain the parity of it.&lt;/p&gt;
&lt;p&gt;A good strategy then is to use &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; with only one bit set on, that is &lt;span class=&#34;math inline&#34;&gt;\(x \in \{100..., 010..., 001.., ...\}\)&lt;/span&gt;. The Python code below implements exactly that idea:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-1&#34; title=&#34;1&#34;&gt;&lt;span class=&#34;kw&#34;&gt;def&lt;/span&gt; guess_hidden_string(f, n):&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-2&#34; title=&#34;2&#34;&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-3&#34; title=&#34;3&#34;&gt;    s &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-4&#34; title=&#34;4&#34;&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-5&#34; title=&#34;5&#34;&gt;    &lt;span class=&#34;cf&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;kw&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;bu&#34;&gt;range&lt;/span&gt;(n):&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-6&#34; title=&#34;6&#34;&gt;        result &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; f(&lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;**&lt;/span&gt;i)&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-7&#34; title=&#34;7&#34;&gt;        &lt;span class=&#34;cf&#34;&gt;if&lt;/span&gt; result &lt;span class=&#34;op&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;:&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-8&#34; title=&#34;8&#34;&gt;            s &lt;span class=&#34;op&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;**&lt;/span&gt;i&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-9&#34; title=&#34;9&#34;&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-10&#34; title=&#34;10&#34;&gt;    &lt;span class=&#34;cf&#34;&gt;return&lt;/span&gt; s&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This approach needs n queries to discover the n-bit hidden string, and overall &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; is the best we can achieve with classical computers. Can quantum computers do better?&lt;/p&gt;
&lt;h2 id=&#34;implementing-the-quantum-oracle&#34;&gt;Implementing the quantum oracle&lt;/h2&gt;
&lt;p&gt;Before we try to find a quantum solution, we will briefly discuss how to implement the quantum oracle because that step is needed to implement the actual algorithm.&lt;/p&gt;
&lt;p&gt;One key fact when implementing the oracle was discussed in the section before: &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; can be interpreted as discussing the parity of set bits of the bitwise AND. Hence, we may write:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(x) = (\sum_{0}^{n-1} a_{i} \wedge b_{i}) \mod 2
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Recalling that the XOR operator (&lt;span class=&#34;math inline&#34;&gt;\(\oplus\)&lt;/span&gt;) can be seen as the plus operator mod 2, we can go even further and write:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
f(x) = (a_{0} \wedge b_{0}) \oplus (a_{1} \wedge b_{1}) \oplus ... \oplus (a_{n-1} \wedge b_{n-1})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The XOR operator is represented by the CNOT gate on quantum computing, because it takes &lt;span class=&#34;math inline&#34;&gt;\(|a\rangle\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(|a \oplus b\rangle\)&lt;/span&gt;. Thus, our quantum oracle looks like the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum6/Q6C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For every bit &lt;span class=&#34;math inline&#34;&gt;\(a_{i} = 1\)&lt;/span&gt; in &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;, we apply the CNOT gate from the i-th qubit to the working qubit. That happens because if &lt;span class=&#34;math inline&#34;&gt;\(a_{i} = 0\)&lt;/span&gt;, then &lt;span class=&#34;math inline&#34;&gt;\(a_{i} \wedge b_{i} = 0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(x \oplus 0 = x\)&lt;/span&gt; thus we can ignore it. CNOT gates are used because they are the equivalent of &lt;span class=&#34;math inline&#34;&gt;\(\oplus\)&lt;/span&gt;, as discussed before.&lt;/p&gt;
&lt;h2 id=&#34;bernstein-vazirani&#34;&gt;Bernstein-Vazirani&lt;/h2&gt;
&lt;p&gt;This time, we will start by giving the solution to the problem. We will very computationally that it works and then justify it mathematically.&lt;/p&gt;
&lt;p&gt;The following circuit guesses the hidden string:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum5/Q5C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Firstly, we change the working qubit from &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt; by using the X gate.&lt;/p&gt;
&lt;p&gt;Secondly, we apply Hadamard gates to the n qubits. That state is then given to the quantum oracle.&lt;/p&gt;
&lt;p&gt;In the next step, the oracle yields the &lt;span class=&#34;math inline&#34;&gt;\(f(x)\)&lt;/span&gt; for the working qubit of each state, and that qubit is discarded afterward.&lt;/p&gt;
&lt;p&gt;To conclude the algorithm, we apply Hadamard gates again and measure the qubits. It is guaranteed that 100% of the measurements will be &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt;, the hidden string we were looking for. We will analyze later why &lt;span class=&#34;math inline&#34;&gt;\(|s\rangle\)&lt;/span&gt; is the state that originates after querying the oracle.&lt;/p&gt;
&lt;p&gt;Notice that we discovered the hidden string using only one query to the oracle, compared to the &lt;span class=&#34;math inline&#34;&gt;\(O(n)\)&lt;/span&gt; queries required by the classical algorithm.&lt;/p&gt;
&lt;h2 id=&#34;implementing-the-bernstein-vazirani-algorithm&#34;&gt;Implementing the Bernstein-Vazirani algorithm&lt;/h2&gt;
&lt;p&gt;We can verify that the Bernstein-Vazirani algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try to guess a hidden string from a black box.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/b1b1c57d275e19823fc5a1156d7e5008.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;analysis-why-the-circuit-works&#34;&gt;Analysis: why the circuit works&lt;/h1&gt;
&lt;p&gt;The first step in the analysis is to notice that the circuit used in Bernstein-Vazirani’s algorithm is identical to the circuit in &lt;a href=&#34;https://ivaniscoding.github.io/posts/quantum5/&#34;&gt;Deutsch-Jozsa’s algorithm&lt;/a&gt;. That is surprising at first because one algorithm works to find a hidden string and the other to distinguish between balanced and constant functions.&lt;/p&gt;
&lt;p&gt;Now, we will use a result from the discussion on the last post, to remember that the state after querying the oracle is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}} (-1)^{f(x)}|x\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;But this time, we know that our oracle is described by &lt;span class=&#34;math inline&#34;&gt;\(f(x) = s \cdot x\)&lt;/span&gt;. Thus:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}} (-1)^{s \cdot x}|x\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We will now claim that:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H^{\otimes n} |\psi\rangle = |s\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;That is, that applying the Hadamard gate to each qubit takes us from &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(|s\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To prove so, we will work backwards. Because &lt;span class=&#34;math inline&#34;&gt;\(H\)&lt;/span&gt; is the inverse gate of itself, then &lt;span class=&#34;math inline&#34;&gt;\(H^{\otimes n}\)&lt;/span&gt; is the inverse of &lt;span class=&#34;math inline&#34;&gt;\(H^{\otimes n}\)&lt;/span&gt;. Thus, proving our claim is equivalent to showing that:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H^{\otimes n} |s\rangle = \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}} (-1)^{s \cdot x}|x\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It would be useful to find a formula for &lt;span class=&#34;math inline&#34;&gt;\(H^{\otimes n} |s\rangle\)&lt;/span&gt; . We can start by finding a formula for &lt;span class=&#34;math inline&#34;&gt;\(H\)&lt;/span&gt;, that is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H |a\rangle = \frac{|0\rangle + (-1)^{a}|1\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The identity can be proved by verification of &lt;span class=&#34;math inline&#34;&gt;\(a = 0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(a = 1\)&lt;/span&gt;. We can even go further and write:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H |a\rangle = \frac{1}{\sqrt 2} \sum_{b \in \{0, 1\}} (-1)^{ab}|b\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Now that we have an identity for &lt;span class=&#34;math inline&#34;&gt;\(n = 1\)&lt;/span&gt;, it would be useful to generalize for greater values of n. For &lt;span class=&#34;math inline&#34;&gt;\(n = 2\)&lt;/span&gt;, we can think of the multiple qubits as tensor products and thus:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H^{\otimes 2}|a,c\rangle = (\frac{1}{\sqrt 2} \sum_{b \in \{0, 1\}} (-1)^{ab}|b\rangle) \otimes (\frac{1}{\sqrt 2} \sum_{d \in \{0, 1\}} (-1)^{cd}|c\rangle)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We may rewrite it in a formula closer to the &lt;span class=&#34;math inline&#34;&gt;\(s \cdot x\)&lt;/span&gt; product we defined earlier, that is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H^{\otimes 2}|s\rangle = \frac{1}{(\sqrt 2)^{2}} \sum_{x \in \{0, 1\}^{2}} (-1)^{s_{0}x_{0} + s_{1}x_{1}}|x\rangle 
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Because of the cycle of powers of -1, &lt;span class=&#34;math inline&#34;&gt;\((-1)^{a} = (-1)^{a \mod 2}\)&lt;/span&gt; and thus the -1 exponent is &lt;span class=&#34;math inline&#34;&gt;\(s \cdot x\)&lt;/span&gt;! Therefore, we may generalize to all &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; (the proof can be done by induction):&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H^{\otimes n}|s\rangle = \frac{1}{(\sqrt 2)^{n}} \sum_{x \in \{0, 1\}^{n}} (-1)^{s\cdot x}|x\rangle 
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Hence, our circuit works because it takes &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(|s\rangle\)&lt;/span&gt; due to the inverse nature of &lt;span class=&#34;math inline&#34;&gt;\(H^{\otimes n}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The connection between Deutsch-Jozsa’s and Bernstein-Vazirani’s algorithm becomes clearer then:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;math inline&#34;&gt;\(f(x) = s \cdot x\)&lt;/span&gt; is a balanced function (or constant if &lt;span class=&#34;math inline&#34;&gt;\(s\)&lt;/span&gt; is all zeroes)!&lt;/li&gt;
&lt;li&gt;If a black box from Deutsch-Jozsa’s returns a state &lt;span class=&#34;math inline&#34;&gt;\(|s\rangle\)&lt;/span&gt; with 100% chance, then the black box implements &lt;span class=&#34;math inline&#34;&gt;\(f(x) = s \cdot x\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Quantum #5 - Deutsch-Jozsa (part 2)</title>
      <link>https://ivaniscoding.github.io/posts/quantum5/</link>
      <pubDate>Sat, 28 Dec 2019 00:10:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/quantum5/</guid>
      <description>&lt;p&gt;This is the fifth post of a series of posts about Quantum Computing with &lt;a href=&#34;https://qiskit.org/&#34;&gt;Qiskit&lt;/a&gt;. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.&lt;/p&gt;
&lt;p&gt;The goal of this post is to continue the discussion of the Deutsch-Jozsa algorithm, starting off where we stopped on &lt;a href=&#34;https://ivaniscoding.github.io/posts/quantum4/&#34;&gt;part 1&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;deutsch-jozsa-problem&#34;&gt;Deutsch-Jozsa problem&lt;/h2&gt;
&lt;p&gt;After having introduced the Deutsch problem, we will now introduce the Deutsch-Jozsa which is a generalization of the Deutsch problem. In particular, the Deutsch problem is the case of Deutsch-Jozsa with &lt;span class=&#34;math inline&#34;&gt;\(n = 1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Imagine that you have a black box that implements a function from n-bit strings (e.g. 11010) to 0 or 1, that is &lt;span class=&#34;math inline&#34;&gt;\(f : \{0, 1 \}^{n} \rightarrow \{0, 1\}\)&lt;/span&gt;. It is guaranteed that &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is either a balanced or a constant function. You can make a query to the black box with a value &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;, and the black box will return &lt;span class=&#34;math inline&#34;&gt;\(f(v)\)&lt;/span&gt;. How many queries are needed to decide if the function is constant or balanced?&lt;/p&gt;
&lt;p&gt;Just remembering definitions, a function is balanced when the number of values that have &lt;span class=&#34;math inline&#34;&gt;\(f(v) = 0\)&lt;/span&gt; is equal to the number of values that have &lt;span class=&#34;math inline&#34;&gt;\(f(v) = 1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;This time, we have way more than 4 possible functions, more precisely &lt;span class=&#34;math inline&#34;&gt;\(2(\binom{2^{n}}{2^{n-1}} + 1)\)&lt;/span&gt;. Our classical strategy also needs more queries to classify the function. To deterministically determine the type of the function, we need &lt;span class=&#34;math inline&#34;&gt;\(O(2^{n})\)&lt;/span&gt; queries because the worst case is when we obtain &lt;span class=&#34;math inline&#34;&gt;\(2^{n-1}\)&lt;/span&gt; of 0s (or 1, it is symmetric) and still need an additional query to distinguish between balanced or constant.&lt;/p&gt;
&lt;p&gt;From a perspective using classical computers, that is (deterministically) the best we can do. A question that arises is: can quantum computers do better? It can be shown that yes, they can. And the speedup is impressive.&lt;/p&gt;
&lt;h2 id=&#34;generalazing-the-solution-for-multiple-bits&#34;&gt;Generalazing the solution for multiple bits&lt;/h2&gt;
&lt;p&gt;We now need to try to generalize our solution from &lt;span class=&#34;math inline&#34;&gt;\(n = 1\)&lt;/span&gt; to larger values of &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;. It is worth trying the same solution but now using multiple bits, i.e. to apply a Hadamard to every qubit to generate all possible values, evaluate using the black box, and lastly apply Hadamard gates before measuring. The circuit we obtain looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum5/Q5C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We now need to decide if the circuit provides criteria similar to the previous solution to differentiate between. It is helpful to expand the math to analyze that. After applying the Hadamard gates we have:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = |00...0\rangle|0\rangle \rightarrow H^{\otimes N}|\psi\rangle \otimes (\frac{|0\rangle - |1\rangle}{\sqrt 2})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\rightarrow \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}} |x\rangle \otimes (\frac{|0\rangle - |1\rangle}{\sqrt 2})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We then send the input to the blackbox, that yields:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\rightarrow \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}} |x\rangle \otimes (\frac{|0 \oplus f(x)\rangle - |1 \oplus f(x)\rangle}{\sqrt 2})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\rightarrow \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}} (-1)^{f(x)}|x\rangle \otimes (\frac{|0\rangle - |1\rangle}{\sqrt 2})
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Like in the last analysis, we used the identity &lt;span class=&#34;math inline&#34;&gt;\(|0 \oplus a \rangle - |1 \oplus a \rangle = (-1)^{a}(|0\rangle - |1\rangle)\)&lt;/span&gt;. We also obtained a similar result: the last qubit does not change, so measuring it is useless and we will not worry about it afterwards.&lt;/p&gt;
&lt;p&gt;Given that now we have a mathematical expression representing the state of the qubits, we can analyse the two possible cases before measuring.&lt;/p&gt;
&lt;h1 id=&#34;constant-case&#34;&gt;Constant case&lt;/h1&gt;
&lt;p&gt;If &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is constant, then all the &lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt; in the sum before will have the same sign, which can be summarized as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \pm \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}} |x\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice that multiplying the whole expression by -1 does not affect the measurements because it is a global phase change. The state that happens on the balanced case after applying the black box is then:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = (\frac{|0\rangle + |1\rangle}{\sqrt 2})^{\otimes n}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice that when we apply the Hadamard gates before measuring, each &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle + |1\rangle}{\sqrt 2}\)&lt;/span&gt; becomes &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; and therefore the final state is &lt;span class=&#34;math inline&#34;&gt;\(|00...0\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Hence, we are sure that if &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is constant then all measurements will always be 0.&lt;/p&gt;
&lt;h2 id=&#34;balanced-case&#34;&gt;Balanced case&lt;/h2&gt;
&lt;p&gt;We now need to analyse the other case, when there is no guarantee that all &lt;span class=&#34;math inline&#34;&gt;\(|x\rangle\)&lt;/span&gt; will have the same sign. Indeed, we do not know anything about &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; (just that the number of 0s and 1s is the same) so it is difficult to know the exact probability of an arbitrary state &lt;span class=&#34;math inline&#34;&gt;\(|x\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;One thing we know though is that &lt;span class=&#34;math inline&#34;&gt;\(|00...0\rangle\)&lt;/span&gt; is always the output of the other case, i.e. the constant case. We may then ask: what is the probability that this case, the balanced case, will output &lt;span class=&#34;math inline&#34;&gt;\(|00...0\rangle\)&lt;/span&gt;?&lt;/p&gt;
&lt;p&gt;To analyze that we need to calculate the coefficient &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; of &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle = \alpha|00...0\rangle + ...\)&lt;/span&gt; after applying all the Hadamard gates, which can be seen as multiplying by &lt;span class=&#34;math inline&#34;&gt;\(H^{\otimes n}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;One key property of &lt;span class=&#34;math inline&#34;&gt;\(H^{\otimes n}\)&lt;/span&gt; is that the first line, the line that will give the &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; of the final &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt;, has constant terms i.e. they are equal. More exactly, all terms of the first line of &lt;span class=&#34;math inline&#34;&gt;\(H^{\otimes n}\)&lt;/span&gt; are &lt;span class=&#34;math inline&#34;&gt;\((\sqrt 2) ^ {-n}\)&lt;/span&gt;. This fact can be shown by induction and I will just use it, not prove it.&lt;/p&gt;
&lt;p&gt;Given that all terms of the first line are &lt;span class=&#34;math inline&#34;&gt;\((\sqrt 2) ^ {-n}\)&lt;/span&gt;, the &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; we obtain is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\alpha = \frac{1}{\sqrt 2 ^ {n}} \frac{1}{\sqrt 2 ^ {n}} \sum_{x \in \{0, 1\}^{n}} (-1)^{f(x)}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Now the fact that the function is balanced becomes crucial. Because the number of &lt;span class=&#34;math inline&#34;&gt;\(f(x) = 0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(f(x) = 1\)&lt;/span&gt; are equal, the sum above is zero! Hence, &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; is zero and therefore there is no &lt;span class=&#34;math inline&#34;&gt;\(|00...0\rangle\)&lt;/span&gt; component in the final state. Because of that, we are guaranteed that not all measurements will be 0, which means that at least one of the measurements will be 1.&lt;/p&gt;
&lt;p&gt;Thus, the circuit we used provides criteria to classify &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If all the measurements are 0, then &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is constant&lt;/li&gt;
&lt;li&gt;If at least one of the measurements is 1, then &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is balanced&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The problem has been solved! The most impressive fact is that only 1 query was used, instead of &lt;span class=&#34;math inline&#34;&gt;\(O(2^{n})\)&lt;/span&gt; queries. That is an exponential speedup.&lt;/p&gt;
&lt;h2 id=&#34;implementing-the-deutsch-jozsa-algorithm&#34;&gt;Implementing the Deutsch-Jozsa algorithm&lt;/h2&gt;
&lt;p&gt;We can verify that the Deutsch-Jozsa algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try three cases for the black box and verify that our algorithm predicts correctly that it is balanced or constant.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/e73a21c814f4288e188d4eec502c87e6.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;so-what&#34;&gt;So what?&lt;/h1&gt;
&lt;p&gt;You might ask: what is the point of the Deutsch-Jozsa algorithm? The algorithm solves a very artificial and useless problem. It has very little practical applications.&lt;/p&gt;
&lt;p&gt;The algorithm, in my personal opinion, exemplifies the beauty of quantum computing: it provides an exponential speedup! Not only the speedup is impressive, but it is also unachievable by classical computers. It is one of the first algorithms from a yet-to-be-explored field.&lt;/p&gt;
&lt;p&gt;It also exemplifies the less beautiful aspects of it. As of now, quantum computing… is useless. The Deutsch-Jozsa problem is a toy problem to show that two complexity classes for algorithms are different, and that is it. No applications. Not to mention that with Noisy Quantum Computers even running simple algorithms like Deutsch-Jozsa can have errors (qubits and gates are still not perfect).&lt;/p&gt;
&lt;p&gt;However, the algorithm still has historical importance and inspired other algorithms that have more practical applications, like Shor’s algorithm for factorizing numbers. Hence, it is still important to study the problem.&lt;/p&gt;
&lt;h1 id=&#34;a-randomized-approach&#34;&gt;A randomized approach&lt;/h1&gt;
&lt;p&gt;In the initial discussion, we highlighted the deterministic factor. As a side note, we can have a probabilistic algorithm that solves the problem most of the time with an error rate &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt;. If &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; queries are made to the black box, &lt;span class=&#34;math inline&#34;&gt;\(\epsilon = 2^{-(k - 1)}\)&lt;/span&gt;. Because the decrease in &lt;span class=&#34;math inline&#34;&gt;\(\epsilon\)&lt;/span&gt; is exponential, with a constant and small value of &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; we can classify with great confidence. Below is Python code implementing that idea (&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is the function, &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; is the number of bits and &lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt; is the number of tries before we stop).&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-1&#34; title=&#34;1&#34;&gt;&lt;span class=&#34;im&#34;&gt;from&lt;/span&gt; random &lt;span class=&#34;im&#34;&gt;import&lt;/span&gt; randint&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-2&#34; title=&#34;2&#34;&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-3&#34; title=&#34;3&#34;&gt;&lt;span class=&#34;kw&#34;&gt;def&lt;/span&gt; balanced_or_constant(f, n, k):&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-4&#34; title=&#34;4&#34;&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-5&#34; title=&#34;5&#34;&gt;    first_guess &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; f(randint(&lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;**&lt;/span&gt;n &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;))&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-6&#34; title=&#34;6&#34;&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-7&#34; title=&#34;7&#34;&gt;    &lt;span class=&#34;cf&#34;&gt;for&lt;/span&gt; i &lt;span class=&#34;kw&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;bu&#34;&gt;range&lt;/span&gt;(k&lt;span class=&#34;dv&#34;&gt;-1&lt;/span&gt;):&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-8&#34; title=&#34;8&#34;&gt;        guess &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; f(randint(&lt;span class=&#34;dv&#34;&gt;0&lt;/span&gt;, &lt;span class=&#34;dv&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;op&#34;&gt;**&lt;/span&gt;n &lt;span class=&#34;op&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;dv&#34;&gt;1&lt;/span&gt;))&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-9&#34; title=&#34;9&#34;&gt;        &lt;span class=&#34;cf&#34;&gt;if&lt;/span&gt; guess &lt;span class=&#34;op&#34;&gt;!=&lt;/span&gt; first_guess:&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-10&#34; title=&#34;10&#34;&gt;            &lt;span class=&#34;cf&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;balanced&amp;quot;&lt;/span&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-11&#34; title=&#34;11&#34;&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-12&#34; title=&#34;12&#34;&gt;    &lt;span class=&#34;cf&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;st&#34;&gt;&amp;quot;constant&amp;quot;&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Quantum #4 - Deutsch-Jozsa (part 1)</title>
      <link>https://ivaniscoding.github.io/posts/quantum4/</link>
      <pubDate>Thu, 26 Dec 2019 18:00:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/quantum4/</guid>
      <description>&lt;p&gt;This is the fourth post of a series of posts about Quantum Computing with &lt;a href=&#34;https://qiskit.org/&#34;&gt;Qiskit&lt;/a&gt;. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.&lt;/p&gt;
&lt;p&gt;The goal of this post is to discuss the Deutsch-Jozsa algorithm, which was one of the very first quantum algorithms. Even though it solves a very artificial problem, its main purpose is to answer: is there an advantage in using quantum computers? The answer is yes.&lt;/p&gt;
&lt;h2 id=&#34;deutsch-problem&#34;&gt;Deutsch problem&lt;/h2&gt;
&lt;p&gt;Before diving into the Deutsch-Jozsa algorithm, let’s discuss the Deutsch problem which is a special case solved by the algorithm. It is a problem that can be summarized as:&lt;/p&gt;
&lt;p&gt;Imagine that you have a black box that implements a function &lt;span class=&#34;math inline&#34;&gt;\(f : \{0, 1 \} \rightarrow \{0, 1\}\)&lt;/span&gt;. You can make a query to the black box with a value &lt;span class=&#34;math inline&#34;&gt;\(v\)&lt;/span&gt;, and the black box will return &lt;span class=&#34;math inline&#34;&gt;\(f(v)\)&lt;/span&gt;. How many queries are needed to decide if the function is constant or balanced? A balanced function is when the number of values that have &lt;span class=&#34;math inline&#34;&gt;\(f(v) = 0\)&lt;/span&gt; is equal to the number of values that have &lt;span class=&#34;math inline&#34;&gt;\(f(v) = 1\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;There are four possible &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; functions, all listed below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Function&lt;/th&gt;
&lt;th&gt;Values&lt;/th&gt;
&lt;th&gt;Classification&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{0}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f(0) = 0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(f(1) = 0\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Constant&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{1}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f(0) = 0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(f(1) = 1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Balanced&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{2}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f(0) = 1\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(f(1) = 0\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Balanced&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f_{3}\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(f(0) = 1\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(f(1) = 1\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;Constant&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;It turns out that to classify the function implemented by the black box, we need to use two queries. When we do one query, we go from four possible functions to two functions, one which will be balanced and the other constant. Thus, we need an additional query to decide which one it is, totaling two queries.&lt;/p&gt;
&lt;p&gt;From a perspective using classical computers, that is the best we can do. A question that arises is: can quantum computers do better? It can be shown yes, they can.&lt;/p&gt;
&lt;h2 id=&#34;quantum-black-box&#34;&gt;Quantum black box&lt;/h2&gt;
&lt;p&gt;Before we continue, it is important to discuss what a quantum black box is. It acts similarly to the classical black box we had before: it takes qubits and spits the result. Because the black box implements a function that might not have a unitary matrix and quantum circuits are composed only of unitary matrices, we need to use a working qubit to store the result of the black box.&lt;/p&gt;
&lt;p&gt;Thus, we define the black box as a transformation &lt;span class=&#34;math inline&#34;&gt;\(|v\rangle|0\rangle \rightarrow |v\rangle|f(v)\rangle\)&lt;/span&gt;, or even more detailed &lt;span class=&#34;math inline&#34;&gt;\(|v\rangle|w\rangle \rightarrow |v\rangle|w \oplus f(v)\rangle\)&lt;/span&gt; to handle the case with 1 (&lt;span class=&#34;math inline&#34;&gt;\(\oplus\)&lt;/span&gt; is the XOR operator).&lt;/p&gt;
&lt;p&gt;An interesting aspect of the quantum black box is that it allows us to achieve something that would be impossible with a classical computer: ask &lt;span class=&#34;math inline&#34;&gt;\(f(0)\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(f(1)\)&lt;/span&gt; at the same time! How? Well, consider a state with a superposition such as &lt;span class=&#34;math inline&#34;&gt;\(\frac{(|0\rangle + |1\rangle)}{\sqrt 2}\)&lt;/span&gt;. If we give that qubit to the black box, a part of our working qubit will have &lt;span class=&#34;math inline&#34;&gt;\(f(0)\)&lt;/span&gt; and the other will have &lt;span class=&#34;math inline&#34;&gt;\(f(1)\)&lt;/span&gt;. Maybe then, we can find a clever way to recover both at the same time and classify the function with only one query!&lt;/p&gt;
&lt;p&gt;One concern that might come now: is it even fair to compare a quantum black box to a classical black box? The answer is: it is reasonable. Even with a quantum black box, classical computers still need 2 queries because they cannot exploit superpositions, hence it is reasonable to compare.&lt;/p&gt;
&lt;h1 id=&#34;exploiting-superposition&#34;&gt;Exploiting superposition&lt;/h1&gt;
&lt;p&gt;Now that we know that we need to use superposition in our solution, it is tempting to use a circuit like the following:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum4/Q4C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In this circuit, we generate a superposition, then apply the black box and after we measure our result. It is a very simple circuit and the core ideas of the real solution are on it. Even though it seems promising, it fails. It cannot differentiate balanced functions.&lt;/p&gt;
&lt;p&gt;To understand why, consider the case for constant. If the value is always 0, our measure for the qubit will also be always zero. If it is 1, similarly, it will always be one. But for balanced, we have 50% for each case so in practice we cannot differentiate constant and balanced functions.&lt;/p&gt;
&lt;p&gt;We could try to measure the balanced case by, let’s say, applying a Hadamard gate :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum4/Q4C1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This solves the problem for balanced functions: now, due to the Hadamard gate, they will always output the same measurement 100% of the time. But our constant functions will now measure 50% of the times 0 and 50% of the times 1, so we still have the same problem as before. We need a more elaborate solution.&lt;/p&gt;
&lt;h2 id=&#34;deutsch-algorithm&#34;&gt;Deutsch algorithm&lt;/h2&gt;
&lt;p&gt;We will now analyze the circuit that the following circuit solves the problem:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum4/Q4C2.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;To understand why, we can expand the algebra of the circuit. We have the following state after applying the &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; and Hadamard gates:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \frac{|0\rangle + |1\rangle}{\sqrt 2} \otimes \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;After applying the black box, we obtain:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\rightarrow \frac{|0\rangle (|0 \oplus f(0)\rangle - |1 \oplus f(0)\rangle)}{2} + \frac{|1\rangle (|0 \oplus f(1)\rangle - |1 \oplus f(1)\rangle)}{2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We are then going to use the following identity to help rewrite our expression in a convenient way:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|0 \oplus a \rangle - |1 \oplus a \rangle = (-1)^{a}(|0\rangle - |1\rangle)
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We can verify that the expression is valid when &lt;span class=&#34;math inline&#34;&gt;\(a\)&lt;/span&gt; is 0 or 1. Therefore, we get:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\rightarrow \frac{(-1)^{f(0)}|0\rangle (|0\rangle - |1\rangle)}{2} + \frac{(-1)^{f(1)}|1\rangle (|0\rangle - |1\rangle)}{2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\rightarrow \frac{(-1)^{f(0)}|0\rangle + (-1)^{f(1)}|1\rangle}{\sqrt 2} \otimes \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This form is convenient because it tells us two things. The first is that the second qubit does not change, so measuring it is useless. The second is that the first qubit depends on the classification of the function:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is constant, the qubit will be &lt;span class=&#34;math inline&#34;&gt;\((\pm 1)\frac{|0\rangle + |1\rangle}{\sqrt 2}\)&lt;/span&gt;. Because having a minus sign does not matter (it is a global phase change), we can say that the qubit will always be &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle + |1\rangle}{\sqrt 2}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;If &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt; is balanced, the qubit will be &lt;span class=&#34;math inline&#34;&gt;\((\pm 1)\frac{|0\rangle - |1\rangle}{\sqrt 2}\)&lt;/span&gt;. Because having a minus sign does not matter (it is a global phase change), we can say that the qubit will always be &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To differentiate between &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle + |1\rangle}{\sqrt 2}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)&lt;/span&gt;, we need to apply a Hadamard gate. The first case will become a &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; and the second case will become &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt;, so using the circuit we presented before we can decide using the rule:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the measurement of the first qubit is &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;, we have a constant function&lt;/li&gt;
&lt;li&gt;Otherwise, if the measurement of the qubit is &lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;, we have a balanced function&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The problem has been solved! With just one query, an achievement that would be impossible with classical computers.&lt;/p&gt;
&lt;h2 id=&#34;implementing-the-deutsch-algorithm&#34;&gt;Implementing the Deutsch algorithm&lt;/h2&gt;
&lt;p&gt;We can verify that the Deutsch algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try the four possible cases for the black box and verify that our algorithm predicts correctly that it is balanced or constant.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/8fa8bbaa6c9d3dad16b3bf60e69d5087.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;next-step&#34;&gt;Next step&lt;/h1&gt;
&lt;p&gt;The next step is to generalize the problem from 1-bit functions to n-bit functions, and that is what will happen in the second part of the blog post about the Deutsch-Jozsa algorithm.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Quantum #3 - Superdense Coding</title>
      <link>https://ivaniscoding.github.io/posts/quantum3/</link>
      <pubDate>Mon, 23 Dec 2019 22:00:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/quantum3/</guid>
      <description>&lt;p&gt;This is the third post of a series of posts about Quantum Computing with &lt;a href=&#34;https://qiskit.org/&#34;&gt;Qiskit&lt;/a&gt;. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.&lt;/p&gt;
&lt;p&gt;The goal of this post is to discuss superdense coding, which can be seen as the opposite of &lt;a href=&#34;https://ivaniscoding.github.io/posts/quantum2/&#34;&gt;quantum teleportation&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;sending-bits-with-qubits&#34;&gt;Sending bits with qubits&lt;/h2&gt;
&lt;p&gt;Imagine that Alice wants to send two classical bits &lt;span class=&#34;math inline&#34;&gt;\(b_{0}b_{1}\)&lt;/span&gt; to Bob. Alice could do that in more standard ways, but instead, Alice chooses to send a qubit to Bob. Is there a way we can guarantee that Bob will &lt;em&gt;always&lt;/em&gt; decode &lt;span class=&#34;math inline&#34;&gt;\(b_{0}b_{1}\)&lt;/span&gt;? The answer is yes, and to communicate in such a non-standard way, Alice and Bob just need to follow an algorithm that is called Superdense Coding:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Entangle Alice’s and Bob’s qubit&lt;/li&gt;
&lt;li&gt;Encode the bits Alice wants to send using quantum gates, and then send the qubit to Bob&lt;/li&gt;
&lt;li&gt;Apply the same gates from the entanglement procedure, but in inverted order&lt;/li&gt;
&lt;li&gt;Measure the two qubits&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Notice that superdense coding can be seen as the opposite of teleportation. In teleportation, we share an entangled state and send two classical bits to recover a qubit. Superdense coding, on the other hand, uses an entangled state and sends a qubit to recover two classical bits. Thus, the processes are complementary.&lt;/p&gt;
&lt;h2 id=&#34;preparing-the-bell-state&#34;&gt;Preparing the Bell state&lt;/h2&gt;
&lt;p&gt;The first step of the algorithm is to prepare the entangled state &lt;span class=&#34;math inline&#34;&gt;\(\vert\Phi^{+}\rangle\)&lt;/span&gt;, one of the Bell states. We discussed that on the &lt;a href=&#34;https://ivaniscoding.github.io/posts/quantum2/&#34;&gt;quantum teleportation&lt;/a&gt;, so if you want a detailed explanation I encourage you to check it out there. What we need to remember is that we work with the state:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\vert\Phi^{+}\rangle = \frac{\vert 00 \rangle + \vert 11 \rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;That is generated by the circuit:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum2/Q2C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;After generating &lt;span class=&#34;math inline&#34;&gt;\(\vert\Phi^{+}\rangle\)&lt;/span&gt;, we send one of the qubits to Alice and the other one to Bob.&lt;/p&gt;
&lt;h2 id=&#34;encoding-classical-information-on-a-qubit&#34;&gt;Encoding classical information on a qubit&lt;/h2&gt;
&lt;p&gt;Now that Alice has one of the qubits of &lt;span class=&#34;math inline&#34;&gt;\(\vert\Phi^{+}\rangle\)&lt;/span&gt;, she can try to encode &lt;span class=&#34;math inline&#34;&gt;\(b_{0}b_{1}\)&lt;/span&gt; into the qubit by applying quantum gates.&lt;/p&gt;
&lt;p&gt;To do so, she needs to find a clever way of applying a gate that after applying the inverted entanglement again, will give Bob the bits we were trying to send, i.e. the measurement of the first qubit will always be &lt;span class=&#34;math inline&#34;&gt;\(b_{0}\)&lt;/span&gt; and the second will always be &lt;span class=&#34;math inline&#34;&gt;\(b_{1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To make it clearer, let’s take for example the &lt;span class=&#34;math inline&#34;&gt;\(|00\rangle\)&lt;/span&gt; case. We need to find a gate &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt; such that:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
(H \otimes I)(CNOT)(G \otimes I)\vert\Phi^{+}\rangle = |00\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We can then write the &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt; matrix in the function of 4 unknown variables and recall that &lt;span class=&#34;math inline&#34;&gt;\(G G^{\dagger} = I\)&lt;/span&gt; to solve for &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt;. It turns out that for &lt;span class=&#34;math inline&#34;&gt;\(|00\rangle\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(G = I\)&lt;/span&gt;. That makes sense because applying the inverted entanglement circuit on the &lt;span class=&#34;math inline&#34;&gt;\(\vert\Phi^{+}\rangle\)&lt;/span&gt; untangles it.&lt;/p&gt;
&lt;p&gt;We would need to do the same for &lt;span class=&#34;math inline&#34;&gt;\(|01\rangle\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(|10\rangle\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(|11\rangle\)&lt;/span&gt;. The table below summarizes the results we would get:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;&lt;span class=&#34;math inline&#34;&gt;\(b_{0}b_{1}\)&lt;/span&gt;&lt;/th&gt;
&lt;th&gt;Gate to apply&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(00\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; (no gates)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(01\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(10\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(11\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; and then &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;One curious connection to notice between quantum teleportation and superdense coding is that the table to apply the gates based on the bits is identical for both algorithms.&lt;/p&gt;
&lt;h2 id=&#34;decoding-classical-information-from-a-qubit&#34;&gt;Decoding classical information from a qubit&lt;/h2&gt;
&lt;p&gt;After Alice is done encoding, she sends her qubit to Bob. Bob applies then the same gates we used to generate&lt;span class=&#34;math inline&#34;&gt;\(\vert\Phi^{+}\rangle\)&lt;/span&gt; but in inverted order. That is, we apply the CNOT gate and then Hadamard gate on the first qubit as in the circuit below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum3/Q3C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Then, Bob measures the qubits. Because of the way we designed the gates in the last section, we are sure that the measurement of the first qubit will be &lt;span class=&#34;math inline&#34;&gt;\(b_{0}\)&lt;/span&gt; and the second will be &lt;span class=&#34;math inline&#34;&gt;\(b_{1}\)&lt;/span&gt;. Hence, Bob has successfully received two bits of classical information! With just 1 qubit.&lt;/p&gt;
&lt;h2 id=&#34;verifying-superdense-coding-computationally&#34;&gt;Verifying superdense coding computationally&lt;/h2&gt;
&lt;p&gt;We can verify that superdense coding works using Qiskit and running an experiment: in the Jupyter notebook below, we try the 4 different cases of bits that we can send.&lt;/p&gt;
&lt;p&gt;Every step explained above is done, and the results match our prediction.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/9254c3b34f837e0b233e148939da833a.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Quantum #2 - Teleportation</title>
      <link>https://ivaniscoding.github.io/posts/quantum2/</link>
      <pubDate>Sun, 22 Dec 2019 22:00:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/quantum2/</guid>
      <description>&lt;p&gt;This is the second post of a series of posts about Quantum Computing with &lt;a href=&#34;https://qiskit.org/&#34;&gt;Qiskit&lt;/a&gt;. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.&lt;/p&gt;
&lt;p&gt;The goal of this post is to discuss quantum teleportation, one of the most basic protocols for communication in quantum computing.&lt;/p&gt;
&lt;h2 id=&#34;teleportation-and-the-problem-it-solves&#34;&gt;Teleportation and the problem it solves&lt;/h2&gt;
&lt;p&gt;Imagine that Alice has a qubit &lt;span class=&#34;math inline&#34;&gt;\(| \psi \rangle = \alpha | 0 \rangle + \beta | 1 \rangle\)&lt;/span&gt;, where both &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; are unknown. Alice needs to send the qubit to Bob that is located somewhere far away. How does Alice do that?&lt;/p&gt;
&lt;p&gt;One simple answer could be to measure &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; and send the information. However, that does not work because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We may need an infinite amount of bits to represent &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; (e.g. think about encoding &lt;span class=&#34;math inline&#34;&gt;\(\pi\)&lt;/span&gt; in binary, it has an infinite length)&lt;/li&gt;
&lt;li&gt;Every time we measure a qubit, it becomes either &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt; and all its information is lost.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Having ruled out measurement, we may ask: is it even possible to send &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt;? The answer is, surprisingly, yes. To do so, we need two extra qubits, one for Alice and one for Bob, and to follow a simple algorithm:&lt;/p&gt;
&lt;ol type=&#34;1&#34;&gt;
&lt;li&gt;Entangle Alice’s and Bob’s qubit&lt;/li&gt;
&lt;li&gt;Apply a CNOT gate with &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; as the control qubit and Alice’s qubit as the target&lt;/li&gt;
&lt;li&gt;Apply a Hadamard gate to &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; and measure it, and measure Alice’s qubit&lt;/li&gt;
&lt;li&gt;Send the measurements to Bob through a &lt;em&gt;classical&lt;/em&gt; communication channel&lt;/li&gt;
&lt;li&gt;Apply (or not) a &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; and/or &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt; gate based on the measurements&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It may look like a lot to process at once, but if broken down, teleportation can make sense.&lt;/p&gt;
&lt;h2 id=&#34;preparing-the-bell-state&#34;&gt;Preparing the Bell state&lt;/h2&gt;
&lt;p&gt;The first step of the algorithm is to prepare the entangled state &lt;span class=&#34;math inline&#34;&gt;\(\vert\Phi^{+}\rangle\)&lt;/span&gt;, one of the Bell states. The Bell states are the most entangled and commonly appear in many quantum algorithms. Out of the for Bell states, the one we are looking is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\vert\Phi^{+}\rangle = \frac{\vert 00 \rangle + \vert 11 \rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To do so, we start with the two-qubit state &lt;span class=&#34;math inline&#34;&gt;\(\vert 00 \rangle\)&lt;/span&gt;, and use a Hadamard gate on the first qubit.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\vert 00 \rangle \rightarrow (\frac{\vert 0 \rangle + \vert 1 \rangle}{\sqrt 2}) \otimes \vert 0 \rangle = \frac{\vert 00 \rangle + \vert 10 \rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice that the state we are right now is very close to our goal. We just need to have &lt;span class=&#34;math inline&#34;&gt;\(|11\rangle\)&lt;/span&gt; instead of &lt;span class=&#34;math inline&#34;&gt;\(|10\rangle\)&lt;/span&gt;, so we use a CNOT with the first qubit as control and second as the target. Nothing happens to &lt;span class=&#34;math inline&#34;&gt;\(|00\rangle\)&lt;/span&gt; because the control qubit is $|0$, but &lt;span class=&#34;math inline&#34;&gt;\(|10\rangle\)&lt;/span&gt; becomes &lt;span class=&#34;math inline&#34;&gt;\(|11\rangle\)&lt;/span&gt; because the control qubit is &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt;. Overall:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\vert 00 \rangle \rightarrow \frac{\vert 00 \rangle + \vert 10 \rangle}{\sqrt 2} \rightarrow \frac{\vert 00 \rangle + \vert 11 \rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The circuit that performs this step looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum2/Q2C0.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;You may ask: how do we perform the entanglement if the qubits are far apart? That is indeed a good question. The first answer to this question would be to entangle the qubits when they are together with Alice and then split them apart, sending one to Bob. In my opinion, this answer violates the essence of teleportation: we do not want to send qubits to Bob.&lt;/p&gt;
&lt;p&gt;The second answer is: assume we can do it at long distances. We have not been discussing the plausibility to have a qubit or apply the gates, so we will leave for physicists to figure out how to physically achieve the entanglement.&lt;/p&gt;
&lt;h2 id=&#34;teleportation-procedure&#34;&gt;Teleportation procedure&lt;/h2&gt;
&lt;p&gt;Now that we know how to generate &lt;span class=&#34;math inline&#34;&gt;\(|\Phi^{+}\rangle\)&lt;/span&gt;, we have everything we need to do quantum teleportation. Considering our three-qubit system, we start with &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle \otimes |\Phi^{+}\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Firstly, we apply a CNOT gate with &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; as the control, and Alice’s entangled qubit as the target. That yields:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\frac{\alpha|000\rangle + \alpha|011\rangle + \beta|100\rangle + \beta|111\rangle}{\sqrt 2} \rightarrow \frac{\alpha|000\rangle + \alpha|011\rangle + \beta|110\rangle + \beta|101\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Secondly, we apply the Hadamard gate to the first qubit and we obtain:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\rightarrow \frac{|00\rangle (\alpha|0 \rangle+\beta|1\rangle) + |01\rangle (\alpha|1 \rangle+\beta|0\rangle) + |10\rangle (\alpha|0 \rangle-\beta|1\rangle) + |11\rangle (\alpha|1 \rangle-\beta|0\rangle)}{2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Thirdly, we measure the first two qubits, i.e. those that are with Alice, and send the result to Bob. Notice that depending on the outcome, we know exactly the state of third qubit. For example, we know that if the outcome of the measurement is &lt;span class=&#34;math inline&#34;&gt;\(10\)&lt;/span&gt;, then the last qubit is &lt;span class=&#34;math inline&#34;&gt;\(\alpha|0 \rangle-\beta|1\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Lastly, we need to go from the qubit that we know now to &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt;. Fortunately, that is simple. To achieve that, we need to apply the gates &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt; conditionally. The table below summarizes when we need to apply the gates:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr class=&#34;header&#34;&gt;
&lt;th&gt;Outcome&lt;/th&gt;
&lt;th&gt;Gate to apply&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(00\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(I\)&lt;/span&gt; (no gates)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(01\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(10\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(11\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; and then &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Even though the math might have looked complicated, the final circuit is simple. The last part of applying gates conditionally can be done by applying a Controlled X gate (which is another name for CNOT), and also applying a Controlled Z gate. Hence, the circuit that performs all 4 steps is:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum2/Q2C1.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;verifying-computationally-that-the-procedure-works&#34;&gt;Verifying computationally that the procedure works&lt;/h2&gt;
&lt;p&gt;We can verify that quantum teleportation works using Qiskit and running an experiment: in the Jupyter notebook bellow, we try to teleport &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle = \frac{\sqrt 3}{2}|0\rangle + \frac{1}{2}|1\rangle\)&lt;/span&gt; and analyse the results.&lt;/p&gt;
&lt;p&gt;Every step explained above is done, and the results match our prediction.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/988251a65389706b0e067a0a0c42a579.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Quantum #1 - Basic Quantum Computing</title>
      <link>https://ivaniscoding.github.io/posts/quantum1/</link>
      <pubDate>Wed, 11 Dec 2019 20:00:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/quantum1/</guid>
      <description>&lt;p&gt;This is the first post of a series of posts about Quantum Computing with &lt;a href=&#34;https://qiskit.org/&#34;&gt;Qiskit&lt;/a&gt;. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.&lt;/p&gt;
&lt;p&gt;The goal of this post is to introduce a more hands-on approach to quantum computing using Qiskit. For a friendly introduction to quantum computing in general, I recommend the essay &lt;a href=&#34;https://quantum.country/qcvc&#34;&gt;Quantum computing for the very curious&lt;/a&gt; by Matuschak and Nielsen.&lt;/p&gt;
&lt;h2 id=&#34;the-qubit&#34;&gt;The qubit&lt;/h2&gt;
&lt;p&gt;Quantum computers are made of qubits like classical computers are made of bits. However, qubits vectors and thus they have components. There are two very important qubits &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt; that relate to their classical 0 and 1 counterparts. In vector notation, they are:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|0\rangle = \begin{bmatrix}1 \\ 0\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|1\rangle = \begin{bmatrix}0 \\ 1\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In general, every qubit &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; has a &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; component and a &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt; component, that is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \alpha|0\rangle + \beta|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We can also write that superposition (or linear combination) in the matrix form.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \begin{bmatrix}\alpha \\ \beta\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It is important to remember that &lt;span class=&#34;math inline&#34;&gt;\(\alpha\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt; may be complex numbers! Thus, the imaginary number &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; may appear in the components. For example, following qubit is valid:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \begin{bmatrix}\frac{1 + i}{\sqrt 2} \\ 0\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Lastly, one key factor for qubits is that they are unitary vectors that is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|| |\psi\rangle || = 1
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Thus, we may visualize a qubit as a 3d vector in a sphere of radius 1:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/BlocSphere.png&#34; /&gt;&lt;/p&gt;
&lt;h2 id=&#34;quantum-gates-quantum-circuits&#34;&gt;Quantum gates &amp;amp; Quantum Circuits&lt;/h2&gt;
&lt;p&gt;A quantum circuit is a collection of qubits and classical bits. The building blocks of quantum circuits are quantum gates: they modify qubits and allow quantum computing to achieve arbitrary qubit states as we discussed before.&lt;/p&gt;
&lt;p&gt;In Qiskit, a quantum circuit can be initialized by:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb1&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-1&#34; title=&#34;1&#34;&gt;&lt;span class=&#34;im&#34;&gt;from&lt;/span&gt; qiskit &lt;span class=&#34;im&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;op&#34;&gt;*&lt;/span&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb1-2&#34; title=&#34;2&#34;&gt;circuit &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; QuantumCircuit(n_qubits, n_classical_bits)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In general, a gate &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; can be added to a circuit by:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb2&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb2-1&#34; title=&#34;1&#34;&gt;circuit.u(target_qubit)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A fact to notice is that there is an infinite number of qubit gates! A gate is any device that takes a qubit &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; and outputs another valid qubit &lt;span class=&#34;math inline&#34;&gt;\(|\phi\rangle\)&lt;/span&gt;. In general, we have that a gate &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; can be represented by a matrix:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
U = \begin{bmatrix} a &amp;amp; b \\ c &amp;amp; d\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;By applying the gate &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; to a qubit &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)&lt;/span&gt;, we obtain:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\phi\rangle = U|\psi\rangle = (a\cdot\alpha + b\cdot\beta)|0\rangle + (c\cdot\alpha + d\cdot\beta)|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice that &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; must preserve the length of &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt; in order for &lt;span class=&#34;math inline&#34;&gt;\(|\phi\rangle\)&lt;/span&gt; to be a valid qubit! Thus &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt; is a special type of matrix called a unitary matrix. Mathematically:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
UU^{\dagger} = I
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Where &lt;span class=&#34;math inline&#34;&gt;\(U^{\dagger}\)&lt;/span&gt; is the &lt;a href=&#34;https://en.wikipedia.org/wiki/Conjugate_transpose&#34;&gt;conjugate transpose&lt;/a&gt;. It is important to see that &lt;span class=&#34;math inline&#34;&gt;\(U^{\dagger}\)&lt;/span&gt; can undo the transformation from &lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt;: it takes &lt;span class=&#34;math inline&#34;&gt;\(|\phi\rangle\)&lt;/span&gt; to &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Because of the matrix multiplication property of the gates, applying multiple quantum gates such as &lt;span class=&#34;math inline&#34;&gt;\(U_{a}\)&lt;/span&gt; and then &lt;span class=&#34;math inline&#34;&gt;\(U_{b}\)&lt;/span&gt; is equivalent to applying a gate &lt;span class=&#34;math inline&#34;&gt;\(G\)&lt;/span&gt; such that:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
G = U_{a}U_{b}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It is important to notice that gate composition also implies gate decomposition. The quantum gate you are applying might be a synthesis of other easier to implement gates in real life such that &lt;span class=&#34;math inline&#34;&gt;\(G = U_{a}U_{b}U_{c}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Even though there is an infinite amount of gates, some are very famous because they are more used than others and have a special place in quantum computing and Qiskit. They are:&lt;/p&gt;
&lt;h3 id=&#34;the-pauli-x-gate&#34;&gt;The Pauli-X gate&lt;/h3&gt;
&lt;p&gt;The Pauli-X gate is the quantum equivalent of the NOT gate, that is it takes 0 to 1 and 1 to 0. Mathematically:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|0\rangle \overset{X}{\rightarrow} |1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|1\rangle \overset{X}{\rightarrow} |0\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\alpha|0\rangle + \beta|1\rangle \overset{X}{\rightarrow} \beta|0\rangle + \alpha|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To use the Pauli-X gate in Qiskit, it suffices to write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb3&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb3-1&#34; title=&#34;1&#34;&gt;circuit.x(target_qubit)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Graphically, the gate is represented as:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/XGate.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Because &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; is a gate, it can be written as a matrix as we discussed before:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
X = \begin{bmatrix} 0 &amp;amp; 1 \\ 1 &amp;amp; 0\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;An important property of &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; is that &lt;span class=&#34;math inline&#34;&gt;\(X = X^{\dagger}\)&lt;/span&gt;, thus &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; is the inverse gate of itself! That means that if we apply twice the Pauli-X Gate to a qubit, we will still have the same qubit.&lt;/p&gt;
&lt;h3 id=&#34;the-pauli-z-gate&#34;&gt;The Pauli-Z gate&lt;/h3&gt;
&lt;p&gt;The Pauli-Z gate is a quantum gate that leaves the &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; component intact but flips the sign of the &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt; component. Mathematically:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|0\rangle \overset{Z}{\rightarrow} |0\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|1\rangle \overset{Z}{\rightarrow} -|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\alpha|0\rangle + \beta|1\rangle \overset{Z}{\rightarrow} \alpha|0\rangle - \beta|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To use the Pauli-Z gate in Qiskit, it suffices to write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb4&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb4-1&#34; title=&#34;1&#34;&gt;circuit.z(target_qubit)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Graphically, the gate is represented as:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/ZGate.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The matrix representation of &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt; is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Z = \begin{bmatrix} 1 &amp;amp; 0 \\ 0 &amp;amp; -1\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;An important property of &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt; is that &lt;span class=&#34;math inline&#34;&gt;\(Z = Z^{\dagger}\)&lt;/span&gt;, thus &lt;span class=&#34;math inline&#34;&gt;\(Z\)&lt;/span&gt; is the inverse gate of itself! That means that if we apply twice the Pauli-Z Gate to a qubit, we will still have the same qubit.&lt;/p&gt;
&lt;h3 id=&#34;the-pauli-y-gate&#34;&gt;The Pauli-Y gate&lt;/h3&gt;
&lt;p&gt;The Pauli-Y gate is a gate that has only pure imaginary entries. It is similar to the &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; gate but has its entries multiplied by &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; and the top term is &lt;span class=&#34;math inline&#34;&gt;\(-i\)&lt;/span&gt;. Mathematically, it acts as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|0\rangle \overset{Y}{\rightarrow} i|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|1\rangle \overset{Y}{\rightarrow} -i|0\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\alpha|0\rangle + \beta|1\rangle \overset{Y}{\rightarrow} -i\beta|0\rangle + i\alpha|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To use the Pauli-Y gate in Qiskit, it suffices to write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb5&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb5-1&#34; title=&#34;1&#34;&gt;circuit.y(target_qubit)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Graphically, the gate is represented as:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/YGate.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The matrix representation of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
Y = \begin{bmatrix} 0 &amp;amp; -i \\ i &amp;amp; 0\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;An important property of &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is that &lt;span class=&#34;math inline&#34;&gt;\(Y = Y^{\dagger}\)&lt;/span&gt;, thus &lt;span class=&#34;math inline&#34;&gt;\(Y\)&lt;/span&gt; is the inverse gate of itself! That means that if we apply twice the Pauli-Y Gate to a qubit, we will still have the same qubit.&lt;/p&gt;
&lt;h3 id=&#34;the-hadamard-gate&#34;&gt;The Hadamard gate&lt;/h3&gt;
&lt;p&gt;The Hadamard gate is a gate to generate superposition, and it is hard to find a classical equivalent of it: it is a quantum gate by nature. Given &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt;, it generates a mix of &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt;, and does the same for &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt;. Mathematically:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|0\rangle \overset{H}{\rightarrow} \frac{|0\rangle + |1\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|1\rangle \overset{H}{\rightarrow} \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\alpha|0\rangle + \beta|1\rangle \overset{H}{\rightarrow} \frac{(\alpha + \beta)}{\sqrt 2}|0\rangle + \frac{(\alpha - \beta)}{\sqrt 2}|1\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Notice that &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle + |1\rangle}{\sqrt 2}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)&lt;/span&gt; are so important because they can be seen as an alternative basis, that they deserve their own symbols:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|+\rangle= \frac{|0\rangle + |1\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|-\rangle= \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To use the Hadamard gate in Qiskit, it suffices to write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb6&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb6-1&#34; title=&#34;1&#34;&gt;circuit.h(target_qubit)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Graphically, the gate is represented as:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/HGate.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The matrix reprenstation of the Hadamard gate is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
H = \frac{1}{\sqrt 2}\begin{bmatrix} 1 &amp;amp; 1 \\ 1 &amp;amp; -1\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;An important property of &lt;span class=&#34;math inline&#34;&gt;\(H\)&lt;/span&gt; is that &lt;span class=&#34;math inline&#34;&gt;\(H = H^{\dagger}\)&lt;/span&gt;, thus &lt;span class=&#34;math inline&#34;&gt;\(H\)&lt;/span&gt; is the inverse gate of itself! That means that if we apply twice the Hadamard gate to a qubit, we will still have the same qubit.&lt;/p&gt;
&lt;h2 id=&#34;executing-a-circuit-in-qiskit&#34;&gt;Executing a circuit in Qiskit&lt;/h2&gt;
&lt;p&gt;In Qiskit, we need a backend to execute a quantum circuit. That backend might be either a real quantum computer or a simulator. The syntax to run a circuit is:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb7&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb7-1&#34; title=&#34;1&#34;&gt;job &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; execute(circuit, backend, shots&lt;span class=&#34;op&#34;&gt;=&lt;/span&gt;n_times_to_execute)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are three key simulators in Qiskit that you must be aware of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;qasm_simulator:&lt;/em&gt; simulates the circuit and performs measurements&lt;/li&gt;
&lt;li&gt;&lt;em&gt;unitary_simulator:&lt;/em&gt; simulates the circuit and outputs the unitary matrix that represents it&lt;/li&gt;
&lt;li&gt;&lt;em&gt;statevector_simulator:&lt;/em&gt; simulates the circuit and outputs the state of the qubit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The syntax to obtain the specific backend with the simulator we want is:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb8&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb8-1&#34; title=&#34;1&#34;&gt;simulator &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; Aer.get_backend(backend_name)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Notice that after running the circuit either in a simulator in a real device, we would want the results! The code snippet below describes how to obtain it:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb9&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb9-1&#34; title=&#34;1&#34;&gt;result &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; job.result()&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb9-2&#34; title=&#34;2&#34;&gt;result.get_unitary()  &lt;span class=&#34;co&#34;&gt;# if the backend is unitary_simulator&lt;/span&gt;&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb9-3&#34; title=&#34;3&#34;&gt;result.get_statevecor() &lt;span class=&#34;co&#34;&gt;# if the backend  is statevector_simulator&lt;/span&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Jupyter notebooks exemplifying the process are given below:&lt;/p&gt;
&lt;p&gt;&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/47754335e473c34203300387ba1e4ba5.js&#34;&gt;&lt;/script&gt;
 &lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/3aa86987a0bed84d09796bc19228bd73.js&#34;&gt;&lt;/script&gt;
&lt;/p&gt;
&lt;h2 id=&#34;measurements&#34;&gt;Measurements&lt;/h2&gt;
&lt;p&gt;Even though qubits are a superposition of &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt;, when a measurement is made, the output will be either 0 or 1. For a given qubit &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)&lt;/span&gt;, there is a &lt;span class=&#34;math inline&#34;&gt;\(|\alpha^{2}|\)&lt;/span&gt; probability that the measurement will be 0 and a &lt;span class=&#34;math inline&#34;&gt;\(|\beta^{2}|\)&lt;/span&gt; probability that the measurement will be 1.&lt;/p&gt;
&lt;p&gt;Because the sum of the probabilities of all events is equal to one, we may write:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\alpha^{2}| + |\beta^{2}| = 1
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;In Qiskit, a measurement can be made using the following syntax:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb10&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb10-1&#34; title=&#34;1&#34;&gt;circuit.measure(target_qubit, target_classical_bit)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After executing the job in a real quantum computer or in a simulator, the obtained measurements will be available in a dictionary where the key is the measurement and the value is the count of the measurements:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb11&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb11-1&#34; title=&#34;1&#34;&gt;result &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; job.result()&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb11-2&#34; title=&#34;2&#34;&gt;measurement_counts &lt;span class=&#34;op&#34;&gt;=&lt;/span&gt; result.get_counts()&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In general, it is also useful to visualize the measurements using a histogram. That can be done through:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb12&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb12-1&#34; title=&#34;1&#34;&gt;&lt;span class=&#34;im&#34;&gt;from&lt;/span&gt; qiskit.visualization &lt;span class=&#34;im&#34;&gt;import&lt;/span&gt; plot_histogram&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb12-2&#34; title=&#34;2&#34;&gt;plot_histogram(measurement_counts)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A Jupyter notebook exemplifying the measurement process is given below:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/8a86d679f371f7d87341f985f43d40f6.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;multiple-qubits&#34;&gt;Multiple qubits&lt;/h2&gt;
&lt;p&gt;So far we have discussed only systems with exactly one qubit! However, quantum circuits are generally composed of multiple qubits. For example, for a two-qubit system, there are four states: &lt;span class=&#34;math inline&#34;&gt;\(|00\rangle\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(|01\rangle\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(|10\rangle\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(|11\rangle\)&lt;/span&gt;. A 2-qubit system can be described then as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle = \alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;A system of n qubits will have &lt;span class=&#34;math inline&#34;&gt;\(2^{n}\)&lt;/span&gt; states, hence using the ket notation is more convenient than writing matrices with &lt;span class=&#34;math inline&#34;&gt;\(2^{n}\)&lt;/span&gt; entries.&lt;/p&gt;
&lt;p&gt;For multiple qubit system, it is also common to use the tensor product (&lt;span class=&#34;math inline&#34;&gt;\(\otimes\)&lt;/span&gt;) to describe the state. If &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)&lt;/span&gt; is a single qubit and &lt;span class=&#34;math inline&#34;&gt;\(|\phi\rangle\)&lt;/span&gt; is a qubit, then we define:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle \otimes |\phi\rangle = \begin{bmatrix}\alpha|\phi\rangle \\ \beta|\phi\rangle\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Sometimes also written &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle|\phi\rangle\)&lt;/span&gt;. Notice that &lt;span class=&#34;math inline&#34;&gt;\(|00\rangle = |0\rangle \otimes |0\rangle\)&lt;/span&gt;. The same apply for more qubits: &lt;span class=&#34;math inline&#34;&gt;\(|011\rangle = |0\rangle \otimes |1\rangle \otimes |1\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;To make it clearer, an example is useful. If &lt;span class=&#34;math inline&#34;&gt;\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(|\phi\rangle = \gamma|0\rangle + \delta|1\rangle\)&lt;/span&gt;, then:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\psi\rangle \otimes |\phi\rangle = \alpha\gamma|00\rangle + \alpha\delta|01\rangle + \beta\gamma|10\rangle + \beta\delta|11\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;One last remark is: not every state can be written as a tensor product of qubits! Those states are called entangled. An example of an entangled state is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|\Phi^{+}\rangle = \frac{|00\rangle + |11\rangle}{\sqrt 2}
\]&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&#34;multiple-qubit-gates&#34;&gt;Multiple-qubit gates&lt;/h2&gt;
&lt;p&gt;In the first gate section, we discussed gates that operated on a single qubit. In this section, we will discuss gates that operate on two or more qubits. They are still unitary gates:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
UU^{\dagger} = I
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Their dimensions, however, are different. A gate that operates on n qubits has dimensions of &lt;span class=&#34;math inline&#34;&gt;\(2^{n} \times 2^{n}\)&lt;/span&gt;. It is also relevant to know how to write single-qubit gates for multiple qubit systems: they are written using the tensor product such as &lt;span class=&#34;math inline&#34;&gt;\(H \otimes Z\)&lt;/span&gt;: in this example, we apply the Hadamard gate to the first qubit and the Pauli-Z gate to the second qubit.&lt;/p&gt;
&lt;p&gt;Again, there is an infinite number of multiple qubit gates. Some that deserve special attention and have a special place in Qiskit are:&lt;/p&gt;
&lt;h3 id=&#34;controlled-not-gate&#34;&gt;Controlled NOT gate&lt;/h3&gt;
&lt;p&gt;The Controlled NOT gate applies the NOT gate (Pauli-X gate) to a target qubit based on a control qubit. If the control qubit is 1, then &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; is applied to the target. Otherwise, the target is not affected. Mathematically, considering the first qubit as control and the second one as a target:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|00\rangle \overset{CX}\rightarrow |00\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|01\rangle \overset{CX}\rightarrow |01\rangle 
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|10\rangle \overset{CX}\rightarrow |11\rangle 
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|11\rangle \overset{CX}\rightarrow |10\rangle 
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle \overset{CX}\rightarrow \alpha|00\rangle + \beta|01\rangle + \delta|10\rangle + \gamma|11\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To use the CNOT gate in Qiskit, it suffices to write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb13&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb13-1&#34; title=&#34;1&#34;&gt;circuit.cx(control, target)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Graphically, it looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/CXGate.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Because of the properties of the &lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt; gate, the CNOT gate is the inverse of itself. Hence, if we apply twice CNOT to the same two qubits, the target qubit will not change.&lt;/p&gt;
&lt;p&gt;In addition, it is worth mentioning that any gate can be made conditional using CNOT. Thus, there also exists the Controlled Z and Controlled Y gates. In Qiskit, they are available through:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb14&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb14-1&#34; title=&#34;1&#34;&gt;circuit.cz(control, target)&lt;/a&gt;
&lt;a class=&#34;sourceLine&#34; id=&#34;cb14-2&#34; title=&#34;2&#34;&gt;circuit.cy(control, target)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;toffoli-gate&#34;&gt;Toffoli gate&lt;/h3&gt;
&lt;p&gt;The Toffoli gate is the quantum equivalent of the logical AND gate. Even though it computes &lt;span class=&#34;math inline&#34;&gt;\(a \wedge b\)&lt;/span&gt;, it needs an extra qubit: &lt;span class=&#34;math inline&#34;&gt;\(|a\rangle|b\rangle \rightarrow |a\rangle|a \wedge b\rangle\)&lt;/span&gt; is not described by an unitary matrix. Thus, the Toffoli gates uses an extra qubit such that &lt;span class=&#34;math inline&#34;&gt;\(|a\rangle|b\rangle|0\rangle \rightarrow |a\rangle|b\rangle|a \wedge b\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Because we need to handle the case when the working qubit is &lt;span class=&#34;math inline&#34;&gt;\(|1\rangle\)&lt;/span&gt;, the Toffoli gate is described by:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
|a\rangle|b\rangle|c\rangle \overset{CCX}\rightarrow |a\rangle|b\rangle|c \oplus (a \wedge b)\rangle
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To use the Toffoli gate in Qiskit, it suffices to write:&lt;/p&gt;
&lt;div class=&#34;sourceCode&#34; id=&#34;cb15&#34;&gt;&lt;pre class=&#34;sourceCode python&#34;&gt;&lt;code class=&#34;sourceCode python&#34;&gt;&lt;a class=&#34;sourceLine&#34; id=&#34;cb15-1&#34; title=&#34;1&#34;&gt;circuit.ccx(control_a, control_b, target_qubit)&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Graphically, it looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/Q1C1.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Because of the properties of &lt;span class=&#34;math inline&#34;&gt;\(\oplus\)&lt;/span&gt;, the Toffoli is the inverse of itself. Thus, if we apply twice the Toffoli gate to the same 3 qubits, the working qubit will not change.&lt;/p&gt;
&lt;p&gt;To consolidate those ideas, here is a Jupyter notebook that uses multiple-qubit gates:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/89356c91607ed73fec75f7b0db33cf25.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;uncomputation&#34;&gt;Uncomputation&lt;/h2&gt;
&lt;p&gt;As we discussed in the previous session, we have seen that for calculating the AND of qubits &lt;span class=&#34;math inline&#34;&gt;\(|a\rangle\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(|b\rangle\)&lt;/span&gt;, we need a working qubit to store &lt;span class=&#34;math inline&#34;&gt;\(|a \wedge b\rangle\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;It turns out that sometimes, to compute a generic function &lt;span class=&#34;math inline&#34;&gt;\(f(a, b)\)&lt;/span&gt;, we may need even more working qubits to store intermediate results.&lt;/p&gt;
&lt;p&gt;For example, imagine that you want to compute &lt;span class=&#34;math inline&#34;&gt;\(a \wedge b \wedge c\)&lt;/span&gt;, the AND of three variables. You would need a qubit to compute &lt;span class=&#34;math inline&#34;&gt;\(a \wedge b\)&lt;/span&gt; and then another qubit to compute &lt;span class=&#34;math inline&#34;&gt;\((a \wedge b) \wedge c\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Notice that we have very little interest in saving &lt;span class=&#34;math inline&#34;&gt;\(a \wedge b\)&lt;/span&gt;. In general, it is a good idea to clean the results (i.e. to reverse the qubit to &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt;), because:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We want to reuse resources&lt;/li&gt;
&lt;li&gt;It makes measurements more accurate (more qubits = more complex systems = harder measurements)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That process of cleaning is called uncomputation.&lt;/p&gt;
&lt;p&gt;Because &lt;span class=&#34;math inline&#34;&gt;\((a \wedge b) \oplus (a \wedge b) = 0\)&lt;/span&gt;, that is the inverse of the Toffoli gate is the Toffoli gate itself, then we may build the following circuit to calculate the AND of three qubits using uncomputation:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/Quantum1/Q1C3.png&#34; /&gt;&lt;/p&gt;
&lt;p&gt;In the circuit above, we use an intermediary qubit &lt;span class=&#34;math inline&#34;&gt;\(|a \wedge b \rangle\)&lt;/span&gt; to help us achieve &lt;span class=&#34;math inline&#34;&gt;\(|a \wedge b \wedge c\rangle\)&lt;/span&gt;, and then immediately clean it afterward. That way, the intermediary qubit goes back to &lt;span class=&#34;math inline&#34;&gt;\(|0\rangle\)&lt;/span&gt; and can be reused later if necessary.&lt;/p&gt;
&lt;p&gt;The Qiskit code that implements the calculation of the AND of three qubits is provided bellow, building exactly the circuit we described:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/0fd6cc6a2a892dd9d3b59e59cfa0f2a2.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>MassPostage ![](/img/Badges/masspostage.svg)</title>
      <link>https://ivaniscoding.github.io/project/masspostage/</link>
      <pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate>
      <guid>https://ivaniscoding.github.io/project/masspostage/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Lightning Traffic ![](/img/Badges/traffic.svg)</title>
      <link>https://ivaniscoding.github.io/project/traffic_lights_ai/</link>
      <pubDate>Fri, 15 Mar 2019 00:00:00 +0000</pubDate>
      <guid>https://ivaniscoding.github.io/project/traffic_lights_ai/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Divide-and-conquer Techniques #1 - All But One Trick</title>
      <link>https://ivaniscoding.github.io/posts/dctrick1/</link>
      <pubDate>Sun, 03 Mar 2019 10:00:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/dctrick1/</guid>
      <description>&lt;p&gt;This is a post about one very interesting Divide-and-conquer technique. I call this the &amp;ldquo;All but one&amp;rdquo; trick because that&#39;s an accurate description
of what it can be used for. I learned about this in the &lt;a href=&#34;http://maratona.ic.unicamp.br/BrazilianICPCSummerSchool2018/&#34;&gt;Brazilian ICPC Summer School in 2018&lt;/a&gt;, thanks to &lt;a href=&#34;https://www.mimuw.edu.pl/~idziaszek/index.html&#34;&gt;Tomasz Idziaszek&lt;/a&gt; and thought it would be
a good addition to this blog. In this post, I will briefly explain the technique and show its application in one problem.&lt;/p&gt;
&lt;p&gt;This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Merge_sort&#34;&gt;Merge Sort&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search&#34;&gt;Binary Search&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;the-problem-it-solves&#34;&gt;The problem it solves&lt;/h1&gt;
&lt;p&gt;This trick is useful to solve the following kind of problem: Imagine there is a structure &lt;strong&gt;S&lt;/strong&gt; with &lt;strong&gt;N&lt;/strong&gt; elements. To build &lt;strong&gt;S&lt;/strong&gt;, you add elements one at a time. You would like to know what
&lt;strong&gt;S&lt;/strong&gt; would look like if, for each element, we considered &lt;strong&gt;S&lt;/strong&gt; without it. However, it is computationally expensive to remove an arbitrary single element.&lt;/p&gt;
&lt;p&gt;A naive approach to this problem that is very straightforward is to rebuild &lt;strong&gt;S&lt;/strong&gt; multiple times without each element. Even though this approach works,
a lot of computations are wasted because many times we have almost the same state for &lt;strong&gt;S&lt;/strong&gt;. After analyzing this, a question arises: is there a more efficient way to do it?&lt;/p&gt;
&lt;p&gt;If removing the last addition to &lt;strong&gt;S&lt;/strong&gt; is fast, then the answer is yes. It uses a clever observation that follows nicely into a Divide-and-Conquer Algorithm.&lt;/p&gt;
&lt;h1 id=&#34;the-algorithm&#34;&gt;The algorithm&lt;/h1&gt;
&lt;p&gt;The idea for the algorithm can be described as follows: if we have a set of &lt;strong&gt;N&lt;/strong&gt; elements, we split into two sets of roughly equal size. Then, for one of the halves, we will add all of its elements to &lt;strong&gt;S&lt;/strong&gt;. Notice that by doing this, we arrive at the same conceptual problem for the other half: find &lt;strong&gt;S&lt;/strong&gt; without a single element for each element.&lt;/p&gt;
&lt;p&gt;Hence, we can continue the procedure until we arrive with a set of a single element. When that happens, we can answer the query about &lt;strong&gt;S&lt;/strong&gt; without that element. The only missing point with that idea is that we need to answer the query for every element and not only for a single one. To solve this, we just need to change a few things when we recurse up.&lt;/p&gt;
&lt;p&gt;The changes are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Remove all additions that were made in the step when we recurse up.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add the elements of the half that were not added at first, and recurse to the half that was added at first.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lastly, we need to undo those add operations when we recurse back to maintain the fact that calling the Divide and Conquer function does not alter the state of &lt;strong&gt;S&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now the algorithm works because we can guarantee that we will arrive at a situation with a single element for every element and that when that happens all the other elements will have been added to &lt;strong&gt;S&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If the operation of adding has a complexity of &lt;strong&gt;O(K)&lt;/strong&gt; and the operation of undoing has a complexity of &lt;strong&gt;O(L)&lt;/strong&gt;, then the algorithm has an overall complexity of &lt;strong&gt;O(N*(K+L)*log(N))&lt;/strong&gt;. A pseudo-implementation of the algorithm is given below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void DivideAndConquer(int s, int e){

    // Base case: single element
    if(s == e){
        // Answer your query !
        return ;
    }

    int m = (s+e)/2; // we will split the set into two

    /* 
    First part: add elements of the right,
    recurse to the left and undo
    */

    for(int i = m+1; i&amp;lt;=e; i++){
        // Adding elements of the right half
        add(i);
    }

    DivideAndConquer(s, m); // recursing to the left half

    for(int i = e; i&amp;gt;=m+1; i--){
        // undo all the operations of addition
        undo();
    }

    /*
    Second part: add elements of the left,
    recurse to the right and undo
    */

    for(int i = s; i&amp;lt;=m; i++){
        // Adding elements of the left half
        add(i);
    }

    DivideAndConquer(m+1, e); // recursing to the right half

    for(int i = m; i &amp;gt;= s; i--){
        // undo all the operations of addition
        undo();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;example-problem&#34;&gt;Example Problem&lt;/h1&gt;
&lt;p&gt;The problem we will analyze is Voltage from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2014). You may find the problem statement and a place to submit &lt;a href=&#34;https://dunjudge.me/analysis/problems/763/&#34;&gt;here&lt;/a&gt; and the original problem statement in Japanese &lt;a href=&#34;https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d3.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : There is a circuit with &lt;strong&gt;N&lt;/strong&gt; nodes and &lt;strong&gt;M&lt;/strong&gt; resistors. Each node can be set either to low or high voltage, and current cannot flow through resistors connected to nodes of the same voltage. Calculate how many resistors can be removed such that if we remove only that resistors, there is current flowing in all other resistors.&lt;/p&gt;
&lt;h1 id=&#34;reduction-to-the-trick-and-solution&#34;&gt;Reduction to the trick and solution&lt;/h1&gt;
&lt;p&gt;The problem can be reduced to the following one: check if without an edge &lt;strong&gt;E&lt;/strong&gt;, the graph is bipartite.&lt;/p&gt;
&lt;p&gt;The structure to verify if a graph is bipartite while adding edges is a modified &lt;a href=&#34;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&#34;&gt;Disjoint Set Union-Find&lt;/a&gt;. I will not be going into many details, but you may find more explanation about it in this &lt;a href=&#34;https://discuss.codechef.com/questions/131944/bipartite-checking-using-dsu&#34;&gt;CodeChef discussion&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Removing an arbitrary edge from the DSU is fairly difficult, but removing the last one is not due to the stack-like structure of the DSU. Hence, the problem we have fits in the range of the applications of the trick and can be solved in &lt;strong&gt;O(N*log(N)^2)&lt;/strong&gt;. The implementation using the technique follows:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/d435ce4634fd54ff99428ee15e9730d7.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>SuSy Reminder Bot ![](/img/Badges/reminder.svg)</title>
      <link>https://ivaniscoding.github.io/project/susy_reminder/</link>
      <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://ivaniscoding.github.io/project/susy_reminder/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Information Theory #6 - Amusement Park</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory6/</link>
      <pubDate>Tue, 28 Aug 2018 14:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory6/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory5/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Amusement Park from the Japanese Olympiad in Informatics Open Contest (JOI Open 2017). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI17_amusement_park&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : You are given a connected graph of N vertices and M edges (60 &amp;lt;= N &amp;lt;= 10000, M &amp;lt;= 20000) . JOI-kun must tell the integer X ( 0 &amp;lt;= X &amp;lt;= 2^60 - 1) to IOI-chan, but he cannot do that directly. Instead, he will write either 0 or 1 in each vertex.  IOI-chan can read the integer written on the vertex currently at and move to any adjacent vertex. Help IOI-chan discover X by using the smallest possible number of movements. You must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the structure of the graph and the integer X, writes 0 or 1 on each vertex. Note that JOI-kun does not know the starting vertex of IOI-chan.&lt;/li&gt;
&lt;li&gt;One that given a starting vertex and the graph structure, uses the least number of moves such that with the integers written on the visited vertices it can recover the integer X.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The scoring of the subtasks is based on the maximum number of moves IOI-chan does. In order to score 100 points, you must find a solution that uses at most 120 moves.&lt;/p&gt;
&lt;p&gt;I will not discuss the first subtasks because I found a solution that in my opinion is conceptually simple (it is basically a DFS) and already scores 78 points going up to subtask 4. Thus, we will discuss the DFS idea and the final solution.&lt;/p&gt;
&lt;h2 id=&#34;a-dfs-approach--78-points&#34;&gt;A DFS approach : 78 points&lt;/h2&gt;
&lt;p&gt;There are some initial steps that are common to almost all approaches to this problem. They are necessary in order to solve the problem because they take care of the basic : how to send X with 0&#39;s and 1&#39;s&lt;/p&gt;
&lt;p&gt;The idea is : we will have to use the binary encoding of X to send it with 0&#39;s and 1&#39;s. The strategy will be as follows : we will assign for each vertex which of the 60 bits it represents; we must find a procedure that produces the same result for IOI-chan and JOI-kun, because we need to be sure that we are correctly receiving the message.&lt;/p&gt;
&lt;p&gt;The next step of this idea is : we need to find an efficient way of moving between the vertices such that we can recover the 60 bits quickly. When we get all the bits, we stop moving and report X. In order to achieve this, we have to also think about the way we assign the bit for each vertex, because this assignment heavily impacts in the number of movements.&lt;/p&gt;
&lt;p&gt;The final step is : it is easier to solve this problem on a tree. Because of the tree properties, it is simple to find a correct way to assign the bits to the vertices and it is less complicated to decide where to move compared to a general graph. Due to the fact that our graph is connected, we can always find a spanning tree of the graph and transform the general graph into a tree.&lt;/p&gt;
&lt;p&gt;An algorithm that finds a spanning tree and also finds an efficient way of choosing the bits is the Depth-First Search. Let&#39;s take a look :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory6/amusement.png&#34; alt=&#34;DFS Tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;We start the algorithm by doing the DFS from any vertex of the graph. There are two key ideas that make the algorithm efficient:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If a vertex was the (i)-th vertex to be discovered by the DFS, we define its discovery time as (i - 1). The bit that we will assign for this vertex will be (i - 1) modulo 60.&lt;/li&gt;
&lt;li&gt;We keep the edges used to discover of a new vertex as the edges of our spanning tree. Thus, we build the tree as we assign the bits&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By doing that, the only remaining step is to find an efficient way to move in order to quickly discover all the 60 bits.&lt;/p&gt;
&lt;p&gt;However, the way we move will also be heavily inspired by the DFS. Suppose that we are currently at a vertex v and let T be the subtree of v considering that the tree is rooted at the starting vertex of the DFS. There are two cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The size of T is bigger than or equal to 60. We just follow the DFS order and stop when all the 60 bits are found.&lt;/li&gt;
&lt;li&gt;The size of T is smaller than 60. We follow the DFS order and then return to the parent vertex of v, p. In p we do something similar but in a different order : instead of following the DFS from the first discovered child, we follow the DFS order from v and consider the array of children to be circular. Let&#39;s exemplify : if [1,2,3,4] was the ordering and you came from 3, them the order will be [3,4,2,1].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This algorithm uses at most 160 movements and scores 78 points. It was harder to think and explain the algorithm then to implement it. You may find the partial solution &lt;a href=&#34;https://oj.uz/submission/69340&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;a-smart-subtree-approach--100-points&#34;&gt;A smart subtree approach : 100 points&lt;/h2&gt;
&lt;p&gt;In the final solution, we will also stick to the idea of solving the problem on a tree and reducing a general graph to its spanning tree. However, we will tweak the moving part of our algorithm to be more efficient.&lt;/p&gt;
&lt;p&gt;From now on, when we talk about subtrees , think of them as a connected acyclic subgraph rather than a subtree of a rooted tree. Suppose that we have a subtree of exactly 60 vertices . If we run the DFS algorithm on this subtree, we will be able to find X with 120 moves or less for all the vertices of the subtree.&lt;/p&gt;
&lt;p&gt;If we could assign for each vertex a subtree of size 60 such that all the bits of X are represented in the subtree, then our problem is solved. Let&#39;s focus on finding a way of doing that.&lt;/p&gt;
&lt;p&gt;Suppose we have already found the spanning tree and found an arbitrary subtree T of size 60. For all vertices of the subtree, we assign T as its subtree. Then, we will try to assign a subtree to the neighbors of the vertices of the subtree that have not yet been assigned a subtree.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory6/amusement1.png&#34; alt=&#34;Limited Subtree&#34;&gt;&lt;/p&gt;
&lt;p&gt;The idea is as follows. Let u be the vertex without an assigned subtree and v its neighbor that has been assigned the subtree T. To find subtree for u, we copy T and remove an arbitrary leaf of the tree that is not v. Then, we connect u to v in the new subtree T* and assign the bit of the removed leaf to u. The image above shows this idea for a smaller subtree : we pick any of the leaves (in this it was the one numbered 6, but it could be 5) and remove it. Then, we connect the new vertex to its neighbor in the subtree an assign the 6th bit to the new vertex.&lt;/p&gt;
&lt;p&gt;We must run the routine above until all vertices are assigned a subtree. Because the graph is connected, it will always be possible to assign a subtree to each vertex.&lt;/p&gt;
&lt;p&gt;In the decoding part as IOI-chan , we run the DFS idea from our previous algorithm in the subtree of the starting vertex. IOI-chan will make at most 120 moves.&lt;/p&gt;
&lt;p&gt;In my final implementation, I opted to use a BFS to generate a spanning tree instead of the DFS. Despite that, the algorithm is exactly the same as the one described above.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/f783667abfc69916405b6ffe4ace99c5.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #5 - City</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory5/</link>
      <pubDate>Mon, 27 Aug 2018 22:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory5/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory4/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is City from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2017). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI17_city&#34;&gt;here&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you are given a rooted tree of N vertices (N &amp;lt;= 250000) that has a depth that is at most 18. You must write an integer on each node so that given only the integers written on X and Y, without knowing the structure of the tree, you can answer the question : is X on the path from Y to the root, Y on the path from X to the root or neither of them?&lt;/p&gt;
&lt;p&gt;The scoring of the problem is based on the maximum integer you write on each node. There is also a subtask for N &amp;lt;= 10.&lt;/p&gt;
&lt;h2 id=&#34;subtask-1--n--10-8-points&#34;&gt;Subtask 1 : N &amp;lt;= 10 (8 points)&lt;/h2&gt;
&lt;p&gt;In this subtask, the graph is small and the maximum integer does not matter as long it is smaller than 2^60 - 1.&lt;/p&gt;
&lt;p&gt;Because of this, we may choose a suboptimal strategy to solve the problem. The simplest one is to encode the vertex and the whole adjacency matrix on the integer we send.&lt;/p&gt;
&lt;p&gt;We use the binary encoding to send the current node (this uses 4 bits) and use another 45 bits to send the matrix. Then, we run a DFS to see which case happens&lt;/p&gt;
&lt;h2 id=&#34;l--236---1--22-points&#34;&gt;L &amp;lt;= 2^36 - 1 : 22 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory5/city0.png&#34; alt=&#34;Euler Tour on a Tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;With very big N, it is impossible to send the adjacency matrix. So we will focus on another technique to solve the problem.&lt;/p&gt;
&lt;p&gt;This technique is commonly called &amp;ldquo;Euler Tour on a Tree&amp;rdquo; , even tough it is not exactly an Euler Tour. You can interpret it as noticing a special property of the initial and final time when you do a DFS on the tree.&lt;/p&gt;
&lt;p&gt;The image above represents the &amp;ldquo;Euler Tour&amp;rdquo;. Every time you enter a vertex v, you increase the DFS counter and says this is number is the start time of v . At the end of the DFS on v, we also save the DFS counter and says it is the end time of v. The vector in the image represents this DFS ordering.&lt;/p&gt;
&lt;p&gt;The cool thing about this is that it allows us to check if a vertex u is on the subtree of a vertex v easily. Because the vertices of the subtree form a contiguous subarray in the DFS order array, we can simply check if the start of u is contained in the interval [s,e] where s is the start time of v and e the end time of v.&lt;/p&gt;
&lt;p&gt;If you think a little bit about it, checking if a vertex v is on a subtree of another is exactly the same as checking if that another vertex is on the path from v to the root. So we found a solution to the problem we want to solve!&lt;/p&gt;
&lt;p&gt;For each vertex, we send an integer that represents the start and end time of the DFS. To do that, we send 18 bits for the start and another 18 bits for the end. In the decoding part, we simply recover the starts and ends and run the interval check described above.&lt;/p&gt;
&lt;p&gt;The maximum number if 2^36 - 1 , thus we score 22 points.&lt;/p&gt;
&lt;h2 id=&#34;an-unused-property&#34;&gt;An unused property&lt;/h2&gt;
&lt;p&gt;So far we did not the property that the depth of the tree is at most 18. The solution described above works for any tree, and therefore does not exploit the special property of the depth.&lt;/p&gt;
&lt;p&gt;Because the maximum depth is 18, every node has at most 18 ancestors and is therefore contained in at most 18 intervals. Thus, the sum of the lengths of all intervals is at most 18*N. So on average each interval is at most 18. That is not much.&lt;/p&gt;
&lt;p&gt;It seems to be a waste to send 18 bits of the end when we could send the size, which is on average 5 bits. So we will do exactly that : instead of sending the end, we send the size of the interval.&lt;/p&gt;
&lt;p&gt;This optimization alone does not affect our punctuation, because there are causes in which we will still send integers up to 2**36 - 1. However, this idea is a crucial step to solve the problem.&lt;/p&gt;
&lt;h2 id=&#34;an-efficient-way-of-sending-the-size--100-points-solution&#34;&gt;An efficient way of sending the size : 100 points solution&lt;/h2&gt;
&lt;p&gt;We need to optimize the way we send the size. In a perfect environment, we could create a smaller dictionary that represented the sizes and send the position in that dictionary.&lt;/p&gt;
&lt;p&gt;However, it is difficult to adjust a dictionary to the sizes of the interval. We will try a different approach : adjust the interval size to the dictionary. But how do we do that ?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory5/city1.png&#34; alt=&#34;Dummy Nodes&#34;&gt;&lt;/p&gt;
&lt;p&gt;Suppose that the interval size is a. How do we fit that size to the dictionary , if it is not in it? Let b be the smallest integer of the dictionary greater than our equal to a. We can always add some extra leaves as dummy vertices in order to reach the size b. The image above exemplifies that, by adding two leaves to reach the size 5 from the original size 3.&lt;/p&gt;
&lt;p&gt;In practice, we are adding empty spaces to our DFS array. The challenge now is to build that dictionary of sizes.&lt;/p&gt;
&lt;h2 id=&#34;building-the-dictionary--100-points-solution&#34;&gt;Building the dictionary : 100 points solution&lt;/h2&gt;
&lt;p&gt;The challenge of finding a dictionary of sizes is that it should not add many extra vertices, because in that case the start of the vertices would be big and thus the dictionary would need to be small.&lt;/p&gt;
&lt;p&gt;If the total number of vertices (original and dummy) of the final solution is close to 2^K, then we must construct a dictionary of size 2^(28 - K) .&lt;/p&gt;
&lt;p&gt;Additionally , this dictionary should vary gradually. A function that varies gradually is a power function, so we can describe our dictionary as a set of {r^0, r^1, r^2&amp;hellip;} for some number r. The optimal r is the solution for r^(2^(28 - K)) = 2^K&lt;/p&gt;
&lt;p&gt;If you experiment with K, you may find that K = 20 is a good choice. Therefore, the maximum number of vertices if 2^20 and the dictionary size is 2^8 = 256.&lt;/p&gt;
&lt;p&gt;The value of r is 2^(20/256) ≈ 1.055645 (we must truncate because we cannot represent an irrational number in an exact decimal form).&lt;/p&gt;
&lt;p&gt;Because r is not an integer, our dictionary is not exactly described by a power function, but by an approximation. Let A be our dictionary and a0 = 0 the first element. We say that ai = max{ a(i-1) + 1, ai*r } , where ai*r is rounded down.&lt;/p&gt;
&lt;p&gt;In the final code, I opted to send the difference between the start and the end instead of the size. The result is identical, tough.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/ae0fb800f1e113807aee2a2804132aa3.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #4 - Airline Route Map</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory4/</link>
      <pubDate>Sun, 26 Aug 2018 20:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory4/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory3/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Airline Route Map from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI18_airline&#34;&gt;here&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : Alice needs to send to Bob an undirected graph of N vertices (N &amp;lt;= 1000) and M edges (M &amp;lt;= N*(N-1)/2). However, the information Alice sends suffers a series of shuffles before Bob receives it&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of the vertices are changed. So each of the N vertices will receive a new unique number from 0 to N-1.&lt;/li&gt;
&lt;li&gt;The edge list is shuffled. The edges remain consistent to the information you sent (if you sent A-&amp;gt;B, then it will mean A* -&amp;gt; B*, where A* and B* are the new numbers for A and B) , but their order on the edge list is not the same.&lt;/li&gt;
&lt;li&gt;The direction of the edge is changed. If it was A-&amp;gt;B , then you may receive A*-&amp;gt;B* or B*-&amp;gt;A*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may add or remove vertices and edges when you are sending the graph as Alice. When Bob receives the shuffled information, he needs to recove the original graph Alice wanted to send. You must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the undirected graph we want to send, generates a new graph and sends it.&lt;/li&gt;
&lt;li&gt;One that given the shuffled sent graph, recovers the original one
The scoring is based on the number of extra vertices you sent. The final subtasks uses only 12 extra vertices to recover the graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This time I will not focus on the subtasks but only at two solutions : one that uses 13 vertices and the improvement of this solution that uses 12 vertices.&lt;/p&gt;
&lt;h2 id=&#34;a-question--add-or-remove-edges-&#34;&gt;A question : add or remove edges ?&lt;/h2&gt;
&lt;p&gt;We are allowed to send any graph, so we must choose if we will add or remove edges (or do both). It turns out that it is very hard to recover information of edges that were not sent using few additional vertices. So it is better to send the original graph with some additional vertices that will help to recover the original numbering of the vertices.&lt;/p&gt;
&lt;h2 id=&#34;first-step--how-to-recover-the-numbers-&#34;&gt;First step : how to recover the numbers ?&lt;/h2&gt;
&lt;p&gt;The first challenge is to recover the original numbers with such few extra vertices. This requires an efficient way of sending information.&lt;/p&gt;
&lt;p&gt;It turns that sending the binary representation of the numbers is a good idea. To do that, we create 10 extra vertices, one for each possible set bit of a number. Then, we connect the i-th extra vertex to the numbers whose i-th bit is set.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline0.png&#34; alt=&#34;Connection to bits&#34;&gt;&lt;/p&gt;
&lt;p&gt;The image above does not show all the bits, but represent the connections of vertex 6 : it has an edge to the vertices that represent 2^1 and 2^2, but not to the one that is 2^0.&lt;/p&gt;
&lt;h2 id=&#34;second-step--identifying-the-bit-vertices&#34;&gt;Second step : identifying the bit vertices&lt;/h2&gt;
&lt;p&gt;The next challenge is to identify those special vertices. My idea to solve this was to create an additional vertex that is connected to all vertices of the graph, except to the bit ones.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline1.png&#34; alt=&#34;Additional vertex connected to everything except bits&#34;&gt;&lt;/p&gt;
&lt;p&gt;In addition to that, I also connected the bit vertices to form a chain , connecting the i-th one to the (i+1)-th one.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline2.png&#34; alt=&#34;Bit chain&#34;&gt;&lt;/p&gt;
&lt;p&gt;So now we only need to identify the 10th bit vertex and the special vertex that is connected to all the nodes. If we do that, we can always discover the next bit of the chain and we have solve our problem.&lt;/p&gt;
&lt;h2 id=&#34;third-step--identifying-the-last-bit-vertex-and-the-special-vertex&#34;&gt;Third step : identifying the last bit vertex and the special vertex&lt;/h2&gt;
&lt;p&gt;We have already used 11 extra vertices, so we do not want to use a lot more in order to identify these two vertices. So we must find some special property or implicit information that can helps us decode without sending many vertices.&lt;/p&gt;
&lt;p&gt;One important piece of information that we have not used so far is the degree of the vertices. If we analyze the degrees, we discover an important property : for N &amp;gt;= 3, all of the vertices but two will always have their degree bigger than or equal to 2. The only two vertices that sometimes can break the rule are the vertex 0, when it does not have any edge in the original graph,  and the 10th bit vertex when N &amp;lt;= 512.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline3.png&#34; alt=&#34;A trick for the two cases&#34;&gt;&lt;/p&gt;
&lt;p&gt;Therefore, it is a good idea to use two extra vertices with degree one to try identify the special and bit vertex, because they will be unique in our graph. With the extra one degree vertex, the 10th bit vertex no longer can have a degree one. The only remaining vertex that can mess up with our idea is 0.&lt;/p&gt;
&lt;p&gt;However, it is easy to overcome the problem with 0 : we can simply make the graph 1-indexed instead of 0-indexed. That way, 0 will become one and have a set bit, thus having a degree of at least two.&lt;/p&gt;
&lt;p&gt;In the end , we do as follows : we make the graph 1-indexed and add the two 1-degree vertices. Then , we identify the two vertices that are connected to the 1-degree vertices and distinguish the special vertex based on the degree (the special one will always have more edges). Then , we process our chain of bits, discover the original numbering for each vertex and report the original graph. This algorithm uses 13 additional vertices and scores 91 points, which is a very good result.&lt;/p&gt;
&lt;h2 id=&#34;fourth-step--final-optimization&#34;&gt;Fourth step : final optimization&lt;/h2&gt;
&lt;p&gt;In order to fully solve the problem, we must get rid of exactly one extra vertex. Therefore, we will need to use again implicit information that we did not use before.&lt;/p&gt;
&lt;p&gt;It turns out that we do not need the 1-degree vertex to identify the last bit vertex. Of all the bit vertices (that can be easily identified because of the special vertex), it will always be the one that has the smallest degree.&lt;/p&gt;
&lt;p&gt;Because of that, we drop the 1-degree vertex that connects to the last bit and tweak the algorithm we used before. Notice that by doing this, the 10th bit vertex can sometimes have only one edge, but with some thinking we can handle this case.&lt;/p&gt;
&lt;p&gt;In my implementation of this idea, I hard coded small cases to avoid corner cases. The remaining part of the code implements exactly the same idea as described above.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/32cb88cb0ae2c60ee4d2e42b8bfdfef3.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #3 - Broken Device</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory3/</link>
      <pubDate>Sat, 25 Aug 2018 12:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory3/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory2/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Broken Device from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2017). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI17_broken_device&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : Anna wants to send a 60-bit integer to Bruno. She has a device that can send a sequence of 150 numbers that are either 0 or 1. The twist is that L (0 &amp;lt;= L &amp;lt;= 40) of the positions of the device are broken and can only send 0. Bruno receives the sequence Anna sent, but the does not know the broken positions. You must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the integer X we want to send and the K broken positions, generates a sequence of length 150 that can be decoded.&lt;/li&gt;
&lt;li&gt;One that given the sequence generated by the previous procedure, decodes the integer X without knowing the K broken positions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The subtasks are based on the maximum number of broken positions your algorithm can handle. Let&#39;s see some ideas for different K&#39;s.&lt;/p&gt;
&lt;h2 id=&#34;k--0--0-points&#34;&gt;K = 0 : 0 points&lt;/h2&gt;
&lt;p&gt;This is not a subtask, but you need to know how to solve this case in order to solve the full problem. The idea is very simple : send the binary encoding of X. We will use the binary encoding in all other subtasks , but you need to keep this idea in mind.&lt;/p&gt;
&lt;p&gt;We use the first 60 positions to send the encoding and leave the other 90 unused.&lt;/p&gt;
&lt;h2 id=&#34;k--1--8-points&#34;&gt;K = 1 : 8 points&lt;/h2&gt;
&lt;p&gt;Because there is a broken place, we might not be able to send X using the 60 first positions. However, it will not be difficult to overcome that.&lt;/p&gt;
&lt;p&gt;The key idea is to send a signal meaning that this is the place the binary representation starts. That is, the first number 1 of the sequence will mean &amp;ldquo;The following 60 numbers are the binary encoding of X&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;In order to use this idea, we need to be sure that there will 61 adjacent positions that are not broken. Because K = 1, we know that this is true.&lt;/p&gt;
&lt;h2 id=&#34;k--15--41-points&#34;&gt;K = 15 : 41 points&lt;/h2&gt;
&lt;p&gt;We will use a different strategy to send the binary encoding of X. The first step of our algorithm is to divide our 150 sequence into 75 buckets of size 2. The image bellow represents this idea , where grey is &amp;ldquo;0&amp;rdquo; and black is &amp;ldquo;1&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory3/broken0.png&#34; alt=&#34;Buckets of size 2&#34;&gt;&lt;/p&gt;
&lt;p&gt;This will allow us to use an encoding that is less affected by the broken places, because we will not need that a lot of adjacent non-broken positions.&lt;/p&gt;
&lt;p&gt;Our encoding will use every 2 positions to send at most one bit. Notice that sometimes we may not send any information because of the broken places, but that is okay.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory3/broken1.png&#34; alt=&#34;Table encoding for buckets of size 2&#34;&gt;&lt;/p&gt;
&lt;p&gt;We will send the bits in order. If we receive &amp;ldquo;00&amp;rdquo;, then we did not send any information. If we receive &amp;ldquo;10&amp;rdquo;, this means that the next bit is &amp;ldquo;0&amp;rdquo;, and if we receive &amp;ldquo;11&amp;rdquo;, this means that the next bit is &amp;ldquo;1&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;By using this encoding , we can send up to 75 bits if there weren&#39;t any broken places. When there is at least one broken position in a bucket, in the worst case, we lose that bucket.&lt;/p&gt;
&lt;p&gt;Considering we need to send 60 bits, we can afford to lose up to 15 buckets. So we solve to K up to 15.&lt;/p&gt;
&lt;h2 id=&#34;intermediary-ks--41-points&#34;&gt;Intermediary K&#39;s : 41+ points&lt;/h2&gt;
&lt;p&gt;We can improve the previous solution to handle more broken positions.&lt;/p&gt;
&lt;p&gt;The first improvement is to find a meaning for &amp;ldquo;01&amp;rdquo;, something that we did not. By meaning we are not only talking about &amp;ldquo;1&amp;rdquo; or &amp;ldquo;0&amp;rdquo;, but other creative ideas like repeating previous numbers.&lt;/p&gt;
&lt;p&gt;The second improvement is to use randomization in order to avoid the worst case of our algorithm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We may shuffle the position of the bits, in order to prevent the worst case where each broken position is on a different bucket&lt;/li&gt;
&lt;li&gt;We may change the integer we are sending by XORing it with a random number. This prevents cases where all numbers are 1 or 0, which can be bad for some ideas. To recover the original integer on the decoding part, we simply XOR the number we found with the random number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We need to carefully implement these ideas because we need to be able to revert the changes in the decoding part.&lt;/p&gt;
&lt;h2 id=&#34;k--40--100-points&#34;&gt;K = 40 : 100 points&lt;/h2&gt;
&lt;p&gt;The final solution is somewhat similar to the 41 points solution, but instead uses buckets of size 3.&lt;/p&gt;
&lt;p&gt;With buckets of size 3 , we can create an encoding that sends up to 2 bits per bucket. Inefficient implementations of this idea do not score full points, but do better than the 41 point solution. I will go straight to the efficient implementation of the idea, but you may take sometime to create a encoding on your own.&lt;/p&gt;
&lt;p&gt;Because of the size, we will use a encoding-table that is more resistant to broken places. The special property of the table is that it will allow us to send 2 bits of information in the case there are no broken places and 1 bit of information in the case there is one broken place.&lt;/p&gt;
&lt;p&gt;Because of that, we can always send 60 bits regardless of the configuration. One possible table is the following :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory3/brokenf.png&#34; alt=&#34;Optimal table for size 3 buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;My implementation of this idea:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/60aa5d68fe46012bd812564bc7b74f42.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #2 - Navigation</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory2/</link>
      <pubDate>Fri, 24 Aug 2018 17:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory2/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory1/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Navigation from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2015). You may find the problem statement and a place to submit &lt;a href=&#34;https://dunjudge.me/analysis/problems/762/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : Anna lives in an island that is part of the IOI islands, that can be represented by an acyclic connected graph. Bruno will visit Anna, but he does not know the whole structure of the tree. He only knows the adjacent islands to the island he is currently at. To help Bruno , Anna will write an integer on each island such that Brunno can go to Anna&#39;s island using the short possible path.&lt;/p&gt;
&lt;p&gt;We must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the structure of the tree and the island Anna lives, writes a number on each island&lt;/li&gt;
&lt;li&gt;One that given the current island and its number, the adjacent islands to that island and their respective number, goes from that island to the one closest to Anna&#39;s island. In the case Bruno is already on Anna&#39;s island, you must not move.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The subtasks are based on the maximum number you wrote on the vertices of the tree.&lt;/p&gt;
&lt;h2 id=&#34;subtask-1--no-restrictions&#34;&gt;Subtask 1 : No restrictions&lt;/h2&gt;
&lt;p&gt;For all subtasks , we will root the tree at Anna&#39;s island.&lt;/p&gt;
&lt;p&gt;The idea for this subtask is to write on each node its distance from the root of the tree when we are encoding. The image above exemplifies this idea.&lt;/p&gt;
&lt;p&gt;When we are decoding, we just go to the node whose number is the smallest.&lt;/p&gt;
&lt;h2 id=&#34;subtask-2--use-numbers-0-1-and-2&#34;&gt;Subtask 2 : use numbers 0, 1 and 2&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory2/navigation0.png&#34; alt=&#34;Level-tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;We need to use something completely different from our previous solution.&lt;/p&gt;
&lt;p&gt;Instead of writing the distances, we will create a table telling wether we should or shouldn&#39;t go to a node based on the number of the current node.&lt;/p&gt;
&lt;p&gt;This table should be complementary : if 0-&amp;gt;1 means go, 1-&amp;gt;0 means do not go. Because of that, we discard 0-&amp;gt;0 , 1-&amp;gt;1 and 2-&amp;gt;2. Even tough we have 6 possibilites, it is possible to find a table that does what we want.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory2/tabela.png&#34; alt=&#34;Table of wheter go or not&#34;&gt;&lt;/p&gt;
&lt;p&gt;To mark each node with the correct integer, we start by doing a DFS from the root. We can choose any integer for the root, so we choose 0 . At each step, we write for the children of our current vertex the number such that it means &amp;ldquo;Don&#39;t go&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Decoding is easy because of the table. The only case we need to be aware is for the root, because in that case we will find only &amp;ldquo;Don&#39;t go&amp;rdquo;, so we must return the own vertex in that case.&lt;/p&gt;
&lt;h2 id=&#34;subtasks-3-and-4--0-and-1&#34;&gt;Subtasks 3 and 4 : 0 and 1&lt;/h2&gt;
&lt;p&gt;With only two numbers , it is impossible to find a table like the previous one. In order to solve the problem , we must try a different strategy or find some implicit information that we have not used so far.&lt;/p&gt;
&lt;p&gt;In this case, we will go with the second option. At the current point, we have not taken advantage of the fact that the number of the vertices remain the same. That is a lot of information !&lt;/p&gt;
&lt;p&gt;Our previous solution relied heavily on the idea of the complementary table. We need to find some information that is complementary and uses the number of the vertices.&lt;/p&gt;
&lt;p&gt;An operator that does exactly that is the less than operator. If  (a &amp;lt; b) equals true, then (a &amp;gt; b) equals false. This was the implicit information we were looking for.&lt;/p&gt;
&lt;p&gt;In order to decide wether we should or shouldn&#39;t go from vertex A to B, we will calculate the following value : v = (integer written on A) + (integer written on B) + (A &amp;lt; B). If v is an even number, then we do not go. If v is an odd number, then we go.&lt;/p&gt;
&lt;p&gt;Because of the complementary nature of the less operator, if v means &amp;ldquo;Go&amp;rdquo; to A, then it will mean &amp;ldquo;Don&#39;t go&amp;rdquo; to B.&lt;/p&gt;
&lt;p&gt;To mark the correct integer on each node, we start by doing a DFS from the root. For each children, we choose the correct integer such that we write &amp;ldquo;Don&#39;t go&amp;rdquo; from the current node.&lt;/p&gt;
&lt;p&gt;Even tough there was a lot of thinking , the final code is very simple. Wow!&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/7d5609cd161b9abed9a65185fc30dc89.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #1 - Coins</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory1/</link>
      <pubDate>Fri, 24 Aug 2018 13:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory1/</guid>
      <description>&lt;p&gt;Information Theory problems are not common and that is why I am writing about them.&lt;/p&gt;
&lt;p&gt;They generally consist of two parts : encoding and decoding. It seems to be simple in theory, but problem setters get very creative when adding restrictions that make simple things hard.&lt;/p&gt;
&lt;p&gt;Each problem is unique, however there are some aspects that seem to be shared by many problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is important to know what you need to send&lt;/li&gt;
&lt;li&gt;It relevant to know which information will be available to both the encoder and decoder&lt;/li&gt;
&lt;li&gt;Binary encoding is an efficient way of sending data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The problem we will analyze is Coins from the Practice Section of the International Olympiad in Informatics (IOI 2017 Practice). You may find the problem statement and a place to submit &lt;a href=&#34;https://dunjudge.me/analysis/problems/1663/&#34;&gt;here&lt;/a&gt; . I have chosen this one because it is neither too easy nor too hard, so it is the ideal one to start.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have a number C (0 &amp;lt;= C &amp;lt; 64) and an array of 64 numbers that are either 0 or 1. In the encoding part, you may change the status of at least one number and at most K numbers of the array. In the decoding part, you receive the array already with the changes and you must answer the number C.&lt;/p&gt;
&lt;p&gt;We will focus on the subtasks 3, 4 and 5.&lt;/p&gt;
&lt;h2 id=&#34;subtask-3--k--64&#34;&gt;Subtask 3 : K = 64 &lt;/h2&gt;
&lt;p&gt;The idea of this task is to calculate the number C by the number of 1&#39;s in the array. Thus, we flip 0&#39;s to 1&#39;s until we have C 1&#39;s in our array.&lt;/p&gt;
&lt;p&gt;Notice that we must always flip at least one coin. So in the case the number of 1&#39;s is already equal to C, we need to flip the same coin twice.&lt;/p&gt;
&lt;h2 id=&#34;subtask-4--k--8&#34;&gt;Subtask 4 : K = 8&lt;/h2&gt;
&lt;p&gt;The idea above wastes lots of implicit information that is shared between the encoder and decoder. In order to reduce the number of flips, we must use that information.&lt;/p&gt;
&lt;p&gt;Because the position of the numbers of the array do not change, we can use the first 8 coins to send the binary representation of the number C. So we need to flip at most 8 coins, and not 64 like before.&lt;/p&gt;
&lt;p&gt;Notice again that in the case the 8 first coins already correspond to the binary encoding of C, we need to flip the same coin twice because we must flip some coin.&lt;/p&gt;
&lt;h2 id=&#34;subtask-5--k--1&#34;&gt;Subtask 5 : K = 1&lt;/h2&gt;
&lt;p&gt;Honestly, I was a bit surprised when the problem asked for a solution that uses only one coin flip. I did not expect such a efficient solution at first. However, after thinking about some bitwise operators, I was able to design an algorithm that did the job.&lt;/p&gt;
&lt;p&gt;Firstly , we will need to define a new decoding function for the array. This function may seem a little bit strange at first, but is has a very special property that solves the problem.&lt;/p&gt;
&lt;p&gt;Let A be the array we receive. f(A) = i1^i2^&amp;hellip;ik where &amp;ldquo;^&amp;rdquo; is the bitwise XOR operator and i1,i2 &amp;hellip; ik the positions that are &amp;ldquo;1&amp;rdquo; on the array. In the case A has no &amp;ldquo;1&amp;rdquo;, f(A) = 0.&lt;/p&gt;
&lt;p&gt;The first special property is that result of the function is always an integer x such that 0 &amp;lt;= x &amp;lt;= 63.  The second is that when we flip the coin j of A and obtain the array A*, the value f(A*) = f(A)^j , regardless of the state of position j in the array A.&lt;/p&gt;
&lt;p&gt;Because 0 &amp;lt;= x &amp;lt;= 63 and 0 &amp;lt;= C &amp;lt;= 63, we can prove that there is an y , 0 &amp;lt;= y &amp;lt;= 63, such that x^y.&lt;/p&gt;
&lt;p&gt;This leads to the solution. We calculate the value of f(Aj*) for Aj* identical to A , except for the j-th coin that is flipped, for all 0 &amp;lt;= j &amp;lt;= 63. One of the j&#39;s will lead to a configuration whose function value is C, so we return that j as the solution.&lt;/p&gt;
&lt;p&gt;A further improvement is that we can know the value of j even quicker. Because of the XOR properties, j = f(A)^C is the position our previous algorithm would find.&lt;/p&gt;
&lt;p&gt;The final code could not be simpler.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/f4045192efcd00d49024cfed6bee5803.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #4 - ICC</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer4/</link>
      <pubDate>Thu, 23 Aug 2018 18:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer4/</guid>
      <description>&lt;p&gt;This is the fourth post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer3/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is ICC from the Central-European Olympiad in Informatics (CEOI 2016). You may find the problem statement here and a place to submit the solution &lt;a href=&#34;http://www.ceoi2016.ro/wp-content/uploads/2016/08/icc-statement.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : there are N cities numbered from 1 to N. At each pass, we build a new road between two cities such that there is no cycle between them. You must guess the new road by asking the following question : is there an edge from a vertex of set A to a vertex of set B? The total number of queries for the N-1 passes must not exceed M queries. There are five subtasks with different (N,M) pairs, but N = 100 and M = 1625 for the last one.&lt;/p&gt;
&lt;p&gt;The fact that the statement mentions roads and cities heavily suggests that this is a graph problem. Indeed, it is one!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/arvore1.png&#34; alt=&#34;Graph representation of the problem&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every city is a vertex&lt;/li&gt;
&lt;li&gt;Every road is an edge&lt;/li&gt;
&lt;li&gt;Our graph is a forest&lt;/li&gt;
&lt;li&gt;At each pass, we add an edge between vertices of different forests&lt;/li&gt;
&lt;li&gt;Just by modeling the problem with a graph we arrive at the most simple solution:&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;on3--7-points&#34;&gt;O(N^3) : 7 points&lt;/h2&gt;
&lt;p&gt;At each pass, we query all possible edges. Notice that the possible edges do not include edges that connect two vertices of the same forest because of the acyclic property of our graph. In order to maintain that, we use an Union-Find data structure.&lt;/p&gt;
&lt;p&gt;To check wether or not there is an edge between two vertices, we do a query with unitary sets containing these vertices.&lt;/p&gt;
&lt;p&gt;The complexity analysis is not complicated. There are O(N^2) edges and O(N) passes, so the total number of queries is O(N^3).&lt;/p&gt;
&lt;h2 id=&#34;on2--18-points&#34;&gt;O(N^2) : 18 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/quadratico.png&#34; alt=&#34;One-versus all idea&#34;&gt;&lt;/p&gt;
&lt;p&gt;To reduce the number of queries, we will not try to discover directly the pair of vertices that is connected by the new edge. Instead, we will try to discover for each vertex if it is the one with a new edge.&lt;/p&gt;
&lt;p&gt;To do that we do the following query : we put the vertex we are considering now in a unitary set and all the vertices that are not on the subtree of this vertex. The image above exemplifies this.&lt;/p&gt;
&lt;p&gt;There will be two vertices that have new edges. These were the vertices we wanted to know and the new edge connect those vertices. The overall complexity is O(N) per pass and there are O(N) passes, so in total its O(N^2).&lt;/p&gt;
&lt;p&gt;Room for improvement : the start of D&amp;amp;C&lt;/p&gt;
&lt;p&gt;Suppose that we found the first vertex that has a new edge. We can use a Divide and Conquer algorithm to find the other one because we know it is on the set we have just asked about.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/icc0.png&#34; alt=&#34;Refining the idea&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&#39;s exemplify the algorithm with an example. Suppose we discovered that the vertex 1 has the new edge and the other vertex is on the set {2,3,4,5,6}. We split the set into L = {2,3,4} and R = {5,6} and do the query with sets {1} and L. If there is an edge between 1 and L , then we can discard R because there is only one edge. Similarly, if there is not, we discard L and continue with R. We continue to do that until we end with a set with only one element : the last element is the other vertex of the edge.&lt;/p&gt;
&lt;p&gt;So our &amp;ldquo;Divide&amp;rdquo; part is to split the set into two halves L and R and do the query between the known vertex and L. The &amp;ldquo;Conquer&amp;rdquo; part is to discard L or R based on the result of our query. The base case is the unitary set.&lt;/p&gt;
&lt;p&gt;This improvement alone does not give any extra points. However, the idea of the final solution uses this improvement.&lt;/p&gt;
&lt;p&gt;A desire : the perfect environment &lt;/p&gt;
&lt;p&gt;Suppose we had two sets A and B and we knew that there is a new edge from a vertex of set A to one on set B. If this happened , we could adapt the above algorithm to discover the two vertices very quickly.&lt;/p&gt;
&lt;p&gt;If we fixed the set A for all the queries and did the above procedure on B, we would find the vertex that has the edge on B. We could also fix B and run the algorithm on A, discovering the vertex on A.&lt;/p&gt;
&lt;p&gt;So the D&amp;amp;C part of the problem has ended. If we could find those two sets, the problem would be solved. But can we?&lt;/p&gt;
&lt;p&gt;The answer is fortunately yes.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--nk--61-points&#34;&gt;O(N*log(N) + N*K) : 61 points&lt;/h2&gt;
&lt;p&gt;The first idea two find the two sets is to use some randomization. Suppose that we put the connected components we have so far (represented by the head of the component) in a sequence and randomly shuffle the sequence. Then , we split the sequence into two halves. The probability that the components whose vertices form the new edge are on different halves if of 50%. We then construct two sets : A with the vertices of the components on the first half and B with the remaining ones. If there is an edge from A to B , we stop the shuffling and run the D&amp;amp;C algorithm. Otherwise, we continue until we arrive in a partition.&lt;/p&gt;
&lt;p&gt;The number of passes algorithm is not defined. However, we could say that on average it will need K passes. A good estimative of K is a K that gives a probability close to 1 that the partition will be found. Because 1 - (0.5)**10 &amp;gt;= 99.9%, K = 10 seems to be a reasonable one.&lt;/p&gt;
&lt;p&gt;The overall complexity is O(log(N) + K) per pass and therefore O(N*log(N) + N*K) total complexity.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--90-points&#34;&gt;O(N*log(N)) : 90 points&lt;/h2&gt;
&lt;p&gt;The final solutions uses a quicker approach to arrive at the partition.&lt;/p&gt;
&lt;p&gt;The partition used is based on a simple principle with a clever application. The idea is : every number written in its binary form has at least one different bit if we compare it to another number.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/binary.png&#34; alt=&#34;Bit representation example&#34;&gt;&lt;/p&gt;
&lt;p&gt;You may take a look at the image above with the representation of {0,1,2,3} in binary base and convince yourself. The formal proof is not that hard, but I will omit it.&lt;/p&gt;
&lt;p&gt;Because of the principle above, the following strategy will find a partition : first, we assign a integer from 0 to C-1 for each component.&lt;/p&gt;
&lt;p&gt;Then, for each bit, we separe the vertex into two sets A and B according to the state of that bit. A contains the vertices whose component number has the bit we are considering turned off and B contains the vertices whose component number has the bit turned on. We test this partition : if it works, then we run the D&amp;amp;C algorithm; if it does not, we follow to the next bit. By doing that, we achieve O(log(N)) to discover the partition which is a small improvement against the last algorithm, but scores more points because of the tight query limit.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;The solution mentioned above is 99% similar to the final solution. The only diference is that in order to achieve 100 points you need to do some micro optimizations.&lt;/p&gt;
&lt;p&gt;The first idea to reduce the number of queries is to shuffle the order that you choose the bit to do the partition. The grader is adaptative and tries to achieve the worst case complexity if you always ask about the bits in order, so shuffling prevents this from happening. If you implement this idea alone you should score 100 points.&lt;/p&gt;
&lt;p&gt;The second idea is to save a query per iteration when doing the partition. Imagine there are K bits to try the partition and you have tried K-1 of them. You do not need to check if the last one will find a valid partition, because it must. This is a small gain but helps.&lt;/p&gt;
&lt;p&gt;My solution to this problem :&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/fe07e32dc71523ee3f234d6487bb8c1a.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #3 - Library</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer3/</link>
      <pubDate>Thu, 23 Aug 2018 13:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer3/</guid>
      <description>&lt;p&gt;This is the third post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer2/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Library from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement &lt;a href=&#34;https://www.ioi-jp.org/camp/2018/2018-sp-tasks/day4/library-en.pdf&#34;&gt;here&lt;/a&gt; and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI18_library&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have an array of size N (N &amp;lt;= 1000) that is a permutation of 1,2,3&amp;hellip; N. At the beginning you do not know the configuration of the array. However, you are allowed to make up to 20000 queries which count the number of subarrays of the subset of numbers you are querying. After that, you must output one of the two possible configurations of the array.&lt;/p&gt;
&lt;p&gt;Our first step in order to solve the problem is to transform it into a graph problem:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/library0.png&#34; alt=&#34;Graph representation of the problem&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every number of the array is a vertex&lt;/li&gt;
&lt;li&gt;There is an edge between every two adjacent numbers in the array&lt;/li&gt;
&lt;li&gt;Our query answers the number of connected components of the subgraph we chose for that query.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This first steps leads very quickly to the solution to subtask 1:&lt;/p&gt;
&lt;h2 id=&#34;on2--19-points&#34;&gt;O(N^2) : 19 points&lt;/h2&gt;
&lt;p&gt;We simply try to discover all edges of the graph. To check wether or not there is an edge , we do a query with only two elements. If there is one connected component, then there is an edge. Otherwise, there is not an edge.&lt;/p&gt;
&lt;p&gt;After that, you can do a BFS/DFS starting from one of the two vertices with degree one and find one of the two possible answers.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;We have about 20 queries per vertex in order to discover the configuration of the array. This heavily suggests around O(log(N)) queries per vertex, which is a hint that Divide and Conquer might work.&lt;/p&gt;
&lt;p&gt;The first step of our algorithm will be adding the vertices in order :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/floating.png&#34; alt=&#34;Floating graph componnents&#34;&gt;&lt;/p&gt;
&lt;p&gt;When we adding the i-th vertex, the other i-1 vertices form C  connected components. Each component has two endpoints (note that the endpoints can be equal when there is only one element). You may think of these components as floating subarrays whose order is still to be defined. In the image, there is an example for a situation where we are adding the vertex 8.&lt;/p&gt;
&lt;p&gt;There are three possible cases for our newly added vertex :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zeroth case : there is no edge between i and the other components , therefore i is a part of a new connected component and the total number of components is increased.&lt;/li&gt;
&lt;li&gt;First case : there is exactly one edge of i to one of the endpoints of the components. The number of components remains the same.&lt;/li&gt;
&lt;li&gt;Second case : there are exactly two edges between i and two endpoints of different components. Therefore we merge two components in this step and the total number decreases by one.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/caso1.png&#34; alt=&#34;Possible cases&#34;&gt;&lt;/p&gt;
&lt;p&gt;To make the last two cases clearer, you may look at the examples above of the first and second case , respectively.&lt;/p&gt;
&lt;p&gt;The first query we will make for our new vertex is asking about the configuration with all the C  components and the vertex. The answer of the query uniquely determines the case : if there are C+1 components, then we know it is case 0 and we can continue our algorithm; if there are C components, then we know it is case 1 and we need to discover the component the i-th vertex is connecting and which vertex it is connecting to; the last option is that there are C - 1 components, in which we need to discover the two components and the two distinct endpoints.&lt;/p&gt;
&lt;p&gt;The next step of our solution is to create a D&amp;amp;C algorithm for the first case. It turns out that this algorithm is very similar to the algorithm of our last two posts :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/dc0.png&#34; alt=&#34;Divide and Conquer appears again&#34;&gt;&lt;/p&gt;
&lt;p&gt;We split the set of the components we have into two halves, L and R. We then try a configuration with the components of L and the i-th vertex. If there are |L| + 1 components in that configuration, then there is no edge between the i-th vertex and the components of L and we discard all components of L , because we know that the edge is on R. Otherwise, the number of components is |L| and we discard all components of R because of the same concept.&lt;/p&gt;
&lt;p&gt;Notice that when we do an iteration, we discard half of the components and arrive at the same problem we had before. If we continue to do that, we will eventually reach the case where there is only one component : this is our base case and the last component is the one we are looking for.&lt;/p&gt;
&lt;p&gt;After that, we need to discover the vertex that connects with the i-th one. This is very simple and can be done with one query : try to check if there is an edge between the i-th vertex and one of the endpoints the same way we did in the previous solution. If there is one, then we found the edge. If there is not, then the edge will be between the other endpoint and the i-th vertex. After that, you must not forget to update the component you found and its endpoints.&lt;/p&gt;
&lt;p&gt;The last step of our algorithm is to create a D&amp;amp;C algorithm for the second case. This part is a little bit more complicated compared to the last one, but not that much.&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Divide&amp;rdquo; part of our algorithm is identical to the last one. We split the set we are querying into two sets L and R. The change is on the &amp;ldquo;Conquer&amp;rdquo; part, because now there are three possible results for our query with L plus i-th vertex.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;|L| - 1 components : the two edges are on L. We discard R and recurse into the same problem we had, that is , a set in case 2.&lt;/li&gt;
&lt;li&gt;|L| + 1 components : the two edges are on R. We discard L and recurse into the same problem we had.&lt;/li&gt;
&lt;li&gt;|L| components : there is one edge on L and consequently one on R. We recurse into two independent problems, which is to find exactly one edge in a set. This is the first case of our algorithm!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Therefore, the &amp;ldquo;Conquer&amp;rdquo; step may recurse into one problem of case 2 or two problems of case one. Our base case will be the same as case 1.&lt;/p&gt;
&lt;p&gt;After we discovered the two components, we need to discover the vertices we connect to. We do exactly the same procedure as in case 1, but we need to be more careful when updating and merging the components.&lt;/p&gt;
&lt;p&gt;A code that implements the idea and scores 100 points follows:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/79fa951989731f161542868c8c51cc7f.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #2 - Cave</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer2/</link>
      <pubDate>Wed, 22 Aug 2018 11:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer2/</guid>
      <description>&lt;p&gt;This is the second post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer1/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Cave from the International Olympiad in Informatics (IOI 2013). You may find the problem statement &lt;a href=&#34;https://ioinformatics.org/files/ioi2013problem4.pdf&#34;&gt;here&lt;/a&gt; and a place to submit &lt;a href=&#34;https://dmoj.ca/problem/ioi13p4&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have N (1 &amp;lt;= N &amp;lt;= 5000) switches and doors. Each switch is linked to a door and has two possible configurations (0 or 1) : one that opens the connected door and one that does not. You can try up to 70000 configurations of switches and see the last door that is open. After those tries you must return the connected door to each switch and also its correct state.&lt;/p&gt;
&lt;p&gt;There are 5 subtask in this problem. Subtasks 1 and 2 are the ones that give the most crucial hints in order to arrive to the full solution. However, I will use a different strategy to get the 100 points : we will focus on the first door.&lt;/p&gt;
&lt;p&gt;The reason for that is that you do not need to know any information about the other doors in order to know about the first one. Therefore, it seems to be a good approach to focus on it.&lt;/p&gt;
&lt;p&gt;Our first problem is to discover the correct state of the switch that opens the first door.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/divide0.png&#34; alt=&#34;Initial State&#34;&gt;&lt;/p&gt;
&lt;p&gt;To solve this, we will try a configuration where all switches are set to the same configuration. Let&#39;s exemplify that with an image. Imagine that each switch is a position in our sequence of blocks, that the color blue represents the state &amp;ldquo;0&amp;rdquo; and that the color yellow represents &amp;ldquo;1&amp;rdquo;. If we try a configuration with all blocks having the blue color and it opens the first door, then the switch that opens the first door must be blue; otherwise, the first door would not be open. In the case the configuration fails to open the door, then the switch must be yellow.&lt;/p&gt;
&lt;p&gt;Our second problem is then to discover which switch opens the first door. There are three approaches to discover the position of the switch : by doing a complete search, by bucketing switches and by using a Divide and Conquer approach.&lt;/p&gt;
&lt;p&gt;The simplest idea is to do the complete search : we test all switches one by one. When we are trying a switch, we set it to the correct color and all the others to the complementary color.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave51.png&#34; alt=&#34;Brute Force&#34;&gt;
&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave71.png&#34; alt=&#34;Brute Force&#34;&gt;&lt;/p&gt;
&lt;p&gt;If the configuration with only the i-th switch set opens the first door, then this is the switch we are looking for. Otherwise, we continue to try other switches. An image helps us exemplify the idea again : first we test only the first switch with the correct color blue. In that case it did not work out, so we must try the second switch with the blue color. Then we discover that this configuration opens the first door and we assign the first door to the second switch.&lt;/p&gt;
&lt;p&gt;A refinement of the idea above is to use buckets in order to do less queries.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/bucket2.png&#34; alt=&#34;Buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;We group the switches into B buckets of roughly the same size. Then we apply the complete search idea , but with buckets instead : we set all the switches of the current bucket we are testing to the correct state and all the other ones to the complementary state. By doing this, we will discover the bucket that contains the desired switch. After that, we do a complete search on the switches of that bucket. The total number of queries is B + N/B. The value of B that minimizes the sum is sqrt(N), so this is a considerable gain if we consider that the idea is not that much different from the O(N) approach.&lt;/p&gt;
&lt;p&gt;The most efficient idea will then be Divide and Conquer. The key idea of our algorithm will be that there is one and only one switch that opens the first door.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave1.png&#34; alt=&#34;First step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Divide&amp;rdquo; part of our algorithm will be as follows : we split the current set of switches we are considering into two halves. We then try a configuration with the switches of the first half set to the correct state and all other switches set to the complementary state.&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Conquer&amp;rdquo; part is based in the result of our query. If the mentioned configuration opens the first door, then the switch we are looking for is on the first half and we discard all the switches of the other half. If it does not, then we discard all the ones from the first half and stick with the ones from the second half. Let&#39;s make an example with the set {1,2,3,4,5,6}. We split the set into L = {1,2,3} and R = {4,5,6} and try the configuration as described above and exemplified by the image above. Imagine that this configuration does not open the first door : then , we discard L and our set is now {4,5,6}.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave2.png&#34; alt=&#34;Second step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;We continue the procedure and split the set  in {4,5} and {6}. If we discover that {4,5} opens the door, than we discard {6}. Then we split {4,5} into {4} and {5} and do the query again.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave3.png&#34; alt=&#34;Third step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;We continue the procedure until we arrive into a set that contains a single switch. This the base case of our D&amp;amp;C recursion : the final element must be the switch we are looking for.&lt;/p&gt;
&lt;p&gt;The analysis of our idea is based on the depth of the recursion tree : because at each step we discard half of the nodes, then the maximal depth if log2(N).&lt;/p&gt;
&lt;p&gt;So we arrived at a fast solution to discovering the correct state and switch that opens the first door. However, we still need to take care of the other N-1 doors. This will not be very different from our current idea.&lt;/p&gt;
&lt;p&gt;The tweak is indeed very simple : we find the informations for the doors in order (1,2,3 and so on&amp;hellip;). When we are doing our queries for the i-th door, we remove the switches that opens the other i-1 doors from the set of candidates and set them to the correct states we discovered in the previous iterations of our algorithm. Therefore, discovering the correct state and switch that opens the i-th door with the information about the i-1 previous doors is equivalent to the problem of solving for the first door.&lt;/p&gt;
&lt;p&gt;Here is a code that implements the D&amp;amp;C algorithm and scores 100 points :&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/959274b5107c0542116a195f966f789e.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #1 - Carnival</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer1/</link>
      <pubDate>Tue, 21 Aug 2018 21:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer1/</guid>
      <description>&lt;p&gt;This is the first post of a series of posts about Divide and Conquer. The idea is to share this simple yet very powerful approach to solve some problems.&lt;/p&gt;
&lt;p&gt;This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Merge_sort&#34;&gt;Merge Sort&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search&#34;&gt;Binary Search&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Carnival from the Central-European Olympiad in Informatics (CEOI 2014). You may find the problem statement &lt;a href=&#34;http://ceoi2014.informatik-olympiade.de/wp-content/uploads/2014/06/carnival.pdf&#34;&gt;here&lt;/a&gt; and a place to submit the solution &lt;a href=&#34;https://oj.uz/problem/view/CEOI14_carnival&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After reading the problem statement it seems very smart to model it with a graph:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/teste.png&#34; alt=&#34;Testing&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every person is represented as a vertex in our graph.&lt;/li&gt;
&lt;li&gt;Every costume is represented by a color in our graph. Each vertex has only one color.&lt;/li&gt;
&lt;li&gt;Every vertex is part of a connected component of vertex with the same color. This connected component is a clique.&lt;/li&gt;
&lt;li&gt;When we organize a party, we query the number of distinct colors of the set of vertices we chose.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Modeling the problem with the graph helps us arrive at the first partial solution:&lt;/p&gt;
&lt;h2 id=&#34;on2-queries--20-points&#34;&gt;O(N^2) queries : 20 points&lt;/h2&gt;
&lt;p&gt;A direct approach to solve the problem is to discover all the edges of the graph. To discover if there is an edge between two vertices, we organize a party with these two vertices. If there are two costumes, then they are of different colors and there is no edge. Otherwise, they share the same color and there is an edge between them.&lt;/p&gt;
&lt;h2 id=&#34;optimized-on2--100-points&#34;&gt;Optimized O(N^2) : 100 points&lt;/h2&gt;
&lt;p&gt;There are some optimizations to make the previous solution work faster.&lt;/p&gt;
&lt;p&gt;The first idea is to choose a head to each component we know so far and always ask questions with it . Because of the clique property, it does not matter which pair of vertices we query : any of them will  do the work. This saves lots of questions&lt;/p&gt;
&lt;p&gt;The second idea is to add vertices gradually. We will first query 1, then 2, 3 and so on. This allow us to the following query : organize a party with the H heads we know so far and the i-th vertex we are adding. If in this party there are H + 1 costumes, then we know that the i-th vertex has no edge to any of those heads and is therefore a head of its own component. In the other case there will be H costumes and we need to query all the possible edges to discover the component of the i-th vertex.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa0.png&#34; alt=&#34;First Step&#34;&gt;&lt;/p&gt;
&lt;p&gt;To make it clearer , see this example : we are adding vertex 6 and we know there are 4 head nodes : 1,3,4,5. If we organize the party and there are 5 costumes, then vertex 6 must have a color different from the other 4 vertices. In the other case, with 4 costumes, 6 must have the same color of one of those vertices. In that case, we find the color of 6 by testing an edge with each head.&lt;/p&gt;
&lt;p&gt;The number of queries is still quadratic because of the case were the i-th vertex is not a new head. However, the constant is heavily reduced. This probably was not the intended solution, but it works.&lt;/p&gt;
&lt;h2 id=&#34;onsqrtn--100-points&#34;&gt;O(N*sqrt(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/bucket.png&#34; alt=&#34;Splitting the nodes into buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;An idea to optimize the previous solution is to group the heads into buckets. We do the first query with all the H heads to discover wether the i-th vertex is a new head or not in the same way as before.&lt;/p&gt;
&lt;p&gt;But the second part changes. Instead of manually testing all edges with the heads, we group them into B buckets with H/B per bucket. Then we organized parties with the i-th vertex and all heads of each bucket. If there are H/B + 1 costumes, then we proceed to the next bucket. Otherwise, we test the edge with all the heads of this bucket.&lt;/p&gt;
&lt;p&gt;This gives B + H/B queries per vertex. The value of the that minimizes this sum is sqrt(H). Therefore we achieve the complexity of O(N*sqrt(N)), better than the last one.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;The title of this post includes &amp;ldquo;Divide and Conquer&amp;rdquo; and so far none of the solutions used it, so at some moment D&amp;amp;C must appear. This is the moment!&lt;/p&gt;
&lt;p&gt;The principle we will use is the same from the previous solutions. However, we will use it way more efficiently.  The idea of querying &lt;strong&gt;H&lt;/strong&gt; heads plus the i-th vertex and deciding wether or not there is a edge based on the answer will be our base.&lt;/p&gt;
&lt;p&gt;To start, we do the now usual query with all heads like in the previous solution.&lt;/p&gt;
&lt;p&gt;If there is an edge, then we start to use D&amp;amp;C. The &amp;ldquo;Divide&amp;rdquo; part of our algorithm will be to partition our set of heads in two halves, L and R and querying the heads of L and the i-th vertex.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa1.png&#34; alt=&#34;Splitting the node into halves&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Conquer&amp;rdquo; part of our algorithm is based on the result of our query and the fact that there is only one edge between the i-th vertex and the whole set. If that edge is on the set &lt;strong&gt;L&lt;/strong&gt;, then we can discard all the heads of &lt;strong&gt;R&lt;/strong&gt;. If that edge is not on that set, then it must be on &lt;strong&gt;R&lt;/strong&gt;,because there is exactly one edge so we discard all heads of &lt;strong&gt;L&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&#39;s make another example with adding 6 , knowing heads 1,3,4,5. We split the heads in {1,3} and {4,5} and do the query {1,3,6}. Suppose we received that there are 3 colors in the set. Then there is no edge between 6 and {1,3} and we now solve the problem with the set {4,5}.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa3.png&#34; alt=&#34;Next step of halving the set&#34;&gt;&lt;/p&gt;
&lt;p&gt;If we continue to do the procedure of discarding a half in each iteration, we will eventually reach our base case : the set has only one element. Therefore , there must be an edge between the i-th vertex and the last element.&lt;/p&gt;
&lt;p&gt;If we want to analyze the complexity , we must think about the depth of the recursion we designed. In each iteration, we discard &lt;strong&gt;H/2&lt;/strong&gt; heads so the depth will be at most &lt;strong&gt;log2(H)&lt;/strong&gt;. Thus the overall number of queries is &lt;strong&gt;O(N*log(N))&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;My implementation of this idea:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/c297207d7b297eb4ba829502125121f7.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Olympiad Solutions ![](/img/Badges/olympiad.svg)</title>
      <link>https://ivaniscoding.github.io/project/olympiad_solutions/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      <guid>https://ivaniscoding.github.io/project/olympiad_solutions/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>https://ivaniscoding.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://ivaniscoding.github.io/about/</guid>
      <description>&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;https://ivaniscoding.github.io/&lt;/title&gt;
    &lt;link rel=&#34;canonical&#34; href=&#34;{{ .Site.BaseURL }}&#34;/&gt;
    &lt;meta name=&#34;robots&#34; content=&#34;noindex&#34;&gt;
    &lt;meta http-equiv=&#34;content-type&#34; content=&#34;text/html; charset=utf-8&#34;/&gt;
    &lt;meta http-equiv=&#34;refresh&#34; content=&#34;0; url={{ .Site.BaseURL }}&#34;/&gt;
  &lt;/head&gt;
&lt;/html&gt;</description>
    </item>
    
  </channel>
</rss>
