<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>algorithms | Ivan Carvalho</title>
    <link>https://ivaniscoding.github.io/tags/algorithms/</link>
      <atom:link href="https://ivaniscoding.github.io/tags/algorithms/index.xml" rel="self" type="application/rss+xml" />
    <description>algorithms</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Mon, 01 Apr 2024 06:00:00 -0400</lastBuildDate>
    <image>
      <url>https://ivaniscoding.github.io/images/icon_hud7c04f8250daa34436c1572b3b03bb6e_328675_512x512_fill_lanczos_center_2.png</url>
      <title>algorithms</title>
      <link>https://ivaniscoding.github.io/tags/algorithms/</link>
    </image>
    
    <item>
      <title>How to survive coding interviews with a single line of Python code</title>
      <link>https://ivaniscoding.github.io/posts/codeinterview/</link>
      <pubDate>Mon, 01 Apr 2024 06:00:00 -0400</pubDate>
      <guid>https://ivaniscoding.github.io/posts/codeinterview/</guid>
      <description>&lt;p&gt;Entering the world of coding interviews can be daunting. Whether you
are a recent graduate with a bachelor’s or master’s degree in Computer
Science or a senior industry professional, questions may arise with
regards to which programming language to use and which strategy to
follow before and during your coding interview.&lt;/p&gt;
&lt;p&gt;This guide will give a simple answer out of the many possible one for
that question.&lt;/p&gt;
&lt;p&gt;To keep things simple, I recommend the Python programming language.
And to keep our strategy even simpler, I recommend writing all your
solutions in a single line.&lt;/p&gt;
&lt;p&gt;Writing your code in one line can bring numerous benefits. Firstly,
if there is a bug, you don’t need to worry about which line of code the
error happened. Secondly, one line progams are concise. Combined with
the fact that Python is similar to plain English, this strategy helps
your interviewer understand your solution better. In fact, it is like
reading one very long sentence with many commas.&lt;/p&gt;
&lt;p&gt;Are you still stressed about the coding interview and in doubt on how
to code in a single line? You need not worry, because I will provide
examples and tips throughout the rest of this article.&lt;/p&gt;
&lt;h2 id=&#34;recursion-is-your-friend&#34;&gt;Recursion is your friend&lt;/h2&gt;
&lt;p&gt;Recursion is a powerful concept that allows us to reutilize code.
Hence, it fits perfectly with Python solutions using one line of
code.&lt;/p&gt;
&lt;p&gt;Let’s take for example the task of inverting a binary tree (&lt;a
href=&#34;https://leetcode.com/problems/invert-binary-tree/&#34;&gt;link&lt;/a&gt;). This
question is rumored to be a frequently asked questions for candidates
that write package managers for macOS.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/2bc07fa83e5547f4d541aadb85fd90d9.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;In the example above, recursion does most of the work. To invert a
binary tree, we swap the left and right nodes and then keep repeating
the process. Clear and concise.&lt;/p&gt;
&lt;h2 id=&#34;conditional-operators-are-helfpul&#34;&gt;Conditional Operators are
helfpul&lt;/h2&gt;
&lt;p&gt;This detail was also in the last code snippet, but we can discuss it
individually. Do not waste multiple lines writing &lt;code&gt;if&lt;/code&gt; and
&lt;code&gt;else&lt;/code&gt; statements! In fact, Python lets you write conditional
operators in a single line.&lt;/p&gt;
&lt;p&gt;Consider the following code that computes the depth of a binary tree
(&lt;a
href=&#34;https://leetcode.com/problems/maximum-depth-of-binary-tree&#34;&gt;link&lt;/a&gt;)
.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/f9f0f4e313c75513515695fd70a2ff62.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Thanks to conditional operators, your code fits concisely in one
line. The &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;else&lt;/code&gt; statements let you
handle correctly the base case for the recursion which is the empty tree
node.&lt;/p&gt;
&lt;h2 id=&#34;lambdas-are-powerful&#34;&gt;Lambdas are powerful&lt;/h2&gt;
&lt;p&gt;Lambdas, also known as anonymous functions, let us define Python
functions without wasting unnecessary lines.&lt;/p&gt;
&lt;p&gt;Take for example the task of finding the first palindrome in a list
(&lt;a
href=&#34;https://leetcode.com/problems/find-first-palindromic-string-in-the-array/&#34;&gt;link&lt;/a&gt;).&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/de20fcd81807250c6c3e26be1b807b28.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Thanks to the &lt;code&gt;lambda&lt;/code&gt; statement, we didn’t need to define
a separate function to check for palindromes
(&lt;code&gt;x == x[::-1]&lt;/code&gt;).&lt;/p&gt;
&lt;h2 id=&#34;the-walrus-is-a-must&#34;&gt;The Walrus is a must&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;I told you about the Walrus and me, man&lt;/p&gt;
&lt;p&gt;You know that we’re as close as can be, man&lt;/p&gt;
&lt;p style=&#34;text-align:right;&#34;&gt;
- The Beatles
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The walrus &lt;del&gt;was Paul&lt;/del&gt; was introduced in &lt;a
href=&#34;https://peps.python.org/pep-0572/&#34;&gt;PEP 572&lt;/a&gt;. Because the
feature landed in Python 3.8, it is higly likely that you can use it as
of 2024. The walrus lets us write less code, which is great.&lt;/p&gt;
&lt;p&gt;The true power of the walrus, however, appears when it is combined
with lambda functions, because it yields recursive lambdas. Now you
don’t need to waste a separate line to define a recursive function!&lt;/p&gt;
&lt;p&gt;Take for example the task to check if a binary tree is symmetric (&lt;a
href=&#34;https://leetcode.com/problems/symmetric-tree/&#34;&gt;link&lt;/a&gt;).&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/c0f65cbd52e496b2bc30f1db12044163.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;The lambda definition with the walrus operator
(&lt;code&gt;f := lambda&lt;/code&gt;) allows us to define a recursive function that
solves the problem in a single line. The code does not need to waste
lines in superfluous function definitions.&lt;/p&gt;
&lt;h2 id=&#34;the-standard-library-is-one-function-call-away&#34;&gt;The standard
library is one function call away&lt;/h2&gt;
&lt;p&gt;Python is known for its included batteries i.e. libraries that ship
with Python. They can be useful for coding interviews as well.&lt;/p&gt;
&lt;p&gt;There is a misconception that you need your &lt;code&gt;import&lt;/code&gt;
statement in a separate line. But that is not necessary due to the
&lt;code&gt;__import__&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;I demonstrate that in the solution for calculating the majority
element in an array (&lt;a
href=&#34;https://leetcode.com/problems/majority-element&#34;&gt;link&lt;/a&gt;) .&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/3d275126409348dbbd7ffea256ff848c.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Python has a built-in &lt;code&gt;Counter&lt;/code&gt; class that handles this
exact case. By using the standard library, we reused existing code and
made our solution simpler without having to sacrifice an extra line for
the import.&lt;/p&gt;
&lt;h2 id=&#34;the-wheel-can-be-reinvented&#34;&gt;The wheel can be reinvented&lt;/h2&gt;
&lt;p&gt;Sometimes your interviewer will explicitly forbid you from using the
standard library. In those cases, it is likely take you can write
similar code still in one line.&lt;/p&gt;
&lt;p&gt;Take for example the task of sorting an array from scratch (&lt;a
href=&#34;https://leetcode.com/problems/sort-an-array/&#34;&gt;link&lt;/a&gt;). We can
fit a Randomized Quicksort in one (very long) line.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/b95a3999a878e852e31ce1edda498d7b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;If the interviewer complains about using &lt;code&gt;random.randint&lt;/code&gt;
though, you can just read from &lt;code&gt;/dev/random&lt;/code&gt; instead. And if
they complain about opening &lt;code&gt;/dev/random&lt;/code&gt; with the Python
built-ins, you can use punched cards to execute code.&lt;/p&gt;
&lt;h2 id=&#34;believe-in-yourself&#34;&gt;Believe in Yourself&lt;/h2&gt;
&lt;p&gt;You might find harder questions along your coding interview journey.
Do not panic. Believe in yourself and keep going. Look at the following
solution for calculating block sums in a matrix (&lt;a
href=&#34;https://leetcode.com/problems/matrix-block-sum/&#34;&gt;link&lt;/a&gt;).&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/7e0e6cabbf051f0aee0b939a00fbd83b.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;Sometimes I’ll start a line of code and I don’t even know where it’s
going. I just hope I find it along the way. And pray there is no syntax
error.&lt;/p&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you have reached the end of the article, I want to kindly remind
you to read the date of the publication of this article. Happy Aрrіl
Fօօls’ Day! Do not take the content of this post seriously, it is all a
ʝοκе. The contents of this post do not reflect my employer’s opinion on
coding interviews. In fact, they don’t even represent mine.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Divide-and-conquer Techniques #1 - All But One Trick</title>
      <link>https://ivaniscoding.github.io/posts/dctrick1/</link>
      <pubDate>Sun, 03 Mar 2019 10:00:00 -0800</pubDate>
      <guid>https://ivaniscoding.github.io/posts/dctrick1/</guid>
      <description>&lt;p&gt;This is a post about one very interesting Divide-and-conquer technique. I call this the &amp;ldquo;All but one&amp;rdquo; trick because that&#39;s an accurate description
of what it can be used for. I learned about this in the &lt;a href=&#34;http://maratona.ic.unicamp.br/BrazilianICPCSummerSchool2018/&#34;&gt;Brazilian ICPC Summer School in 2018&lt;/a&gt;, thanks to &lt;a href=&#34;https://www.mimuw.edu.pl/~idziaszek/index.html&#34;&gt;Tomasz Idziaszek&lt;/a&gt; and thought it would be
a good addition to this blog. In this post, I will briefly explain the technique and show its application in one problem.&lt;/p&gt;
&lt;p&gt;This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Merge_sort&#34;&gt;Merge Sort&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search&#34;&gt;Binary Search&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;the-problem-it-solves&#34;&gt;The problem it solves&lt;/h1&gt;
&lt;p&gt;This trick is useful to solve the following kind of problem: Imagine there is a structure &lt;strong&gt;S&lt;/strong&gt; with &lt;strong&gt;N&lt;/strong&gt; elements. To build &lt;strong&gt;S&lt;/strong&gt;, you add elements one at a time. You would like to know what
&lt;strong&gt;S&lt;/strong&gt; would look like if, for each element, we considered &lt;strong&gt;S&lt;/strong&gt; without it. However, it is computationally expensive to remove an arbitrary single element.&lt;/p&gt;
&lt;p&gt;A naive approach to this problem that is very straightforward is to rebuild &lt;strong&gt;S&lt;/strong&gt; multiple times without each element. Even though this approach works,
a lot of computations are wasted because many times we have almost the same state for &lt;strong&gt;S&lt;/strong&gt;. After analyzing this, a question arises: is there a more efficient way to do it?&lt;/p&gt;
&lt;p&gt;If removing the last addition to &lt;strong&gt;S&lt;/strong&gt; is fast, then the answer is yes. It uses a clever observation that follows nicely into a Divide-and-Conquer Algorithm.&lt;/p&gt;
&lt;h1 id=&#34;the-algorithm&#34;&gt;The algorithm&lt;/h1&gt;
&lt;p&gt;The idea for the algorithm can be described as follows: if we have a set of &lt;strong&gt;N&lt;/strong&gt; elements, we split into two sets of roughly equal size. Then, for one of the halves, we will add all of its elements to &lt;strong&gt;S&lt;/strong&gt;. Notice that by doing this, we arrive at the same conceptual problem for the other half: find &lt;strong&gt;S&lt;/strong&gt; without a single element for each element.&lt;/p&gt;
&lt;p&gt;Hence, we can continue the procedure until we arrive with a set of a single element. When that happens, we can answer the query about &lt;strong&gt;S&lt;/strong&gt; without that element. The only missing point with that idea is that we need to answer the query for every element and not only for a single one. To solve this, we just need to change a few things when we recurse up.&lt;/p&gt;
&lt;p&gt;The changes are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Remove all additions that were made in the step when we recurse up.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add the elements of the half that were not added at first, and recurse to the half that was added at first.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lastly, we need to undo those add operations when we recurse back to maintain the fact that calling the Divide and Conquer function does not alter the state of &lt;strong&gt;S&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now the algorithm works because we can guarantee that we will arrive at a situation with a single element for every element and that when that happens all the other elements will have been added to &lt;strong&gt;S&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;If the operation of adding has a complexity of &lt;strong&gt;O(K)&lt;/strong&gt; and the operation of undoing has a complexity of &lt;strong&gt;O(L)&lt;/strong&gt;, then the algorithm has an overall complexity of &lt;strong&gt;O(N*(K+L)*log(N))&lt;/strong&gt;. A pseudo-implementation of the algorithm is given below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;void DivideAndConquer(int s, int e){

    // Base case: single element
    if(s == e){
        // Answer your query !
        return ;
    }

    int m = (s+e)/2; // we will split the set into two

    /* 
    First part: add elements of the right,
    recurse to the left and undo
    */

    for(int i = m+1; i&amp;lt;=e; i++){
        // Adding elements of the right half
        add(i);
    }

    DivideAndConquer(s, m); // recursing to the left half

    for(int i = e; i&amp;gt;=m+1; i--){
        // undo all the operations of addition
        undo();
    }

    /*
    Second part: add elements of the left,
    recurse to the right and undo
    */

    for(int i = s; i&amp;lt;=m; i++){
        // Adding elements of the left half
        add(i);
    }

    DivideAndConquer(m+1, e); // recursing to the right half

    for(int i = m; i &amp;gt;= s; i--){
        // undo all the operations of addition
        undo();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;example-problem&#34;&gt;Example Problem&lt;/h1&gt;
&lt;p&gt;The problem we will analyze is Voltage from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2014). You may find the problem statement and a place to submit &lt;a href=&#34;https://dunjudge.me/analysis/problems/763/&#34;&gt;here&lt;/a&gt; and the original problem statement in Japanese &lt;a href=&#34;https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d3.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : There is a circuit with &lt;strong&gt;N&lt;/strong&gt; nodes and &lt;strong&gt;M&lt;/strong&gt; resistors. Each node can be set either to low or high voltage, and current cannot flow through resistors connected to nodes of the same voltage. Calculate how many resistors can be removed such that if we remove only that resistors, there is current flowing in all other resistors.&lt;/p&gt;
&lt;h1 id=&#34;reduction-to-the-trick-and-solution&#34;&gt;Reduction to the trick and solution&lt;/h1&gt;
&lt;p&gt;The problem can be reduced to the following one: check if without an edge &lt;strong&gt;E&lt;/strong&gt;, the graph is bipartite.&lt;/p&gt;
&lt;p&gt;The structure to verify if a graph is bipartite while adding edges is a modified &lt;a href=&#34;https://en.wikipedia.org/wiki/Disjoint-set_data_structure&#34;&gt;Disjoint Set Union-Find&lt;/a&gt;. I will not be going into many details, but you may find more explanation about it in this &lt;a href=&#34;https://discuss.codechef.com/questions/131944/bipartite-checking-using-dsu&#34;&gt;CodeChef discussion&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Removing an arbitrary edge from the DSU is fairly difficult, but removing the last one is not due to the stack-like structure of the DSU. Hence, the problem we have fits in the range of the applications of the trick and can be solved in &lt;strong&gt;O(N*log(N)^2)&lt;/strong&gt;. The implementation using the technique follows:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/d435ce4634fd54ff99428ee15e9730d7.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #6 - Amusement Park</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory6/</link>
      <pubDate>Tue, 28 Aug 2018 14:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory6/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory5/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Amusement Park from the Japanese Olympiad in Informatics Open Contest (JOI Open 2017). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI17_amusement_park&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : You are given a connected graph of N vertices and M edges (60 &amp;lt;= N &amp;lt;= 10000, M &amp;lt;= 20000) . JOI-kun must tell the integer X ( 0 &amp;lt;= X &amp;lt;= 2^60 - 1) to IOI-chan, but he cannot do that directly. Instead, he will write either 0 or 1 in each vertex.  IOI-chan can read the integer written on the vertex currently at and move to any adjacent vertex. Help IOI-chan discover X by using the smallest possible number of movements. You must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the structure of the graph and the integer X, writes 0 or 1 on each vertex. Note that JOI-kun does not know the starting vertex of IOI-chan.&lt;/li&gt;
&lt;li&gt;One that given a starting vertex and the graph structure, uses the least number of moves such that with the integers written on the visited vertices it can recover the integer X.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The scoring of the subtasks is based on the maximum number of moves IOI-chan does. In order to score 100 points, you must find a solution that uses at most 120 moves.&lt;/p&gt;
&lt;p&gt;I will not discuss the first subtasks because I found a solution that in my opinion is conceptually simple (it is basically a DFS) and already scores 78 points going up to subtask 4. Thus, we will discuss the DFS idea and the final solution.&lt;/p&gt;
&lt;h2 id=&#34;a-dfs-approach--78-points&#34;&gt;A DFS approach : 78 points&lt;/h2&gt;
&lt;p&gt;There are some initial steps that are common to almost all approaches to this problem. They are necessary in order to solve the problem because they take care of the basic : how to send X with 0&#39;s and 1&#39;s&lt;/p&gt;
&lt;p&gt;The idea is : we will have to use the binary encoding of X to send it with 0&#39;s and 1&#39;s. The strategy will be as follows : we will assign for each vertex which of the 60 bits it represents; we must find a procedure that produces the same result for IOI-chan and JOI-kun, because we need to be sure that we are correctly receiving the message.&lt;/p&gt;
&lt;p&gt;The next step of this idea is : we need to find an efficient way of moving between the vertices such that we can recover the 60 bits quickly. When we get all the bits, we stop moving and report X. In order to achieve this, we have to also think about the way we assign the bit for each vertex, because this assignment heavily impacts in the number of movements.&lt;/p&gt;
&lt;p&gt;The final step is : it is easier to solve this problem on a tree. Because of the tree properties, it is simple to find a correct way to assign the bits to the vertices and it is less complicated to decide where to move compared to a general graph. Due to the fact that our graph is connected, we can always find a spanning tree of the graph and transform the general graph into a tree.&lt;/p&gt;
&lt;p&gt;An algorithm that finds a spanning tree and also finds an efficient way of choosing the bits is the Depth-First Search. Let&#39;s take a look :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory6/amusement.png&#34; alt=&#34;DFS Tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;We start the algorithm by doing the DFS from any vertex of the graph. There are two key ideas that make the algorithm efficient:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If a vertex was the (i)-th vertex to be discovered by the DFS, we define its discovery time as (i - 1). The bit that we will assign for this vertex will be (i - 1) modulo 60.&lt;/li&gt;
&lt;li&gt;We keep the edges used to discover of a new vertex as the edges of our spanning tree. Thus, we build the tree as we assign the bits&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By doing that, the only remaining step is to find an efficient way to move in order to quickly discover all the 60 bits.&lt;/p&gt;
&lt;p&gt;However, the way we move will also be heavily inspired by the DFS. Suppose that we are currently at a vertex v and let T be the subtree of v considering that the tree is rooted at the starting vertex of the DFS. There are two cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The size of T is bigger than or equal to 60. We just follow the DFS order and stop when all the 60 bits are found.&lt;/li&gt;
&lt;li&gt;The size of T is smaller than 60. We follow the DFS order and then return to the parent vertex of v, p. In p we do something similar but in a different order : instead of following the DFS from the first discovered child, we follow the DFS order from v and consider the array of children to be circular. Let&#39;s exemplify : if [1,2,3,4] was the ordering and you came from 3, them the order will be [3,4,2,1].&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This algorithm uses at most 160 movements and scores 78 points. It was harder to think and explain the algorithm then to implement it. You may find the partial solution &lt;a href=&#34;https://oj.uz/submission/69340&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;a-smart-subtree-approach--100-points&#34;&gt;A smart subtree approach : 100 points&lt;/h2&gt;
&lt;p&gt;In the final solution, we will also stick to the idea of solving the problem on a tree and reducing a general graph to its spanning tree. However, we will tweak the moving part of our algorithm to be more efficient.&lt;/p&gt;
&lt;p&gt;From now on, when we talk about subtrees , think of them as a connected acyclic subgraph rather than a subtree of a rooted tree. Suppose that we have a subtree of exactly 60 vertices . If we run the DFS algorithm on this subtree, we will be able to find X with 120 moves or less for all the vertices of the subtree.&lt;/p&gt;
&lt;p&gt;If we could assign for each vertex a subtree of size 60 such that all the bits of X are represented in the subtree, then our problem is solved. Let&#39;s focus on finding a way of doing that.&lt;/p&gt;
&lt;p&gt;Suppose we have already found the spanning tree and found an arbitrary subtree T of size 60. For all vertices of the subtree, we assign T as its subtree. Then, we will try to assign a subtree to the neighbors of the vertices of the subtree that have not yet been assigned a subtree.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory6/amusement1.png&#34; alt=&#34;Limited Subtree&#34;&gt;&lt;/p&gt;
&lt;p&gt;The idea is as follows. Let u be the vertex without an assigned subtree and v its neighbor that has been assigned the subtree T. To find subtree for u, we copy T and remove an arbitrary leaf of the tree that is not v. Then, we connect u to v in the new subtree T* and assign the bit of the removed leaf to u. The image above shows this idea for a smaller subtree : we pick any of the leaves (in this it was the one numbered 6, but it could be 5) and remove it. Then, we connect the new vertex to its neighbor in the subtree an assign the 6th bit to the new vertex.&lt;/p&gt;
&lt;p&gt;We must run the routine above until all vertices are assigned a subtree. Because the graph is connected, it will always be possible to assign a subtree to each vertex.&lt;/p&gt;
&lt;p&gt;In the decoding part as IOI-chan , we run the DFS idea from our previous algorithm in the subtree of the starting vertex. IOI-chan will make at most 120 moves.&lt;/p&gt;
&lt;p&gt;In my final implementation, I opted to use a BFS to generate a spanning tree instead of the DFS. Despite that, the algorithm is exactly the same as the one described above.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/f783667abfc69916405b6ffe4ace99c5.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #5 - City</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory5/</link>
      <pubDate>Mon, 27 Aug 2018 22:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory5/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory4/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is City from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2017). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI17_city&#34;&gt;here&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you are given a rooted tree of N vertices (N &amp;lt;= 250000) that has a depth that is at most 18. You must write an integer on each node so that given only the integers written on X and Y, without knowing the structure of the tree, you can answer the question : is X on the path from Y to the root, Y on the path from X to the root or neither of them?&lt;/p&gt;
&lt;p&gt;The scoring of the problem is based on the maximum integer you write on each node. There is also a subtask for N &amp;lt;= 10.&lt;/p&gt;
&lt;h2 id=&#34;subtask-1--n--10-8-points&#34;&gt;Subtask 1 : N &amp;lt;= 10 (8 points)&lt;/h2&gt;
&lt;p&gt;In this subtask, the graph is small and the maximum integer does not matter as long it is smaller than 2^60 - 1.&lt;/p&gt;
&lt;p&gt;Because of this, we may choose a suboptimal strategy to solve the problem. The simplest one is to encode the vertex and the whole adjacency matrix on the integer we send.&lt;/p&gt;
&lt;p&gt;We use the binary encoding to send the current node (this uses 4 bits) and use another 45 bits to send the matrix. Then, we run a DFS to see which case happens&lt;/p&gt;
&lt;h2 id=&#34;l--236---1--22-points&#34;&gt;L &amp;lt;= 2^36 - 1 : 22 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory5/city0.png&#34; alt=&#34;Euler Tour on a Tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;With very big N, it is impossible to send the adjacency matrix. So we will focus on another technique to solve the problem.&lt;/p&gt;
&lt;p&gt;This technique is commonly called &amp;ldquo;Euler Tour on a Tree&amp;rdquo; , even tough it is not exactly an Euler Tour. You can interpret it as noticing a special property of the initial and final time when you do a DFS on the tree.&lt;/p&gt;
&lt;p&gt;The image above represents the &amp;ldquo;Euler Tour&amp;rdquo;. Every time you enter a vertex v, you increase the DFS counter and says this is number is the start time of v . At the end of the DFS on v, we also save the DFS counter and says it is the end time of v. The vector in the image represents this DFS ordering.&lt;/p&gt;
&lt;p&gt;The cool thing about this is that it allows us to check if a vertex u is on the subtree of a vertex v easily. Because the vertices of the subtree form a contiguous subarray in the DFS order array, we can simply check if the start of u is contained in the interval [s,e] where s is the start time of v and e the end time of v.&lt;/p&gt;
&lt;p&gt;If you think a little bit about it, checking if a vertex v is on a subtree of another is exactly the same as checking if that another vertex is on the path from v to the root. So we found a solution to the problem we want to solve!&lt;/p&gt;
&lt;p&gt;For each vertex, we send an integer that represents the start and end time of the DFS. To do that, we send 18 bits for the start and another 18 bits for the end. In the decoding part, we simply recover the starts and ends and run the interval check described above.&lt;/p&gt;
&lt;p&gt;The maximum number if 2^36 - 1 , thus we score 22 points.&lt;/p&gt;
&lt;h2 id=&#34;an-unused-property&#34;&gt;An unused property&lt;/h2&gt;
&lt;p&gt;So far we did not the property that the depth of the tree is at most 18. The solution described above works for any tree, and therefore does not exploit the special property of the depth.&lt;/p&gt;
&lt;p&gt;Because the maximum depth is 18, every node has at most 18 ancestors and is therefore contained in at most 18 intervals. Thus, the sum of the lengths of all intervals is at most 18*N. So on average each interval is at most 18. That is not much.&lt;/p&gt;
&lt;p&gt;It seems to be a waste to send 18 bits of the end when we could send the size, which is on average 5 bits. So we will do exactly that : instead of sending the end, we send the size of the interval.&lt;/p&gt;
&lt;p&gt;This optimization alone does not affect our punctuation, because there are causes in which we will still send integers up to 2**36 - 1. However, this idea is a crucial step to solve the problem.&lt;/p&gt;
&lt;h2 id=&#34;an-efficient-way-of-sending-the-size--100-points-solution&#34;&gt;An efficient way of sending the size : 100 points solution&lt;/h2&gt;
&lt;p&gt;We need to optimize the way we send the size. In a perfect environment, we could create a smaller dictionary that represented the sizes and send the position in that dictionary.&lt;/p&gt;
&lt;p&gt;However, it is difficult to adjust a dictionary to the sizes of the interval. We will try a different approach : adjust the interval size to the dictionary. But how do we do that ?&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory5/city1.png&#34; alt=&#34;Dummy Nodes&#34;&gt;&lt;/p&gt;
&lt;p&gt;Suppose that the interval size is a. How do we fit that size to the dictionary , if it is not in it? Let b be the smallest integer of the dictionary greater than our equal to a. We can always add some extra leaves as dummy vertices in order to reach the size b. The image above exemplifies that, by adding two leaves to reach the size 5 from the original size 3.&lt;/p&gt;
&lt;p&gt;In practice, we are adding empty spaces to our DFS array. The challenge now is to build that dictionary of sizes.&lt;/p&gt;
&lt;h2 id=&#34;building-the-dictionary--100-points-solution&#34;&gt;Building the dictionary : 100 points solution&lt;/h2&gt;
&lt;p&gt;The challenge of finding a dictionary of sizes is that it should not add many extra vertices, because in that case the start of the vertices would be big and thus the dictionary would need to be small.&lt;/p&gt;
&lt;p&gt;If the total number of vertices (original and dummy) of the final solution is close to 2^K, then we must construct a dictionary of size 2^(28 - K) .&lt;/p&gt;
&lt;p&gt;Additionally , this dictionary should vary gradually. A function that varies gradually is a power function, so we can describe our dictionary as a set of {r^0, r^1, r^2&amp;hellip;} for some number r. The optimal r is the solution for r^(2^(28 - K)) = 2^K&lt;/p&gt;
&lt;p&gt;If you experiment with K, you may find that K = 20 is a good choice. Therefore, the maximum number of vertices if 2^20 and the dictionary size is 2^8 = 256.&lt;/p&gt;
&lt;p&gt;The value of r is 2^(20/256) ≈ 1.055645 (we must truncate because we cannot represent an irrational number in an exact decimal form).&lt;/p&gt;
&lt;p&gt;Because r is not an integer, our dictionary is not exactly described by a power function, but by an approximation. Let A be our dictionary and a0 = 0 the first element. We say that ai = max{ a(i-1) + 1, ai*r } , where ai*r is rounded down.&lt;/p&gt;
&lt;p&gt;In the final code, I opted to send the difference between the start and the end instead of the size. The result is identical, tough.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/ae0fb800f1e113807aee2a2804132aa3.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #4 - Airline Route Map</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory4/</link>
      <pubDate>Sun, 26 Aug 2018 20:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory4/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory3/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Airline Route Map from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI18_airline&#34;&gt;here&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : Alice needs to send to Bob an undirected graph of N vertices (N &amp;lt;= 1000) and M edges (M &amp;lt;= N*(N-1)/2). However, the information Alice sends suffers a series of shuffles before Bob receives it&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The number of the vertices are changed. So each of the N vertices will receive a new unique number from 0 to N-1.&lt;/li&gt;
&lt;li&gt;The edge list is shuffled. The edges remain consistent to the information you sent (if you sent A-&amp;gt;B, then it will mean A* -&amp;gt; B*, where A* and B* are the new numbers for A and B) , but their order on the edge list is not the same.&lt;/li&gt;
&lt;li&gt;The direction of the edge is changed. If it was A-&amp;gt;B , then you may receive A*-&amp;gt;B* or B*-&amp;gt;A*&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You may add or remove vertices and edges when you are sending the graph as Alice. When Bob receives the shuffled information, he needs to recove the original graph Alice wanted to send. You must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the undirected graph we want to send, generates a new graph and sends it.&lt;/li&gt;
&lt;li&gt;One that given the shuffled sent graph, recovers the original one
The scoring is based on the number of extra vertices you sent. The final subtasks uses only 12 extra vertices to recover the graph.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This time I will not focus on the subtasks but only at two solutions : one that uses 13 vertices and the improvement of this solution that uses 12 vertices.&lt;/p&gt;
&lt;h2 id=&#34;a-question--add-or-remove-edges-&#34;&gt;A question : add or remove edges ?&lt;/h2&gt;
&lt;p&gt;We are allowed to send any graph, so we must choose if we will add or remove edges (or do both). It turns out that it is very hard to recover information of edges that were not sent using few additional vertices. So it is better to send the original graph with some additional vertices that will help to recover the original numbering of the vertices.&lt;/p&gt;
&lt;h2 id=&#34;first-step--how-to-recover-the-numbers-&#34;&gt;First step : how to recover the numbers ?&lt;/h2&gt;
&lt;p&gt;The first challenge is to recover the original numbers with such few extra vertices. This requires an efficient way of sending information.&lt;/p&gt;
&lt;p&gt;It turns that sending the binary representation of the numbers is a good idea. To do that, we create 10 extra vertices, one for each possible set bit of a number. Then, we connect the i-th extra vertex to the numbers whose i-th bit is set.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline0.png&#34; alt=&#34;Connection to bits&#34;&gt;&lt;/p&gt;
&lt;p&gt;The image above does not show all the bits, but represent the connections of vertex 6 : it has an edge to the vertices that represent 2^1 and 2^2, but not to the one that is 2^0.&lt;/p&gt;
&lt;h2 id=&#34;second-step--identifying-the-bit-vertices&#34;&gt;Second step : identifying the bit vertices&lt;/h2&gt;
&lt;p&gt;The next challenge is to identify those special vertices. My idea to solve this was to create an additional vertex that is connected to all vertices of the graph, except to the bit ones.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline1.png&#34; alt=&#34;Additional vertex connected to everything except bits&#34;&gt;&lt;/p&gt;
&lt;p&gt;In addition to that, I also connected the bit vertices to form a chain , connecting the i-th one to the (i+1)-th one.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline2.png&#34; alt=&#34;Bit chain&#34;&gt;&lt;/p&gt;
&lt;p&gt;So now we only need to identify the 10th bit vertex and the special vertex that is connected to all the nodes. If we do that, we can always discover the next bit of the chain and we have solve our problem.&lt;/p&gt;
&lt;h2 id=&#34;third-step--identifying-the-last-bit-vertex-and-the-special-vertex&#34;&gt;Third step : identifying the last bit vertex and the special vertex&lt;/h2&gt;
&lt;p&gt;We have already used 11 extra vertices, so we do not want to use a lot more in order to identify these two vertices. So we must find some special property or implicit information that can helps us decode without sending many vertices.&lt;/p&gt;
&lt;p&gt;One important piece of information that we have not used so far is the degree of the vertices. If we analyze the degrees, we discover an important property : for N &amp;gt;= 3, all of the vertices but two will always have their degree bigger than or equal to 2. The only two vertices that sometimes can break the rule are the vertex 0, when it does not have any edge in the original graph,  and the 10th bit vertex when N &amp;lt;= 512.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory4/airline3.png&#34; alt=&#34;A trick for the two cases&#34;&gt;&lt;/p&gt;
&lt;p&gt;Therefore, it is a good idea to use two extra vertices with degree one to try identify the special and bit vertex, because they will be unique in our graph. With the extra one degree vertex, the 10th bit vertex no longer can have a degree one. The only remaining vertex that can mess up with our idea is 0.&lt;/p&gt;
&lt;p&gt;However, it is easy to overcome the problem with 0 : we can simply make the graph 1-indexed instead of 0-indexed. That way, 0 will become one and have a set bit, thus having a degree of at least two.&lt;/p&gt;
&lt;p&gt;In the end , we do as follows : we make the graph 1-indexed and add the two 1-degree vertices. Then , we identify the two vertices that are connected to the 1-degree vertices and distinguish the special vertex based on the degree (the special one will always have more edges). Then , we process our chain of bits, discover the original numbering for each vertex and report the original graph. This algorithm uses 13 additional vertices and scores 91 points, which is a very good result.&lt;/p&gt;
&lt;h2 id=&#34;fourth-step--final-optimization&#34;&gt;Fourth step : final optimization&lt;/h2&gt;
&lt;p&gt;In order to fully solve the problem, we must get rid of exactly one extra vertex. Therefore, we will need to use again implicit information that we did not use before.&lt;/p&gt;
&lt;p&gt;It turns out that we do not need the 1-degree vertex to identify the last bit vertex. Of all the bit vertices (that can be easily identified because of the special vertex), it will always be the one that has the smallest degree.&lt;/p&gt;
&lt;p&gt;Because of that, we drop the 1-degree vertex that connects to the last bit and tweak the algorithm we used before. Notice that by doing this, the 10th bit vertex can sometimes have only one edge, but with some thinking we can handle this case.&lt;/p&gt;
&lt;p&gt;In my implementation of this idea, I hard coded small cases to avoid corner cases. The remaining part of the code implements exactly the same idea as described above.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/32cb88cb0ae2c60ee4d2e42b8bfdfef3.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #3 - Broken Device</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory3/</link>
      <pubDate>Sat, 25 Aug 2018 12:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory3/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory2/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Broken Device from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2017). You may find the problem statement and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI17_broken_device&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : Anna wants to send a 60-bit integer to Bruno. She has a device that can send a sequence of 150 numbers that are either 0 or 1. The twist is that L (0 &amp;lt;= L &amp;lt;= 40) of the positions of the device are broken and can only send 0. Bruno receives the sequence Anna sent, but the does not know the broken positions. You must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the integer X we want to send and the K broken positions, generates a sequence of length 150 that can be decoded.&lt;/li&gt;
&lt;li&gt;One that given the sequence generated by the previous procedure, decodes the integer X without knowing the K broken positions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The subtasks are based on the maximum number of broken positions your algorithm can handle. Let&#39;s see some ideas for different K&#39;s.&lt;/p&gt;
&lt;h2 id=&#34;k--0--0-points&#34;&gt;K = 0 : 0 points&lt;/h2&gt;
&lt;p&gt;This is not a subtask, but you need to know how to solve this case in order to solve the full problem. The idea is very simple : send the binary encoding of X. We will use the binary encoding in all other subtasks , but you need to keep this idea in mind.&lt;/p&gt;
&lt;p&gt;We use the first 60 positions to send the encoding and leave the other 90 unused.&lt;/p&gt;
&lt;h2 id=&#34;k--1--8-points&#34;&gt;K = 1 : 8 points&lt;/h2&gt;
&lt;p&gt;Because there is a broken place, we might not be able to send X using the 60 first positions. However, it will not be difficult to overcome that.&lt;/p&gt;
&lt;p&gt;The key idea is to send a signal meaning that this is the place the binary representation starts. That is, the first number 1 of the sequence will mean &amp;ldquo;The following 60 numbers are the binary encoding of X&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;In order to use this idea, we need to be sure that there will 61 adjacent positions that are not broken. Because K = 1, we know that this is true.&lt;/p&gt;
&lt;h2 id=&#34;k--15--41-points&#34;&gt;K = 15 : 41 points&lt;/h2&gt;
&lt;p&gt;We will use a different strategy to send the binary encoding of X. The first step of our algorithm is to divide our 150 sequence into 75 buckets of size 2. The image bellow represents this idea , where grey is &amp;ldquo;0&amp;rdquo; and black is &amp;ldquo;1&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory3/broken0.png&#34; alt=&#34;Buckets of size 2&#34;&gt;&lt;/p&gt;
&lt;p&gt;This will allow us to use an encoding that is less affected by the broken places, because we will not need that a lot of adjacent non-broken positions.&lt;/p&gt;
&lt;p&gt;Our encoding will use every 2 positions to send at most one bit. Notice that sometimes we may not send any information because of the broken places, but that is okay.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory3/broken1.png&#34; alt=&#34;Table encoding for buckets of size 2&#34;&gt;&lt;/p&gt;
&lt;p&gt;We will send the bits in order. If we receive &amp;ldquo;00&amp;rdquo;, then we did not send any information. If we receive &amp;ldquo;10&amp;rdquo;, this means that the next bit is &amp;ldquo;0&amp;rdquo;, and if we receive &amp;ldquo;11&amp;rdquo;, this means that the next bit is &amp;ldquo;1&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;By using this encoding , we can send up to 75 bits if there weren&#39;t any broken places. When there is at least one broken position in a bucket, in the worst case, we lose that bucket.&lt;/p&gt;
&lt;p&gt;Considering we need to send 60 bits, we can afford to lose up to 15 buckets. So we solve to K up to 15.&lt;/p&gt;
&lt;h2 id=&#34;intermediary-ks--41-points&#34;&gt;Intermediary K&#39;s : 41+ points&lt;/h2&gt;
&lt;p&gt;We can improve the previous solution to handle more broken positions.&lt;/p&gt;
&lt;p&gt;The first improvement is to find a meaning for &amp;ldquo;01&amp;rdquo;, something that we did not. By meaning we are not only talking about &amp;ldquo;1&amp;rdquo; or &amp;ldquo;0&amp;rdquo;, but other creative ideas like repeating previous numbers.&lt;/p&gt;
&lt;p&gt;The second improvement is to use randomization in order to avoid the worst case of our algorithm:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We may shuffle the position of the bits, in order to prevent the worst case where each broken position is on a different bucket&lt;/li&gt;
&lt;li&gt;We may change the integer we are sending by XORing it with a random number. This prevents cases where all numbers are 1 or 0, which can be bad for some ideas. To recover the original integer on the decoding part, we simply XOR the number we found with the random number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We need to carefully implement these ideas because we need to be able to revert the changes in the decoding part.&lt;/p&gt;
&lt;h2 id=&#34;k--40--100-points&#34;&gt;K = 40 : 100 points&lt;/h2&gt;
&lt;p&gt;The final solution is somewhat similar to the 41 points solution, but instead uses buckets of size 3.&lt;/p&gt;
&lt;p&gt;With buckets of size 3 , we can create an encoding that sends up to 2 bits per bucket. Inefficient implementations of this idea do not score full points, but do better than the 41 point solution. I will go straight to the efficient implementation of the idea, but you may take sometime to create a encoding on your own.&lt;/p&gt;
&lt;p&gt;Because of the size, we will use a encoding-table that is more resistant to broken places. The special property of the table is that it will allow us to send 2 bits of information in the case there are no broken places and 1 bit of information in the case there is one broken place.&lt;/p&gt;
&lt;p&gt;Because of that, we can always send 60 bits regardless of the configuration. One possible table is the following :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory3/brokenf.png&#34; alt=&#34;Optimal table for size 3 buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;My implementation of this idea:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/60aa5d68fe46012bd812564bc7b74f42.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #2 - Navigation</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory2/</link>
      <pubDate>Fri, 24 Aug 2018 17:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory2/</guid>
      <description>&lt;p&gt;I am writing a series of posts about Information Theory problems. You may find the previous one &lt;a href=&#34;https://ivaniscoding.github.io/posts/informationtheory1/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Navigation from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2015). You may find the problem statement and a place to submit &lt;a href=&#34;https://dunjudge.me/analysis/problems/762/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : Anna lives in an island that is part of the IOI islands, that can be represented by an acyclic connected graph. Bruno will visit Anna, but he does not know the whole structure of the tree. He only knows the adjacent islands to the island he is currently at. To help Bruno , Anna will write an integer on each island such that Brunno can go to Anna&#39;s island using the short possible path.&lt;/p&gt;
&lt;p&gt;We must submit two files:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;One that given the structure of the tree and the island Anna lives, writes a number on each island&lt;/li&gt;
&lt;li&gt;One that given the current island and its number, the adjacent islands to that island and their respective number, goes from that island to the one closest to Anna&#39;s island. In the case Bruno is already on Anna&#39;s island, you must not move.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The subtasks are based on the maximum number you wrote on the vertices of the tree.&lt;/p&gt;
&lt;h2 id=&#34;subtask-1--no-restrictions&#34;&gt;Subtask 1 : No restrictions&lt;/h2&gt;
&lt;p&gt;For all subtasks , we will root the tree at Anna&#39;s island.&lt;/p&gt;
&lt;p&gt;The idea for this subtask is to write on each node its distance from the root of the tree when we are encoding. The image above exemplifies this idea.&lt;/p&gt;
&lt;p&gt;When we are decoding, we just go to the node whose number is the smallest.&lt;/p&gt;
&lt;h2 id=&#34;subtask-2--use-numbers-0-1-and-2&#34;&gt;Subtask 2 : use numbers 0, 1 and 2&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory2/navigation0.png&#34; alt=&#34;Level-tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;We need to use something completely different from our previous solution.&lt;/p&gt;
&lt;p&gt;Instead of writing the distances, we will create a table telling wether we should or shouldn&#39;t go to a node based on the number of the current node.&lt;/p&gt;
&lt;p&gt;This table should be complementary : if 0-&amp;gt;1 means go, 1-&amp;gt;0 means do not go. Because of that, we discard 0-&amp;gt;0 , 1-&amp;gt;1 and 2-&amp;gt;2. Even tough we have 6 possibilites, it is possible to find a table that does what we want.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/InformationTheory2/tabela.png&#34; alt=&#34;Table of wheter go or not&#34;&gt;&lt;/p&gt;
&lt;p&gt;To mark each node with the correct integer, we start by doing a DFS from the root. We can choose any integer for the root, so we choose 0 . At each step, we write for the children of our current vertex the number such that it means &amp;ldquo;Don&#39;t go&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;Decoding is easy because of the table. The only case we need to be aware is for the root, because in that case we will find only &amp;ldquo;Don&#39;t go&amp;rdquo;, so we must return the own vertex in that case.&lt;/p&gt;
&lt;h2 id=&#34;subtasks-3-and-4--0-and-1&#34;&gt;Subtasks 3 and 4 : 0 and 1&lt;/h2&gt;
&lt;p&gt;With only two numbers , it is impossible to find a table like the previous one. In order to solve the problem , we must try a different strategy or find some implicit information that we have not used so far.&lt;/p&gt;
&lt;p&gt;In this case, we will go with the second option. At the current point, we have not taken advantage of the fact that the number of the vertices remain the same. That is a lot of information !&lt;/p&gt;
&lt;p&gt;Our previous solution relied heavily on the idea of the complementary table. We need to find some information that is complementary and uses the number of the vertices.&lt;/p&gt;
&lt;p&gt;An operator that does exactly that is the less than operator. If  (a &amp;lt; b) equals true, then (a &amp;gt; b) equals false. This was the implicit information we were looking for.&lt;/p&gt;
&lt;p&gt;In order to decide wether we should or shouldn&#39;t go from vertex A to B, we will calculate the following value : v = (integer written on A) + (integer written on B) + (A &amp;lt; B). If v is an even number, then we do not go. If v is an odd number, then we go.&lt;/p&gt;
&lt;p&gt;Because of the complementary nature of the less operator, if v means &amp;ldquo;Go&amp;rdquo; to A, then it will mean &amp;ldquo;Don&#39;t go&amp;rdquo; to B.&lt;/p&gt;
&lt;p&gt;To mark the correct integer on each node, we start by doing a DFS from the root. For each children, we choose the correct integer such that we write &amp;ldquo;Don&#39;t go&amp;rdquo; from the current node.&lt;/p&gt;
&lt;p&gt;Even tough there was a lot of thinking , the final code is very simple. Wow!&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/7d5609cd161b9abed9a65185fc30dc89.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Information Theory #1 - Coins</title>
      <link>https://ivaniscoding.github.io/posts/informationtheory1/</link>
      <pubDate>Fri, 24 Aug 2018 13:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/informationtheory1/</guid>
      <description>&lt;p&gt;Information Theory problems are not common and that is why I am writing about them.&lt;/p&gt;
&lt;p&gt;They generally consist of two parts : encoding and decoding. It seems to be simple in theory, but problem setters get very creative when adding restrictions that make simple things hard.&lt;/p&gt;
&lt;p&gt;Each problem is unique, however there are some aspects that seem to be shared by many problems:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is important to know what you need to send&lt;/li&gt;
&lt;li&gt;It relevant to know which information will be available to both the encoder and decoder&lt;/li&gt;
&lt;li&gt;Binary encoding is an efficient way of sending data&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The problem we will analyze is Coins from the Practice Section of the International Olympiad in Informatics (IOI 2017 Practice). You may find the problem statement and a place to submit &lt;a href=&#34;https://dunjudge.me/analysis/problems/1663/&#34;&gt;here&lt;/a&gt; . I have chosen this one because it is neither too easy nor too hard, so it is the ideal one to start.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have a number C (0 &amp;lt;= C &amp;lt; 64) and an array of 64 numbers that are either 0 or 1. In the encoding part, you may change the status of at least one number and at most K numbers of the array. In the decoding part, you receive the array already with the changes and you must answer the number C.&lt;/p&gt;
&lt;p&gt;We will focus on the subtasks 3, 4 and 5.&lt;/p&gt;
&lt;h2 id=&#34;subtask-3--k--64&#34;&gt;Subtask 3 : K = 64 &lt;/h2&gt;
&lt;p&gt;The idea of this task is to calculate the number C by the number of 1&#39;s in the array. Thus, we flip 0&#39;s to 1&#39;s until we have C 1&#39;s in our array.&lt;/p&gt;
&lt;p&gt;Notice that we must always flip at least one coin. So in the case the number of 1&#39;s is already equal to C, we need to flip the same coin twice.&lt;/p&gt;
&lt;h2 id=&#34;subtask-4--k--8&#34;&gt;Subtask 4 : K = 8&lt;/h2&gt;
&lt;p&gt;The idea above wastes lots of implicit information that is shared between the encoder and decoder. In order to reduce the number of flips, we must use that information.&lt;/p&gt;
&lt;p&gt;Because the position of the numbers of the array do not change, we can use the first 8 coins to send the binary representation of the number C. So we need to flip at most 8 coins, and not 64 like before.&lt;/p&gt;
&lt;p&gt;Notice again that in the case the 8 first coins already correspond to the binary encoding of C, we need to flip the same coin twice because we must flip some coin.&lt;/p&gt;
&lt;h2 id=&#34;subtask-5--k--1&#34;&gt;Subtask 5 : K = 1&lt;/h2&gt;
&lt;p&gt;Honestly, I was a bit surprised when the problem asked for a solution that uses only one coin flip. I did not expect such a efficient solution at first. However, after thinking about some bitwise operators, I was able to design an algorithm that did the job.&lt;/p&gt;
&lt;p&gt;Firstly , we will need to define a new decoding function for the array. This function may seem a little bit strange at first, but is has a very special property that solves the problem.&lt;/p&gt;
&lt;p&gt;Let A be the array we receive. f(A) = i1^i2^&amp;hellip;ik where &amp;ldquo;^&amp;rdquo; is the bitwise XOR operator and i1,i2 &amp;hellip; ik the positions that are &amp;ldquo;1&amp;rdquo; on the array. In the case A has no &amp;ldquo;1&amp;rdquo;, f(A) = 0.&lt;/p&gt;
&lt;p&gt;The first special property is that result of the function is always an integer x such that 0 &amp;lt;= x &amp;lt;= 63.  The second is that when we flip the coin j of A and obtain the array A*, the value f(A*) = f(A)^j , regardless of the state of position j in the array A.&lt;/p&gt;
&lt;p&gt;Because 0 &amp;lt;= x &amp;lt;= 63 and 0 &amp;lt;= C &amp;lt;= 63, we can prove that there is an y , 0 &amp;lt;= y &amp;lt;= 63, such that x^y.&lt;/p&gt;
&lt;p&gt;This leads to the solution. We calculate the value of f(Aj*) for Aj* identical to A , except for the j-th coin that is flipped, for all 0 &amp;lt;= j &amp;lt;= 63. One of the j&#39;s will lead to a configuration whose function value is C, so we return that j as the solution.&lt;/p&gt;
&lt;p&gt;A further improvement is that we can know the value of j even quicker. Because of the XOR properties, j = f(A)^C is the position our previous algorithm would find.&lt;/p&gt;
&lt;p&gt;The final code could not be simpler.&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/f4045192efcd00d49024cfed6bee5803.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #4 - ICC</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer4/</link>
      <pubDate>Thu, 23 Aug 2018 18:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer4/</guid>
      <description>&lt;p&gt;This is the fourth post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer3/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is ICC from the Central-European Olympiad in Informatics (CEOI 2016). You may find the problem statement here and a place to submit the solution &lt;a href=&#34;http://www.ceoi2016.ro/wp-content/uploads/2016/08/icc-statement.pdf&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : there are N cities numbered from 1 to N. At each pass, we build a new road between two cities such that there is no cycle between them. You must guess the new road by asking the following question : is there an edge from a vertex of set A to a vertex of set B? The total number of queries for the N-1 passes must not exceed M queries. There are five subtasks with different (N,M) pairs, but N = 100 and M = 1625 for the last one.&lt;/p&gt;
&lt;p&gt;The fact that the statement mentions roads and cities heavily suggests that this is a graph problem. Indeed, it is one!&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/arvore1.png&#34; alt=&#34;Graph representation of the problem&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every city is a vertex&lt;/li&gt;
&lt;li&gt;Every road is an edge&lt;/li&gt;
&lt;li&gt;Our graph is a forest&lt;/li&gt;
&lt;li&gt;At each pass, we add an edge between vertices of different forests&lt;/li&gt;
&lt;li&gt;Just by modeling the problem with a graph we arrive at the most simple solution:&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;on3--7-points&#34;&gt;O(N^3) : 7 points&lt;/h2&gt;
&lt;p&gt;At each pass, we query all possible edges. Notice that the possible edges do not include edges that connect two vertices of the same forest because of the acyclic property of our graph. In order to maintain that, we use an Union-Find data structure.&lt;/p&gt;
&lt;p&gt;To check wether or not there is an edge between two vertices, we do a query with unitary sets containing these vertices.&lt;/p&gt;
&lt;p&gt;The complexity analysis is not complicated. There are O(N^2) edges and O(N) passes, so the total number of queries is O(N^3).&lt;/p&gt;
&lt;h2 id=&#34;on2--18-points&#34;&gt;O(N^2) : 18 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/quadratico.png&#34; alt=&#34;One-versus all idea&#34;&gt;&lt;/p&gt;
&lt;p&gt;To reduce the number of queries, we will not try to discover directly the pair of vertices that is connected by the new edge. Instead, we will try to discover for each vertex if it is the one with a new edge.&lt;/p&gt;
&lt;p&gt;To do that we do the following query : we put the vertex we are considering now in a unitary set and all the vertices that are not on the subtree of this vertex. The image above exemplifies this.&lt;/p&gt;
&lt;p&gt;There will be two vertices that have new edges. These were the vertices we wanted to know and the new edge connect those vertices. The overall complexity is O(N) per pass and there are O(N) passes, so in total its O(N^2).&lt;/p&gt;
&lt;p&gt;Room for improvement : the start of D&amp;amp;C&lt;/p&gt;
&lt;p&gt;Suppose that we found the first vertex that has a new edge. We can use a Divide and Conquer algorithm to find the other one because we know it is on the set we have just asked about.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/icc0.png&#34; alt=&#34;Refining the idea&#34;&gt;&lt;/p&gt;
&lt;p&gt;Let&#39;s exemplify the algorithm with an example. Suppose we discovered that the vertex 1 has the new edge and the other vertex is on the set {2,3,4,5,6}. We split the set into L = {2,3,4} and R = {5,6} and do the query with sets {1} and L. If there is an edge between 1 and L , then we can discard R because there is only one edge. Similarly, if there is not, we discard L and continue with R. We continue to do that until we end with a set with only one element : the last element is the other vertex of the edge.&lt;/p&gt;
&lt;p&gt;So our &amp;ldquo;Divide&amp;rdquo; part is to split the set into two halves L and R and do the query between the known vertex and L. The &amp;ldquo;Conquer&amp;rdquo; part is to discard L or R based on the result of our query. The base case is the unitary set.&lt;/p&gt;
&lt;p&gt;This improvement alone does not give any extra points. However, the idea of the final solution uses this improvement.&lt;/p&gt;
&lt;p&gt;A desire : the perfect environment &lt;/p&gt;
&lt;p&gt;Suppose we had two sets A and B and we knew that there is a new edge from a vertex of set A to one on set B. If this happened , we could adapt the above algorithm to discover the two vertices very quickly.&lt;/p&gt;
&lt;p&gt;If we fixed the set A for all the queries and did the above procedure on B, we would find the vertex that has the edge on B. We could also fix B and run the algorithm on A, discovering the vertex on A.&lt;/p&gt;
&lt;p&gt;So the D&amp;amp;C part of the problem has ended. If we could find those two sets, the problem would be solved. But can we?&lt;/p&gt;
&lt;p&gt;The answer is fortunately yes.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--nk--61-points&#34;&gt;O(N*log(N) + N*K) : 61 points&lt;/h2&gt;
&lt;p&gt;The first idea two find the two sets is to use some randomization. Suppose that we put the connected components we have so far (represented by the head of the component) in a sequence and randomly shuffle the sequence. Then , we split the sequence into two halves. The probability that the components whose vertices form the new edge are on different halves if of 50%. We then construct two sets : A with the vertices of the components on the first half and B with the remaining ones. If there is an edge from A to B , we stop the shuffling and run the D&amp;amp;C algorithm. Otherwise, we continue until we arrive in a partition.&lt;/p&gt;
&lt;p&gt;The number of passes algorithm is not defined. However, we could say that on average it will need K passes. A good estimative of K is a K that gives a probability close to 1 that the partition will be found. Because 1 - (0.5)**10 &amp;gt;= 99.9%, K = 10 seems to be a reasonable one.&lt;/p&gt;
&lt;p&gt;The overall complexity is O(log(N) + K) per pass and therefore O(N*log(N) + N*K) total complexity.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--90-points&#34;&gt;O(N*log(N)) : 90 points&lt;/h2&gt;
&lt;p&gt;The final solutions uses a quicker approach to arrive at the partition.&lt;/p&gt;
&lt;p&gt;The partition used is based on a simple principle with a clever application. The idea is : every number written in its binary form has at least one different bit if we compare it to another number.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer4/binary.png&#34; alt=&#34;Bit representation example&#34;&gt;&lt;/p&gt;
&lt;p&gt;You may take a look at the image above with the representation of {0,1,2,3} in binary base and convince yourself. The formal proof is not that hard, but I will omit it.&lt;/p&gt;
&lt;p&gt;Because of the principle above, the following strategy will find a partition : first, we assign a integer from 0 to C-1 for each component.&lt;/p&gt;
&lt;p&gt;Then, for each bit, we separe the vertex into two sets A and B according to the state of that bit. A contains the vertices whose component number has the bit we are considering turned off and B contains the vertices whose component number has the bit turned on. We test this partition : if it works, then we run the D&amp;amp;C algorithm; if it does not, we follow to the next bit. By doing that, we achieve O(log(N)) to discover the partition which is a small improvement against the last algorithm, but scores more points because of the tight query limit.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;The solution mentioned above is 99% similar to the final solution. The only diference is that in order to achieve 100 points you need to do some micro optimizations.&lt;/p&gt;
&lt;p&gt;The first idea to reduce the number of queries is to shuffle the order that you choose the bit to do the partition. The grader is adaptative and tries to achieve the worst case complexity if you always ask about the bits in order, so shuffling prevents this from happening. If you implement this idea alone you should score 100 points.&lt;/p&gt;
&lt;p&gt;The second idea is to save a query per iteration when doing the partition. Imagine there are K bits to try the partition and you have tried K-1 of them. You do not need to check if the last one will find a valid partition, because it must. This is a small gain but helps.&lt;/p&gt;
&lt;p&gt;My solution to this problem :&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/fe07e32dc71523ee3f234d6487bb8c1a.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #3 - Library</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer3/</link>
      <pubDate>Thu, 23 Aug 2018 13:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer3/</guid>
      <description>&lt;p&gt;This is the third post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer2/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Library from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement &lt;a href=&#34;https://www.ioi-jp.org/camp/2018/2018-sp-tasks/day4/library-en.pdf&#34;&gt;here&lt;/a&gt; and a place to submit &lt;a href=&#34;https://oj.uz/problem/view/JOI18_library&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have an array of size N (N &amp;lt;= 1000) that is a permutation of 1,2,3&amp;hellip; N. At the beginning you do not know the configuration of the array. However, you are allowed to make up to 20000 queries which count the number of subarrays of the subset of numbers you are querying. After that, you must output one of the two possible configurations of the array.&lt;/p&gt;
&lt;p&gt;Our first step in order to solve the problem is to transform it into a graph problem:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/library0.png&#34; alt=&#34;Graph representation of the problem&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every number of the array is a vertex&lt;/li&gt;
&lt;li&gt;There is an edge between every two adjacent numbers in the array&lt;/li&gt;
&lt;li&gt;Our query answers the number of connected components of the subgraph we chose for that query.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This first steps leads very quickly to the solution to subtask 1:&lt;/p&gt;
&lt;h2 id=&#34;on2--19-points&#34;&gt;O(N^2) : 19 points&lt;/h2&gt;
&lt;p&gt;We simply try to discover all edges of the graph. To check wether or not there is an edge , we do a query with only two elements. If there is one connected component, then there is an edge. Otherwise, there is not an edge.&lt;/p&gt;
&lt;p&gt;After that, you can do a BFS/DFS starting from one of the two vertices with degree one and find one of the two possible answers.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;We have about 20 queries per vertex in order to discover the configuration of the array. This heavily suggests around O(log(N)) queries per vertex, which is a hint that Divide and Conquer might work.&lt;/p&gt;
&lt;p&gt;The first step of our algorithm will be adding the vertices in order :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/floating.png&#34; alt=&#34;Floating graph componnents&#34;&gt;&lt;/p&gt;
&lt;p&gt;When we adding the i-th vertex, the other i-1 vertices form C  connected components. Each component has two endpoints (note that the endpoints can be equal when there is only one element). You may think of these components as floating subarrays whose order is still to be defined. In the image, there is an example for a situation where we are adding the vertex 8.&lt;/p&gt;
&lt;p&gt;There are three possible cases for our newly added vertex :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Zeroth case : there is no edge between i and the other components , therefore i is a part of a new connected component and the total number of components is increased.&lt;/li&gt;
&lt;li&gt;First case : there is exactly one edge of i to one of the endpoints of the components. The number of components remains the same.&lt;/li&gt;
&lt;li&gt;Second case : there are exactly two edges between i and two endpoints of different components. Therefore we merge two components in this step and the total number decreases by one.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/caso1.png&#34; alt=&#34;Possible cases&#34;&gt;&lt;/p&gt;
&lt;p&gt;To make the last two cases clearer, you may look at the examples above of the first and second case , respectively.&lt;/p&gt;
&lt;p&gt;The first query we will make for our new vertex is asking about the configuration with all the C  components and the vertex. The answer of the query uniquely determines the case : if there are C+1 components, then we know it is case 0 and we can continue our algorithm; if there are C components, then we know it is case 1 and we need to discover the component the i-th vertex is connecting and which vertex it is connecting to; the last option is that there are C - 1 components, in which we need to discover the two components and the two distinct endpoints.&lt;/p&gt;
&lt;p&gt;The next step of our solution is to create a D&amp;amp;C algorithm for the first case. It turns out that this algorithm is very similar to the algorithm of our last two posts :&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer3/dc0.png&#34; alt=&#34;Divide and Conquer appears again&#34;&gt;&lt;/p&gt;
&lt;p&gt;We split the set of the components we have into two halves, L and R. We then try a configuration with the components of L and the i-th vertex. If there are |L| + 1 components in that configuration, then there is no edge between the i-th vertex and the components of L and we discard all components of L , because we know that the edge is on R. Otherwise, the number of components is |L| and we discard all components of R because of the same concept.&lt;/p&gt;
&lt;p&gt;Notice that when we do an iteration, we discard half of the components and arrive at the same problem we had before. If we continue to do that, we will eventually reach the case where there is only one component : this is our base case and the last component is the one we are looking for.&lt;/p&gt;
&lt;p&gt;After that, we need to discover the vertex that connects with the i-th one. This is very simple and can be done with one query : try to check if there is an edge between the i-th vertex and one of the endpoints the same way we did in the previous solution. If there is one, then we found the edge. If there is not, then the edge will be between the other endpoint and the i-th vertex. After that, you must not forget to update the component you found and its endpoints.&lt;/p&gt;
&lt;p&gt;The last step of our algorithm is to create a D&amp;amp;C algorithm for the second case. This part is a little bit more complicated compared to the last one, but not that much.&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Divide&amp;rdquo; part of our algorithm is identical to the last one. We split the set we are querying into two sets L and R. The change is on the &amp;ldquo;Conquer&amp;rdquo; part, because now there are three possible results for our query with L plus i-th vertex.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;|L| - 1 components : the two edges are on L. We discard R and recurse into the same problem we had, that is , a set in case 2.&lt;/li&gt;
&lt;li&gt;|L| + 1 components : the two edges are on R. We discard L and recurse into the same problem we had.&lt;/li&gt;
&lt;li&gt;|L| components : there is one edge on L and consequently one on R. We recurse into two independent problems, which is to find exactly one edge in a set. This is the first case of our algorithm!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Therefore, the &amp;ldquo;Conquer&amp;rdquo; step may recurse into one problem of case 2 or two problems of case one. Our base case will be the same as case 1.&lt;/p&gt;
&lt;p&gt;After we discovered the two components, we need to discover the vertices we connect to. We do exactly the same procedure as in case 1, but we need to be more careful when updating and merging the components.&lt;/p&gt;
&lt;p&gt;A code that implements the idea and scores 100 points follows:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/79fa951989731f161542868c8c51cc7f.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #2 - Cave</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer2/</link>
      <pubDate>Wed, 22 Aug 2018 11:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer2/</guid>
      <description>&lt;p&gt;This is the second post of a series that focuses on Divide and Conquer. If you want to check the previous one, click &lt;a href=&#34;https://ivaniscoding.github.io/posts/divideandconquer1/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Cave from the International Olympiad in Informatics (IOI 2013). You may find the problem statement &lt;a href=&#34;https://ioinformatics.org/files/ioi2013problem4.pdf&#34;&gt;here&lt;/a&gt; and a place to submit &lt;a href=&#34;https://dmoj.ca/problem/ioi13p4&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;A synthesis of the problem statement is : you have N (1 &amp;lt;= N &amp;lt;= 5000) switches and doors. Each switch is linked to a door and has two possible configurations (0 or 1) : one that opens the connected door and one that does not. You can try up to 70000 configurations of switches and see the last door that is open. After those tries you must return the connected door to each switch and also its correct state.&lt;/p&gt;
&lt;p&gt;There are 5 subtask in this problem. Subtasks 1 and 2 are the ones that give the most crucial hints in order to arrive to the full solution. However, I will use a different strategy to get the 100 points : we will focus on the first door.&lt;/p&gt;
&lt;p&gt;The reason for that is that you do not need to know any information about the other doors in order to know about the first one. Therefore, it seems to be a good approach to focus on it.&lt;/p&gt;
&lt;p&gt;Our first problem is to discover the correct state of the switch that opens the first door.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/divide0.png&#34; alt=&#34;Initial State&#34;&gt;&lt;/p&gt;
&lt;p&gt;To solve this, we will try a configuration where all switches are set to the same configuration. Let&#39;s exemplify that with an image. Imagine that each switch is a position in our sequence of blocks, that the color blue represents the state &amp;ldquo;0&amp;rdquo; and that the color yellow represents &amp;ldquo;1&amp;rdquo;. If we try a configuration with all blocks having the blue color and it opens the first door, then the switch that opens the first door must be blue; otherwise, the first door would not be open. In the case the configuration fails to open the door, then the switch must be yellow.&lt;/p&gt;
&lt;p&gt;Our second problem is then to discover which switch opens the first door. There are three approaches to discover the position of the switch : by doing a complete search, by bucketing switches and by using a Divide and Conquer approach.&lt;/p&gt;
&lt;p&gt;The simplest idea is to do the complete search : we test all switches one by one. When we are trying a switch, we set it to the correct color and all the others to the complementary color.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave51.png&#34; alt=&#34;Brute Force&#34;&gt;
&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave71.png&#34; alt=&#34;Brute Force&#34;&gt;&lt;/p&gt;
&lt;p&gt;If the configuration with only the i-th switch set opens the first door, then this is the switch we are looking for. Otherwise, we continue to try other switches. An image helps us exemplify the idea again : first we test only the first switch with the correct color blue. In that case it did not work out, so we must try the second switch with the blue color. Then we discover that this configuration opens the first door and we assign the first door to the second switch.&lt;/p&gt;
&lt;p&gt;A refinement of the idea above is to use buckets in order to do less queries.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/bucket2.png&#34; alt=&#34;Buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;We group the switches into B buckets of roughly the same size. Then we apply the complete search idea , but with buckets instead : we set all the switches of the current bucket we are testing to the correct state and all the other ones to the complementary state. By doing this, we will discover the bucket that contains the desired switch. After that, we do a complete search on the switches of that bucket. The total number of queries is B + N/B. The value of B that minimizes the sum is sqrt(N), so this is a considerable gain if we consider that the idea is not that much different from the O(N) approach.&lt;/p&gt;
&lt;p&gt;The most efficient idea will then be Divide and Conquer. The key idea of our algorithm will be that there is one and only one switch that opens the first door.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave1.png&#34; alt=&#34;First step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Divide&amp;rdquo; part of our algorithm will be as follows : we split the current set of switches we are considering into two halves. We then try a configuration with the switches of the first half set to the correct state and all other switches set to the complementary state.&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Conquer&amp;rdquo; part is based in the result of our query. If the mentioned configuration opens the first door, then the switch we are looking for is on the first half and we discard all the switches of the other half. If it does not, then we discard all the ones from the first half and stick with the ones from the second half. Let&#39;s make an example with the set {1,2,3,4,5,6}. We split the set into L = {1,2,3} and R = {4,5,6} and try the configuration as described above and exemplified by the image above. Imagine that this configuration does not open the first door : then , we discard L and our set is now {4,5,6}.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave2.png&#34; alt=&#34;Second step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;We continue the procedure and split the set  in {4,5} and {6}. If we discover that {4,5} opens the door, than we discard {6}. Then we split {4,5} into {4} and {5} and do the query again.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer2/cave3.png&#34; alt=&#34;Third step of Divide and Conquer&#34;&gt;&lt;/p&gt;
&lt;p&gt;We continue the procedure until we arrive into a set that contains a single switch. This the base case of our D&amp;amp;C recursion : the final element must be the switch we are looking for.&lt;/p&gt;
&lt;p&gt;The analysis of our idea is based on the depth of the recursion tree : because at each step we discard half of the nodes, then the maximal depth if log2(N).&lt;/p&gt;
&lt;p&gt;So we arrived at a fast solution to discovering the correct state and switch that opens the first door. However, we still need to take care of the other N-1 doors. This will not be very different from our current idea.&lt;/p&gt;
&lt;p&gt;The tweak is indeed very simple : we find the informations for the doors in order (1,2,3 and so on&amp;hellip;). When we are doing our queries for the i-th door, we remove the switches that opens the other i-1 doors from the set of candidates and set them to the correct states we discovered in the previous iterations of our algorithm. Therefore, discovering the correct state and switch that opens the i-th door with the information about the i-1 previous doors is equivalent to the problem of solving for the first door.&lt;/p&gt;
&lt;p&gt;Here is a code that implements the D&amp;amp;C algorithm and scores 100 points :&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/959274b5107c0542116a195f966f789e.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
    <item>
      <title>Divide and Conquer #1 - Carnival</title>
      <link>https://ivaniscoding.github.io/posts/divideandconquer1/</link>
      <pubDate>Tue, 21 Aug 2018 21:00:00 -0300</pubDate>
      <guid>https://ivaniscoding.github.io/posts/divideandconquer1/</guid>
      <description>&lt;p&gt;This is the first post of a series of posts about Divide and Conquer. The idea is to share this simple yet very powerful approach to solve some problems.&lt;/p&gt;
&lt;p&gt;This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Merge_sort&#34;&gt;Merge Sort&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Binary_search&#34;&gt;Binary Search&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The problem we will analyze is Carnival from the Central-European Olympiad in Informatics (CEOI 2014). You may find the problem statement &lt;a href=&#34;http://ceoi2014.informatik-olympiade.de/wp-content/uploads/2014/06/carnival.pdf&#34;&gt;here&lt;/a&gt; and a place to submit the solution &lt;a href=&#34;https://oj.uz/problem/view/CEOI14_carnival&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After reading the problem statement it seems very smart to model it with a graph:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/teste.png&#34; alt=&#34;Testing&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every person is represented as a vertex in our graph.&lt;/li&gt;
&lt;li&gt;Every costume is represented by a color in our graph. Each vertex has only one color.&lt;/li&gt;
&lt;li&gt;Every vertex is part of a connected component of vertex with the same color. This connected component is a clique.&lt;/li&gt;
&lt;li&gt;When we organize a party, we query the number of distinct colors of the set of vertices we chose.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Modeling the problem with the graph helps us arrive at the first partial solution:&lt;/p&gt;
&lt;h2 id=&#34;on2-queries--20-points&#34;&gt;O(N^2) queries : 20 points&lt;/h2&gt;
&lt;p&gt;A direct approach to solve the problem is to discover all the edges of the graph. To discover if there is an edge between two vertices, we organize a party with these two vertices. If there are two costumes, then they are of different colors and there is no edge. Otherwise, they share the same color and there is an edge between them.&lt;/p&gt;
&lt;h2 id=&#34;optimized-on2--100-points&#34;&gt;Optimized O(N^2) : 100 points&lt;/h2&gt;
&lt;p&gt;There are some optimizations to make the previous solution work faster.&lt;/p&gt;
&lt;p&gt;The first idea is to choose a head to each component we know so far and always ask questions with it . Because of the clique property, it does not matter which pair of vertices we query : any of them will  do the work. This saves lots of questions&lt;/p&gt;
&lt;p&gt;The second idea is to add vertices gradually. We will first query 1, then 2, 3 and so on. This allow us to the following query : organize a party with the H heads we know so far and the i-th vertex we are adding. If in this party there are H + 1 costumes, then we know that the i-th vertex has no edge to any of those heads and is therefore a head of its own component. In the other case there will be H costumes and we need to query all the possible edges to discover the component of the i-th vertex.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa0.png&#34; alt=&#34;First Step&#34;&gt;&lt;/p&gt;
&lt;p&gt;To make it clearer , see this example : we are adding vertex 6 and we know there are 4 head nodes : 1,3,4,5. If we organize the party and there are 5 costumes, then vertex 6 must have a color different from the other 4 vertices. In the other case, with 4 costumes, 6 must have the same color of one of those vertices. In that case, we find the color of 6 by testing an edge with each head.&lt;/p&gt;
&lt;p&gt;The number of queries is still quadratic because of the case were the i-th vertex is not a new head. However, the constant is heavily reduced. This probably was not the intended solution, but it works.&lt;/p&gt;
&lt;h2 id=&#34;onsqrtn--100-points&#34;&gt;O(N*sqrt(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/bucket.png&#34; alt=&#34;Splitting the nodes into buckets&#34;&gt;&lt;/p&gt;
&lt;p&gt;An idea to optimize the previous solution is to group the heads into buckets. We do the first query with all the H heads to discover wether the i-th vertex is a new head or not in the same way as before.&lt;/p&gt;
&lt;p&gt;But the second part changes. Instead of manually testing all edges with the heads, we group them into B buckets with H/B per bucket. Then we organized parties with the i-th vertex and all heads of each bucket. If there are H/B + 1 costumes, then we proceed to the next bucket. Otherwise, we test the edge with all the heads of this bucket.&lt;/p&gt;
&lt;p&gt;This gives B + H/B queries per vertex. The value of the that minimizes this sum is sqrt(H). Therefore we achieve the complexity of O(N*sqrt(N)), better than the last one.&lt;/p&gt;
&lt;h2 id=&#34;onlogn--100-points&#34;&gt;O(N*log(N)) : 100 points&lt;/h2&gt;
&lt;p&gt;The title of this post includes &amp;ldquo;Divide and Conquer&amp;rdquo; and so far none of the solutions used it, so at some moment D&amp;amp;C must appear. This is the moment!&lt;/p&gt;
&lt;p&gt;The principle we will use is the same from the previous solutions. However, we will use it way more efficiently.  The idea of querying &lt;strong&gt;H&lt;/strong&gt; heads plus the i-th vertex and deciding wether or not there is a edge based on the answer will be our base.&lt;/p&gt;
&lt;p&gt;To start, we do the now usual query with all heads like in the previous solution.&lt;/p&gt;
&lt;p&gt;If there is an edge, then we start to use D&amp;amp;C. The &amp;ldquo;Divide&amp;rdquo; part of our algorithm will be to partition our set of heads in two halves, L and R and querying the heads of L and the i-th vertex.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa1.png&#34; alt=&#34;Splitting the node into halves&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &amp;ldquo;Conquer&amp;rdquo; part of our algorithm is based on the result of our query and the fact that there is only one edge between the i-th vertex and the whole set. If that edge is on the set &lt;strong&gt;L&lt;/strong&gt;, then we can discard all the heads of &lt;strong&gt;R&lt;/strong&gt;. If that edge is not on that set, then it must be on &lt;strong&gt;R&lt;/strong&gt;,because there is exactly one edge so we discard all heads of &lt;strong&gt;L&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let&#39;s make another example with adding 6 , knowing heads 1,3,4,5. We split the heads in {1,3} and {4,5} and do the query {1,3,6}. Suppose we received that there are 3 colors in the set. Then there is no edge between 6 and {1,3} and we now solve the problem with the set {4,5}.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://ivaniscoding.github.io/img/DivideAndConquer1/etapa3.png&#34; alt=&#34;Next step of halving the set&#34;&gt;&lt;/p&gt;
&lt;p&gt;If we continue to do the procedure of discarding a half in each iteration, we will eventually reach our base case : the set has only one element. Therefore , there must be an edge between the i-th vertex and the last element.&lt;/p&gt;
&lt;p&gt;If we want to analyze the complexity , we must think about the depth of the recursion we designed. In each iteration, we discard &lt;strong&gt;H/2&lt;/strong&gt; heads so the depth will be at most &lt;strong&gt;log2(H)&lt;/strong&gt;. Thus the overall number of queries is &lt;strong&gt;O(N*log(N))&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;My implementation of this idea:&lt;/p&gt;
&lt;script type=&#34;application/javascript&#34; src=&#34;https://gist.github.com/IvanIsCoding/c297207d7b297eb4ba829502125121f7.js&#34;&gt;&lt;/script&gt;

</description>
    </item>
    
  </channel>
</rss>
