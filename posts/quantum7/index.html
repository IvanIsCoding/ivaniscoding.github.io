<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.55.6" />

    
    
    

<title>Quantum #7 - Grover • Ivan Carvalho</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Quantum #7 - Grover"/>
<meta name="twitter:description" content="Finding a needle in a haystack with quantum search algorithm"/>

<meta property="og:title" content="Quantum #7 - Grover" />
<meta property="og:description" content="Finding a needle in a haystack with quantum search algorithm" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ivaniscoding.github.io/posts/quantum7/" />
<meta property="article:published_time" content="2020-01-02T16:10:00-08:00"/>
<meta property="article:modified_time" content="2020-01-02T16:10:00-08:00"/><meta property="og:site_name" content="Ivan Carvalho" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.6a83d62c39a364f036df4db1ecd564645635d6c7fc182425cb501218fec485f5.css" integrity="sha256-aoPWLDmjZPA2302x7NVkZFY11sf8GCQly1ASGP7EhfU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
</head>


    <body class="theme-base-0d layout-reverse">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://ivaniscoding.github.io/">Ivan Carvalho</a>
      </span>
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Ivan Carvalho</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/index.html">
						<span>About</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	
	
	<a href="https://github.com/ivaniscoding" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/ivan-carvalho" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>Quantum #7 - Grover</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Jan 2, 2020
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/quantum">QUANTUM</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/quantum">quantum</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 8 min read
</div>


  </header>
  
  
  <div class="post">
    <p>This is the seventh post of a series of posts about Quantum Computing with <a href="https://qiskit.org/">Qiskit</a>. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.</p>
<p>The goal of this post is to discuss Grover’s algorithm. It is an algorithm to solve unstructured search in <span class="math inline">\(O(\sqrt N)\)</span>, which is a quadratic speedup over the classical <span class="math inline">\(O(N)\)</span> solution.</p>
<h2 id="unstructured-search">Unstructured Search</h2>
<p>Imagine that you have a hard problem to solve such that your best-known solutions is to try all the possibilities. That problem could be:</p>
<ul>
<li>Checking if two molecules are identical, i.e. solving <a href="https://en.wikipedia.org/wiki/Graph_isomorphism_problem">graph isomorphism</a></li>
<li>Finding the shortest route that passes through all cities, the <a href="https://en.wikipedia.org/wiki/Travelling_salesman_problem">travelling salesman problem</a></li>
</ul>
<p>Classically, those are examples of unstructured search problems: the search space (i.e. possible solutions) has so little structure that the best strategy is just to try all possibilities.</p>
<p>The complexity of solving that problem depends on how big the search space is: if there are <span class="math inline">\(N\)</span> elements to check, the algorithm needs to make <span class="math inline">\(O(N)\)</span> to an oracle (i.e. the entity that verifies if a solution is valid). That is the best that can be done.</p>
<p>The quantum algorithm that will discuss today goes beyond: it can find the solution with <span class="math inline">\(O(\sqrt N)\)</span> checks. Considering that there is no structure in the search space, Grover’s algorithm provides an impressive speedup. Moreover, unlike the last two quantum algorithms we discussed, an unstructured search is the component of many real-world problems. Thus, Grover’s algorithm has immediate applications.</p>
<p>For our discussion today, we will pick a specific flavor of the search problem: we will try to find a needle in a haystack.</p>
<h3 id="needle-in-a-haystack">Needle in a haystack</h3>
<p>Imagine that you have a search space with <span class="math inline">\(N\)</span> elements, with <span class="math inline">\(N-1\)</span> straws that are useless, and exactly one needle that we are looking for.</p>
<p>Mathematically, the problem is described by a function <span class="math inline">\(f\)</span>:</p>
<p><span class="math display">\[
f(x) = 1 \iff x = s
\]</span></p>
<p><span class="math display">\[
f(x) = 0 \iff x \neq s
\]</span></p>
<p>In which <span class="math inline">\(s\)</span> is the solution string, i.e. the needle. Notice that <span class="math inline">\(f\)</span> needs to be implemented by a quantum circuit, that we will call quantum oracle.</p>
<h2 id="steps-of-the-algorithm">Steps of the algorithm</h2>
<p>Now that we know the problem Grover’s algorithm solves, it is time to discuss it.</p>
<h3 id="assumptions">Assumptions</h3>
<p>On this discussion, we will assume two things that might not always be true in a search problem:</p>
<ul>
<li><span class="math inline">\(N = 2^{n}\)</span>, that is <span class="math inline">\(N\)</span> is a power of two</li>
<li>There is exactly one solution</li>
</ul>
<p>Those assumptions are to simplify the discussion. Even though they are not always true, it is not hard to make a problem respect them.</p>
<p>For the first assumption, if we are given a <span class="math inline">\(M\)</span> that is not a power of two, we can just augment the search space to a <span class="math inline">\(N\)</span> that is a power of two and have :</p>
<p><span class="math display">\[
x &gt; M \implies f(x) = 0
\]</span></p>
<p>For the second assumption, Grover’s algorithm can still find a solution when there is multiple: it is just the number of iterations <span class="math inline">\(K\)</span> that will change.</p>
<h3 id="step-1">Step 1</h3>
<p>Generate the superposition state:</p>
<p><span class="math display">\[
|\psi\rangle = \frac{1}{\sqrt 2 ^ {n}}\sum_{x \in \{0, 1\}^{n}}|x\rangle
\]</span></p>
<p>And initialize the ancilla qubit to <span class="math inline">\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)</span>.</p>
<p>Notice that on this step, each possible state <span class="math inline">\(x\)</span> will have an equal probability of measurement, which is basically guessing the solution. The critical insight from Grover’s algorithm comes on the next step, in which we will try to improve the chance of measuring the solution.</p>
<h3 id="step-2">Step 2</h3>
<p>Apply Grover’s iteration <span class="math inline">\(K\)</span> times:</p>
<ul>
<li>Query the oracle. This is sometimes also called reflection around the solution.</li>
<li>Invert about the mean. This is sometimes also called reflection around the superposition state.</li>
</ul>
<p>The value <span class="math inline">\(K\)</span> is given by <span class="math inline">\(K \approx \frac{\pi \sqrt N}{4}\)</span>. Thus, the algorithm makes <span class="math inline">\(O(\sqrt N)\)</span> queries to the oracle.</p>
<h3 id="step-3">Step 3</h3>
<p>Measure the qubits. <span class="math inline">\(s\)</span> will be the measurement with a high probability. A lower-bound for correctness is:</p>
<p><span class="math display">\[
P = 1 - \frac{1}{N}
\]</span></p>
<p>Hence, for very big <span class="math inline">\(N\)</span> our algorithm will guess the solution with a very high chance.</p>
<h2 id="grovers-iteration">Grover’s iteration</h2>
<p>At each iteration, Grover’s algorithm has a goal: to increase the amplitude <span class="math inline">\(\alpha_{s}\)</span> of the solution and to decrease the amplitude <span class="math inline">\(\alpha_{x}\)</span> of the non-solutions. To achieve it, it performs two specific steps as we will discuss.</p>
<h3 id="phase-kickback">Phase kickback</h3>
<p>Consider that at an arbitrary iteration of the algorithm, we will have a state <span class="math inline">\(|\psi\rangle\)</span>:</p>
<p><span class="math display">\[
|\psi\rangle = \sum_{x \in \{0, 1\}^{n}}\alpha_{x} |x\rangle
\]</span></p>
<p>Graphically, the amplitudes could be seen as:</p>
<p><img src="/img/Quantum7/Amplitude_Start.png" /></p>
<p>The first step of the Grover iteration is to query the oracle. The oracle will be a transformation <span class="math inline">\(|x\rangle|a\rangle \rightarrow |x\rangle|a \oplus f(x)\rangle\)</span>.</p>
<p>We will now reuse a trick that was first discussed in <a href="/posts/quantum4/">Deutsch-Jozsa’s algorithm</a>: because the ancilla is <span class="math inline">\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)</span>, then the phase will kickback in the form of a coefficient <span class="math inline">\((-1)^{f(x)}\)</span>, and the ancilla will remain unchanged.</p>
<p>Hence, that yields:</p>
<p><span class="math display">\[
U_{\omega}|\psi\rangle = \sum_{x \in \{0, 1\}^{n}} (-1)^{f(x)} \alpha_{x} |x\rangle
\]</span></p>
<p>Notice that this time, only one amplitude is negative: that of the solution. Graphically, it can be seen as:</p>
<p><img src="/img/Quantum7/Amplitude_Kickback.png" /></p>
<p>The next step is to perform an inversion about the mean. The idea is that combining phase kickback with a mean inversion, we will make the amplitude of the solution grow while reducing the amplitude of nonsolutions.</p>
<h3 id="inversion-about-the-mean">Inversion about the mean</h3>
<p>An inversion about the mean is reflecting the terms of a sequence <span class="math inline">\(C\)</span> according to the mean <span class="math inline">\(\overline{C}\)</span>. That is, we will find a new sequence <span class="math inline">\(D\)</span> such that each term is <span class="math inline">\(C_{i}\)</span> reflected.</p>
<p>Imagine that you have an element <span class="math inline">\(C_{i}\)</span>. We will find a new element <span class="math inline">\(D_{i}\)</span> such that the distance between <span class="math inline">\(D_{i}\)</span> and <span class="math inline">\(\overline{C}\)</span> is the same as the distance between <span class="math inline">\(C_{i}\)</span> and <span class="math inline">\(\overline{C}\)</span>. Mathematically, that can be written as:</p>
<p><span class="math display">\[
|D_{i} - \overline{C}| = |C_{i} - \overline{C}|
\]</span></p>
<p>Solving the equation and ignoring the case in which <span class="math inline">\(C_{i} = D_{i}\)</span>, we obtain:</p>
<p><span class="math display">\[
D_{i} = 2\overline{C} - C_{i}
\]</span></p>
<p>After the mean inversion transformation, <span class="math inline">\(\overline{D} = \overline{C}\)</span> holds as well.</p>
<p>At this point, you might be asking: what does mean inversion has to do with quantum computing? To answer that question, an example will do. Suppose that we have the sequence <span class="math inline">\(\{1, 1, 1, 1\}\)</span> and we flip the sign of the third 1, that is we have:</p>
<p><span class="math display">\[
C = \{1, 1, -1, 1\}
\]</span></p>
<p>The mean of this sequence is <span class="math inline">\(\frac{1}{2}\)</span>. Now if we compute mean inversion using the formula given before, we obtain:</p>
<p><span class="math display">\[
D = \{0, 0, 2, 0\}
\]</span></p>
<p>Something very interesting occurred: during the inversion, the only negative value of the sequence became the most positive while the old positives values diminished.</p>
<p>Hence, mean inversion combined with phase kickback is exactly what we were looking for: it is going to make <span class="math inline">\(\alpha_{s}\)</span> increase and decrease <span class="math inline">\(\alpha_{x}\)</span> of the nonsolutions.</p>
<p>Continuing the amplitude visualization we had before, mean inversion yields:</p>
<p><img src="/img/Quantum7/Amplitude_Mean_Inverted.png" /></p>
<p>Therefore, the idea is to perform phase kickback and mean inversion until <span class="math inline">\(\alpha_{s}\)</span> is maximized. We will not discuss the math behind, but it turns out that <span class="math inline">\(\frac{\pi \sqrt N}{4}\)</span> iterations suffice.</p>
<h2 id="implementing-the-quantum-oracle">Implementing the quantum oracle</h2>
<p>In real applications, the oracle would be a circuit that performs a meaningful computation: it could be solving the travelling salesman problem, trying to break an encryption key or just solving a hard problem in general.</p>
<p>For this example problem, we will emulate a real-world problem: we will have a function that has one value <span class="math inline">\(s\)</span> such that <span class="math inline">\(f(s) = 1\)</span> and that <span class="math inline">\(f(x) = 0\)</span> for all other <span class="math inline">\(x\)</span>.</p>
<p>Classically, it would look like:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> f(x):</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="cf">if</span> x <span class="op">==</span> s:</a>
<a class="sourceLine" id="cb1-3" title="3">        <span class="cf">return</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb1-5" title="5">        <span class="cf">return</span> <span class="dv">0</span></a></code></pre></div>
<p>The question now is: how does a quantum computer check that the state <span class="math inline">\(x\)</span> is equal to <span class="math inline">\(s\)</span>? The answer is: we verify if the binary representation of <span class="math inline">\(x\)</span> is identical to the binary representation of <span class="math inline">\(s\)</span>.</p>
<p>To do so, we use a multi-qubit Toffoli gate: we AND the equality of each bit. Because of the AND property, <span class="math inline">\(f(x) = 1\)</span> if and only if each bit of <span class="math inline">\(x\)</span> is equal to <span class="math inline">\(s\)</span>, otherwise <span class="math inline">\(f(x) = 0\)</span>. That implements exactly what we were looking for.</p>
<p>A factor to consider is that if a bit is 0, we need to NOT it so when the AND is done the result is 1. Hence, the circuit implementing <span class="math inline">\(f\)</span> for a string <span class="math inline">\(s\)</span> looks like:</p>
<p><img src="/img/Quantum7/Q7C0.png" /></p>
<p>Notice that after applying the Toffoli, we do not want to change <span class="math inline">\(|x\rangle\)</span> hence we apply NOT again on what was NOTed before.</p>
<h2 id="implementing-inversion-about-mean">Implementing inversion about mean</h2>
<p>To implement, we will use the Grover diffusion operator. I will not discuss it much, but the operator can be written as:</p>
<p><span class="math display">\[
\mathcal{D} = -H^{\otimes n}U_{s}H^{\otimes n}
\]</span></p>
<p>The idea is to implement the formula <span class="math inline">\(2\overline{C} - C_{i}\)</span> using matrix multiplication. It can be shown that <span class="math inline">\(\mathcal{D} = 2|+\rangle\langle+| - I\)</span>, which is the matrix equivalent of the formula we found for mean inversion.</p>
<p>An element of <span class="math inline">\(\mathcal{D}\)</span> we have not discussed yet is <span class="math inline">\(U_{s}\)</span>: it is similar to the oracle <span class="math inline">\(U_{\omega}\)</span>. It implements a function <span class="math inline">\(g(x)\)</span> such that <span class="math inline">\(g(000...0) = 1\)</span> and <span class="math inline">\(g(x) = 0\)</span> for all other <span class="math inline">\(x\)</span>.</p>
<p>Therefore, we also use a multi-qubit Toffoli gate to implement <span class="math inline">\(U_{s}\)</span> which yields the following circuit for <span class="math inline">\(\mathcal{D}\)</span>:</p>
<p><img src="/img/Quantum7/Q7C1.png" /></p>
<h2 id="implementing-grovers-algorithm">Implementing Grover’s algorithm</h2>
<p>We can verify that Grover’s algorithm works using Qiskit and running an experiment: in the Jupyter notebook below, we try to find a needle in a haystack.</p>
<script type="application/javascript" src="//gist.github.com/IvanIsCoding/089dc60e14775f2eca548e2f14930d94.js"></script>

  </div>
  


  

  
    


</article>


        </div>
        
    

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-135472875-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
 <script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "$", right: "$", display: false}]
    });
  });
</script>



    



    </body>
</html>
