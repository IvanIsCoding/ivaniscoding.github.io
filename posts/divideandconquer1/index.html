<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.54.0" />

    
    
    

<title>Divide and Conquer #1 - Carnival • Ivan&#39;s Blog</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Divide and Conquer #1 - Carnival"/>
<meta name="twitter:description" content="Analysis of Carnival from the Central-European Olympiad in Informatics 2014"/>

<meta property="og:title" content="Divide and Conquer #1 - Carnival" />
<meta property="og:description" content="Analysis of Carnival from the Central-European Olympiad in Informatics 2014" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ivaniscoding.github.io/posts/divideandconquer1/" />
<meta property="article:published_time" content="2018-08-21T21:00:00-03:00"/>
<meta property="article:modified_time" content="2018-08-21T21:00:00-03:00"/><meta property="og:site_name" content="Ivan&#39;s blog" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.6a83d62c39a364f036df4db1ecd564645635d6c7fc182425cb501218fec485f5.css" integrity="sha256-aoPWLDmjZPA2302x7NVkZFY11sf8GCQly1ASGP7EhfU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    

</head>


    <body class="theme-base-0d layout-reverse">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://ivaniscoding.github.io/">Ivan&#39;s Blog</a>
      </span>
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Ivan&#39;s Blog</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/index.html">
						<span>About</span>
					</a>
				</li>
			 
		
		</li>
	</ul>
</div>

        <section class="social">
	
	
	
	<a href="https://github.com/ivaniscoding" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	<a href="https://linkedin.com/in/ivan-carvalho" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>Divide and Conquer #1 - Carnival</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Aug 21, 2018
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/divide-and-conquer">DIVIDE AND CONQUER</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/algorithms">algorithms</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 5 min read
</div>


  </header>
  
  
  <div class="post">
    

<p>This is the first post of a series of posts about Divide and Conquer. The idea is to share this simple yet very powerful approach to solve some problems.</p>

<p>This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a> and <a href="https://en.wikipedia.org/wiki/Binary_search">Binary Search</a>.</p>

<p>The problem we will analyze is Carnival from the Central-European Olympiad in Informatics (CEOI 2014). You may find the problem statement <a href="http://ceoi2014.informatik-olympiade.de/wp-content/uploads/2014/06/carnival.pdf">here</a> and a place to submit the solution <a href="https://oj.uz/problem/view/CEOI14_carnival">here</a>.</p>

<p>After reading the problem statement it seems very smart to model it with a graph:</p>

<p><img src="/img/DivideAndConquer1/teste.png" alt="Testing" /></p>

<ul>
<li>Every person is represented as a vertex in our graph.</li>
<li>Every costume is represented by a color in our graph. Each vertex has only one color.</li>
<li>Every vertex is part of a connected component of vertex with the same color. This connected component is a clique.</li>
<li>When we organize a party, we query the number of distinct colors of the set of vertices we chose.</li>
</ul>

<p>Modeling the problem with the graph helps us arrive at the first partial solution:</p>

<h2 id="o-n-2-queries-20-points">O(N^2) queries : 20 points</h2>

<p>A direct approach to solve the problem is to discover all the edges of the graph. To discover if there is an edge between two vertices, we organize a party with these two vertices. If there are two costumes, then they are of different colors and there is no edge. Otherwise, they share the same color and there is an edge between them.</p>

<h2 id="optimized-o-n-2-100-points">Optimized O(N^2) : 100 points</h2>

<p>There are some optimizations to make the previous solution work faster.</p>

<p>The first idea is to choose a head to each component we know so far and always ask questions with it . Because of the clique property, it does not matter which pair of vertices we query : any of them will  do the work. This saves lots of questions</p>

<p>The second idea is to add vertices gradually. We will first query 1, then 2, 3 and so on. This allow us to the following query : organize a party with the H heads we know so far and the i-th vertex we are adding. If in this party there are H + 1 costumes, then we know that the i-th vertex has no edge to any of those heads and is therefore a head of its own component. In the other case there will be H costumes and we need to query all the possible edges to discover the component of the i-th vertex.</p>

<p><img src="/img/DivideAndConquer1/etapa0.png" alt="First Step" /></p>

<p>To make it clearer , see this example : we are adding vertex 6 and we know there are 4 head nodes : 1,3,4,5. If we organize the party and there are 5 costumes, then vertex 6 must have a color different from the other 4 vertices. In the other case, with 4 costumes, 6 must have the same color of one of those vertices. In that case, we find the color of 6 by testing an edge with each head.</p>

<p>The number of queries is still quadratic because of the case were the i-th vertex is not a new head. However, the constant is heavily reduced. This probably was not the intended solution, but it works.</p>

<h2 id="o-n-sqrt-n-100-points">O(N*sqrt(N)) : 100 points</h2>

<p><img src="/img/DivideAndConquer1/bucket.png" alt="Splitting the nodes into buckets" /></p>

<p>An idea to optimize the previous solution is to group the heads into buckets. We do the first query with all the H heads to discover wether the i-th vertex is a new head or not in the same way as before.</p>

<p>But the second part changes. Instead of manually testing all edges with the heads, we group them into B buckets with H/B per bucket. Then we organized parties with the i-th vertex and all heads of each bucket. If there are H/B + 1 costumes, then we proceed to the next bucket. Otherwise, we test the edge with all the heads of this bucket.</p>

<p>This gives B + H/B queries per vertex. The value of the that minimizes this sum is sqrt(H). Therefore we achieve the complexity of O(N*sqrt(N)), better than the last one.</p>

<h2 id="o-n-log-n-100-points">O(N*log(N)) : 100 points</h2>

<p>The title of this post includes &ldquo;Divide and Conquer&rdquo; and so far none of the solutions used it, so at some moment D&amp;C must appear. This is the moment!</p>

<p>The principle we will use is the same from the previous solutions. However, we will use it way more efficiently.  The idea of querying <strong>H</strong> heads plus the i-th vertex and deciding wether or not there is a edge based on the answer will be our base.</p>

<p>To start, we do the now usual query with all heads like in the previous solution.</p>

<p>If there is an edge, then we start to use D&amp;C. The &ldquo;Divide&rdquo; part of our algorithm will be to partition our set of heads in two halves, L and R and querying the heads of L and the i-th vertex.</p>

<p><img src="/img/DivideAndConquer1/etapa1.png" alt="Splitting the node into halves" /></p>

<p>The &ldquo;Conquer&rdquo; part of our algorithm is based on the result of our query and the fact that there is only one edge between the i-th vertex and the whole set. If that edge is on the set <strong>L</strong>, then we can discard all the heads of <strong>R</strong>. If that edge is not on that set, then it must be on <strong>R</strong>,because there is exactly one edge so we discard all heads of <strong>L</strong>.</p>

<p>Let&rsquo;s make another example with adding 6 , knowing heads 1,3,4,5. We split the heads in {1,3} and {4,5} and do the query {1,3,6}. Suppose we received that there are 3 colors in the set. Then there is no edge between 6 and {1,3} and we now solve the problem with the set {4,5}.</p>

<p><img src="/img/DivideAndConquer1/etapa3.png" alt="Next step of halving the set" /></p>

<p>If we continue to do the procedure of discarding a half in each iteration, we will eventually reach our base case : the set has only one element. Therefore , there must be an edge between the i-th vertex and the last element.</p>

<p>If we want to analyze the complexity , we must think about the depth of the recursion we designed. In each iteration, we discard <strong>H/2</strong> heads so the depth will be at most <strong>log2(H)</strong>. Thus the overall number of queries is <strong>O(N*log(N))</strong>.</p>

<p>My implementation of this idea:</p>

<script type="application/javascript" src="//gist.github.com/IvanIsCoding/c297207d7b297eb4ba829502125121f7.js"></script>

  </div>
  


  

  
    


</article>


        </div>
        
    
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-135472875-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
