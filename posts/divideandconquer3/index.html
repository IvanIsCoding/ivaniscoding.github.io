<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.54.0" />

    
    
    

<title>Divide and Conquer #3 - Library • Ivan&#39;s Blog</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Divide and Conquer #3 - Library"/>
<meta name="twitter:description" content="Analysis of Library from the Japanese Olympiad in Informatics Spring Camp 2018"/>

<meta property="og:title" content="Divide and Conquer #3 - Library" />
<meta property="og:description" content="Analysis of Library from the Japanese Olympiad in Informatics Spring Camp 2018" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ivaniscoding.github.io/posts/divideandconquer3/" />
<meta property="article:published_time" content="2018-08-23T13:00:00-03:00"/>
<meta property="article:modified_time" content="2018-08-23T13:00:00-03:00"/><meta property="og:site_name" content="Ivan&#39;s blog" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.6a83d62c39a364f036df4db1ecd564645635d6c7fc182425cb501218fec485f5.css" integrity="sha256-aoPWLDmjZPA2302x7NVkZFY11sf8GCQly1ASGP7EhfU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    

</head>


    <body class=" ">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://ivaniscoding.github.io/">Ivan&#39;s Blog</a>
      </span>
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Ivan&#39;s Blog</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/">
						<span>About</span>
					</a>
				</li>
			 
		
		</li>
	</ul>
</div>

        <section class="social">
	
	
	
	<a href="https://github.com/ivaniscoding" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	<a href="https://linkedin.com/in/ivan-carvalho" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>Divide and Conquer #3 - Library</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Aug 23, 2018
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/divide-and-conquer">DIVIDE AND CONQUER</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/algorithms">algorithms</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 6 min read
</div>


  </header>
  
  
  <div class="post">
    

<p>This is the third post of a series that focuses on Divide and Conquer. If you want to check the previous one, click <a href="/posts/divideandconquer2/">here</a>.</p>

<p>The problem we will analyze is Library from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2018). You may find the problem statement <a href="https://www.ioi-jp.org/camp/2018/2018-sp-tasks/day4/library-en.pdf">here</a> and a place to submit <a href="https://oj.uz/problem/view/JOI18_library">here</a>.</p>

<p>A synthesis of the problem statement is : you have an array of size N (N &lt;= 1000) that is a permutation of 1,2,3&hellip; N. At the beginning you do not know the configuration of the array. However, you are allowed to make up to 20000 queries which count the number of subarrays of the subset of numbers you are querying. After that, you must output one of the two possible configurations of the array.</p>

<p>Our first step in order to solve the problem is to transform it into a graph problem:</p>

<p><img src="/img/DivideAndConquer3/library0.png" alt="Graph representation of the problem" /></p>

<ul>
<li>Every number of the array is a vertex</li>
<li>There is an edge between every two adjacent numbers in the array</li>
<li>Our query answers the number of connected components of the subgraph we chose for that query.</li>
</ul>

<p>This first steps leads very quickly to the solution to subtask 1:</p>

<h2 id="o-n-2-19-points">O(N^2) : 19 points</h2>

<p>We simply try to discover all edges of the graph. To check wether or not there is an edge , we do a query with only two elements. If there is one connected component, then there is an edge. Otherwise, there is not an edge.</p>

<p>After that, you can do a BFS/DFS starting from one of the two vertices with degree one and find one of the two possible answers.</p>

<h2 id="o-n-log-n-100-points">O(N*log(N)) : 100 points</h2>

<p>We have about 20 queries per vertex in order to discover the configuration of the array. This heavily suggests around O(log(N)) queries per vertex, which is a hint that Divide and Conquer might work.</p>

<p>The first step of our algorithm will be adding the vertices in order :</p>

<p><img src="/img/DivideAndConquer3/floating.png" alt="Floating graph componnents" /></p>

<p>When we adding the i-th vertex, the other i-1 vertices form C  connected components. Each component has two endpoints (note that the endpoints can be equal when there is only one element). You may think of these components as floating subarrays whose order is still to be defined. In the image, there is an example for a situation where we are adding the vertex 8.</p>

<p>There are three possible cases for our newly added vertex :</p>

<ul>
<li>Zeroth case : there is no edge between i and the other components , therefore i is a part of a new connected component and the total number of components is increased.</li>
<li>First case : there is exactly one edge of i to one of the endpoints of the components. The number of components remains the same.</li>
<li>Second case : there are exactly two edges between i and two endpoints of different components. Therefore we merge two components in this step and the total number decreases by one.</li>
</ul>

<p><img src="/img/DivideAndConquer3/caso1.png" alt="Possible cases" /></p>

<p>To make the last two cases clearer, you may look at the examples above of the first and second case , respectively.</p>

<p>The first query we will make for our new vertex is asking about the configuration with all the C  components and the vertex. The answer of the query uniquely determines the case : if there are C+1 components, then we know it is case 0 and we can continue our algorithm; if there are C components, then we know it is case 1 and we need to discover the component the i-th vertex is connecting and which vertex it is connecting to; the last option is that there are C - 1 components, in which we need to discover the two components and the two distinct endpoints.</p>

<p>The next step of our solution is to create a D&amp;C algorithm for the first case. It turns out that this algorithm is very similar to the algorithm of our last two posts :</p>

<p><img src="/img/DivideAndConquer3/dc0.png" alt="Divide and Conquer appears again" /></p>

<p>We split the set of the components we have into two halves, L and R. We then try a configuration with the components of L and the i-th vertex. If there are |L| + 1 components in that configuration, then there is no edge between the i-th vertex and the components of L and we discard all components of L , because we know that the edge is on R. Otherwise, the number of components is |L| and we discard all components of R because of the same concept.</p>

<p>Notice that when we do an iteration, we discard half of the components and arrive at the same problem we had before. If we continue to do that, we will eventually reach the case where there is only one component : this is our base case and the last component is the one we are looking for.</p>

<p>After that, we need to discover the vertex that connects with the i-th one. This is very simple and can be done with one query : try to check if there is an edge between the i-th vertex and one of the endpoints the same way we did in the previous solution. If there is one, then we found the edge. If there is not, then the edge will be between the other endpoint and the i-th vertex. After that, you must not forget to update the component you found and its endpoints.</p>

<p>The last step of our algorithm is to create a D&amp;C algorithm for the second case. This part is a little bit more complicated compared to the last one, but not that much.</p>

<p>The &ldquo;Divide&rdquo; part of our algorithm is identical to the last one. We split the set we are querying into two sets L and R. The change is on the &ldquo;Conquer&rdquo; part, because now there are three possible results for our query with L plus i-th vertex.</p>

<ul>
<li>|L| - 1 components : the two edges are on L. We discard R and recurse into the same problem we had, that is , a set in case 2.</li>
<li>|L| + 1 components : the two edges are on R. We discard L and recurse into the same problem we had.</li>
<li>|L| components : there is one edge on L and consequently one on R. We recurse into two independent problems, which is to find exactly one edge in a set. This is the first case of our algorithm!</li>
</ul>

<p>Therefore, the &ldquo;Conquer&rdquo; step may recurse into one problem of case 2 or two problems of case one. Our base case will be the same as case 1.</p>

<p>After we discovered the two components, we need to discover the vertices we connect to. We do exactly the same procedure as in case 1, but we need to be more careful when updating and merging the components.</p>

<p>A code that implements the idea and scores 100 points follows:</p>

<script type="application/javascript" src="//gist.github.com/IvanIsCoding/79fa951989731f161542868c8c51cc7f.js"></script>

  </div>
  

<div class="navigation navigation-single">
    
    <a href="/posts/divideandconquer2/" class="navigation-prev">
      <i aria-hidden="true" class="fa fa-chevron-left"></i>
      <span class="navigation-tittle">Divide and Conquer #2 - Cave</span>
    </a>
    
    
    <a href="/posts/divideandconquer4/" class="navigation-next">
      <span class="navigation-tittle">Divide and Conquer #4 - ICC</span>
      <i aria-hidden="true" class="fa fa-chevron-right"></i>
    </a>
    
</div>


  

  
    


</article>


        </div>
        
    
<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
