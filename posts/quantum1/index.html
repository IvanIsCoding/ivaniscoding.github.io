<!DOCTYPE html>
<html lang="en-us">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.7.0">

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Ivan Carvalho">

  
  
  
    
  
  <meta name="description" content="Hands-on quantum computing with Qiskit">

  
  <link rel="alternate" hreflang="en-us" href="https://ivaniscoding.github.io/posts/quantum1/">

  


  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  <script src="/js/mathjax-config.js"></script>
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css" crossorigin="anonymous" title="hl-light">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css" crossorigin="anonymous" title="hl-dark" disabled>
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.css" integrity="sha256-SHMGCYmST46SoyGgo4YR/9AlK1vf3ff84Aq9yK4hdqM=" crossorigin="anonymous">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js" integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    

  

  
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap">
  

  
  
  
  
  <link rel="stylesheet" href="/css/academic.css">

  





<script async src="https://www.googletagmanager.com/gtag/js?id=UA-135472875-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
      dataLayer.push(arguments);
  }

  function trackOutboundLink(url) {
    gtag('event', 'click', {
         'event_category': 'outbound',
         'event_label': url,
         'transport_type': 'beacon',
         'event_callback': function () {
           document.location = url;
         }
    });
    console.debug("Outbound link clicked: " + url);
  }

  function onClickCallback(event) {
    if ((event.target.tagName !== 'A') || (event.target.host === window.location.host)) {
      return;
    }
    trackOutboundLink(event.target);  
  }

  gtag('js', new Date());
  gtag('config', 'UA-135472875-1', {});

  
  document.addEventListener('click', onClickCallback, false);
</script>


  


  

  <link rel="manifest" href="/index.webmanifest">
  <link rel="icon" type="image/png" href="/images/icon_hud7c04f8250daa34436c1572b3b03bb6e_328675_32x32_fill_lanczos_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hud7c04f8250daa34436c1572b3b03bb6e_328675_192x192_fill_lanczos_center_2.png">

  <link rel="canonical" href="https://ivaniscoding.github.io/posts/quantum1/">

  
  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="Ivan Carvalho">
  <meta property="og:url" content="https://ivaniscoding.github.io/posts/quantum1/">
  <meta property="og:title" content="Quantum #1 - Basic Quantum Computing | Ivan Carvalho">
  <meta property="og:description" content="Hands-on quantum computing with Qiskit"><meta property="og:image" content="https://ivaniscoding.github.io/images/icon_hud7c04f8250daa34436c1572b3b03bb6e_328675_512x512_fill_lanczos_center_2.png">
  <meta property="twitter:image" content="https://ivaniscoding.github.io/images/icon_hud7c04f8250daa34436c1572b3b03bb6e_328675_512x512_fill_lanczos_center_2.png"><meta property="og:locale" content="en-us">
  
    
      <meta property="article:published_time" content="2019-12-11T20:00:00-08:00">
    
    <meta property="article:modified_time" content="2019-12-30T22:38:00-08:00">
  

  



  


  


  





  <title>Quantum #1 - Basic Quantum Computing | Ivan Carvalho</title>

</head>

<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" >

  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


  

<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container">

    
    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">Ivan Carvalho</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">Ivan Carvalho</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Home</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#projects"><span>Projects</span></a>
        </li>

        
        

        

        
        
        
          
        

        
        
        
        
        
        
          
          
          
            
          
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">
      

      

      

    </ul>

  </div>
</nav>


  <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>Quantum #1 - Basic Quantum Computing</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
          Last updated on
      
    
    Dec 30, 2019
  </span>
  

  

  

  
  
  

  
  
  <span class="middot-divider"></span>
  <span class="article-categories">
    <i class="fas fa-folder mr-1"></i><a href="/categories/quantum/">Quantum</a></span>
  

</div>

    














  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>This is the first post of a series of posts about Quantum Computing with <a href="https://qiskit.org/">Qiskit</a>. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.</p>
<p>The goal of this post is to introduce a more hands-on approach to quantum computing using Qiskit. For a friendly introduction to quantum computing in general, I recommend the essay <a href="https://quantum.country/qcvc">Quantum computing for the very curious</a> by Matuschak and Nielsen.</p>
<h2 id="the-qubit">The qubit</h2>
<p>Quantum computers are made of qubits like classical computers are made of bits. However, qubits vectors and thus they have components. There are two very important qubits <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> that relate to their classical 0 and 1 counterparts. In vector notation, they are:</p>
<p><span class="math display">\[
|0\rangle = \begin{bmatrix}1 \\ 0\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
|1\rangle = \begin{bmatrix}0 \\ 1\end{bmatrix}
\]</span></p>
<p>In general, every qubit <span class="math inline">\(|\psi\rangle\)</span> has a <span class="math inline">\(|0\rangle\)</span> component and a <span class="math inline">\(|1\rangle\)</span> component, that is:</p>
<p><span class="math display">\[
|\psi\rangle = \alpha|0\rangle + \beta|1\rangle
\]</span></p>
<p>We can also write that superposition (or linear combination) in the matrix form.</p>
<p><span class="math display">\[
|\psi\rangle = \begin{bmatrix}\alpha \\ \beta\end{bmatrix}
\]</span></p>
<p>It is important to remember that <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> may be complex numbers! Thus, the imaginary number <span class="math inline">\(i\)</span> may appear in the components. For example, following qubit is valid:</p>
<p><span class="math display">\[
|\psi\rangle = \begin{bmatrix}\frac{1 + i}{\sqrt 2} \\ 0\end{bmatrix}
\]</span></p>
<p>Lastly, one key factor for qubits is that they are unitary vectors that is:</p>
<p><span class="math display">\[
|| |\psi\rangle || = 1
\]</span></p>
<p>Thus, we may visualize a qubit as a 3d vector in a sphere of radius 1:</p>
<p><img src="/img/Quantum1/BlocSphere.png" /></p>
<h2 id="quantum-gates-quantum-circuits">Quantum gates &amp; Quantum Circuits</h2>
<p>A quantum circuit is a collection of qubits and classical bits. The building blocks of quantum circuits are quantum gates: they modify qubits and allow quantum computing to achieve arbitrary qubit states as we discussed before.</p>
<p>In Qiskit, a quantum circuit can be initialized by:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">from</span> qiskit <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-2" title="2">circuit <span class="op">=</span> QuantumCircuit(n_qubits, n_classical_bits)</a></code></pre></div>
<p>In general, a gate <span class="math inline">\(U\)</span> can be added to a circuit by:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">circuit.u(target_qubit)</a></code></pre></div>
<p>A fact to notice is that there is an infinite number of qubit gates! A gate is any device that takes a qubit <span class="math inline">\(|\psi\rangle\)</span> and outputs another valid qubit <span class="math inline">\(|\phi\rangle\)</span>. In general, we have that a gate <span class="math inline">\(U\)</span> can be represented by a matrix:</p>
<p><span class="math display">\[
U = \begin{bmatrix} a &amp; b \\ c &amp; d\end{bmatrix}
\]</span></p>
<p>By applying the gate <span class="math inline">\(U\)</span> to a qubit <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span>, we obtain:</p>
<p><span class="math display">\[
|\phi\rangle = U|\psi\rangle = (a\cdot\alpha + b\cdot\beta)|0\rangle + (c\cdot\alpha + d\cdot\beta)|1\rangle
\]</span></p>
<p>Notice that <span class="math inline">\(U\)</span> must preserve the length of <span class="math inline">\(|\psi\rangle\)</span> in order for <span class="math inline">\(|\phi\rangle\)</span> to be a valid qubit! Thus <span class="math inline">\(U\)</span> is a special type of matrix called a unitary matrix. Mathematically:</p>
<p><span class="math display">\[
UU^{\dagger} = I
\]</span></p>
<p>Where <span class="math inline">\(U^{\dagger}\)</span> is the <a href="https://en.wikipedia.org/wiki/Conjugate_transpose">conjugate transpose</a>. It is important to see that <span class="math inline">\(U^{\dagger}\)</span> can undo the transformation from <span class="math inline">\(U\)</span>: it takes <span class="math inline">\(|\phi\rangle\)</span> to <span class="math inline">\(|\psi\rangle\)</span>.</p>
<p>Because of the matrix multiplication property of the gates, applying multiple quantum gates such as <span class="math inline">\(U_{a}\)</span> and then <span class="math inline">\(U_{b}\)</span> is equivalent to applying a gate <span class="math inline">\(G\)</span> such that:</p>
<p><span class="math display">\[
G = U_{a}U_{b}
\]</span></p>
<p>It is important to notice that gate composition also implies gate decomposition. The quantum gate you are applying might be a synthesis of other easier to implement gates in real life such that <span class="math inline">\(G = U_{a}U_{b}U_{c}\)</span>.</p>
<p>Even though there is an infinite amount of gates, some are very famous because they are more used than others and have a special place in quantum computing and Qiskit. They are:</p>
<h3 id="the-pauli-x-gate">The Pauli-X gate</h3>
<p>The Pauli-X gate is the quantum equivalent of the NOT gate, that is it takes 0 to 1 and 1 to 0. Mathematically:</p>
<p><span class="math display">\[
|0\rangle \overset{X}{\rightarrow} |1\rangle
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{X}{\rightarrow} |0\rangle
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{X}{\rightarrow} \beta|0\rangle + \alpha|1\rangle
\]</span></p>
<p>To use the Pauli-X gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">circuit.x(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/XGate.png" /></p>
<p>Because <span class="math inline">\(X\)</span> is a gate, it can be written as a matrix as we discussed before:</p>
<p><span class="math display">\[
X = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 0\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(X\)</span> is that <span class="math inline">\(X = X^{\dagger}\)</span>, thus <span class="math inline">\(X\)</span> is the inverse gate of itself! That means that if we apply twice the Pauli-X Gate to a qubit, we will still have the same qubit.</p>
<h3 id="the-pauli-z-gate">The Pauli-Z gate</h3>
<p>The Pauli-Z gate is a quantum gate that leaves the <span class="math inline">\(|0\rangle\)</span> component intact but flips the sign of the <span class="math inline">\(|1\rangle\)</span> component. Mathematically:</p>
<p><span class="math display">\[
|0\rangle \overset{Z}{\rightarrow} |0\rangle
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{Z}{\rightarrow} -|1\rangle
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{Z}{\rightarrow} \alpha|0\rangle - \beta|1\rangle
\]</span></p>
<p>To use the Pauli-Z gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">circuit.z(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/ZGate.png" /></p>
<p>The matrix representation of <span class="math inline">\(Z\)</span> is:</p>
<p><span class="math display">\[
Z = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; -1\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(Z\)</span> is that <span class="math inline">\(Z = Z^{\dagger}\)</span>, thus <span class="math inline">\(Z\)</span> is the inverse gate of itself! That means that if we apply twice the Pauli-Z Gate to a qubit, we will still have the same qubit.</p>
<h3 id="the-pauli-y-gate">The Pauli-Y gate</h3>
<p>The Pauli-Y gate is a gate that has only pure imaginary entries. It is similar to the <span class="math inline">\(X\)</span> gate but has its entries multiplied by <span class="math inline">\(i\)</span> and the top term is <span class="math inline">\(-i\)</span>. Mathematically, it acts as follows:</p>
<p><span class="math display">\[
|0\rangle \overset{Y}{\rightarrow} i|1\rangle
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{Y}{\rightarrow} -i|0\rangle
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{Y}{\rightarrow} -i\beta|0\rangle + i\alpha|1\rangle
\]</span></p>
<p>To use the Pauli-Y gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">circuit.y(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/YGate.png" /></p>
<p>The matrix representation of <span class="math inline">\(Y\)</span> is:</p>
<p><span class="math display">\[
Y = \begin{bmatrix} 0 &amp; -i \\ i &amp; 0\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(Y\)</span> is that <span class="math inline">\(Y = Y^{\dagger}\)</span>, thus <span class="math inline">\(Y\)</span> is the inverse gate of itself! That means that if we apply twice the Pauli-Y Gate to a qubit, we will still have the same qubit.</p>
<h3 id="the-hadamard-gate">The Hadamard gate</h3>
<p>The Hadamard gate is a gate to generate superposition, and it is hard to find a classical equivalent of it: it is a quantum gate by nature. Given <span class="math inline">\(|0\rangle\)</span>, it generates a mix of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>, and does the same for <span class="math inline">\(|1\rangle\)</span>. Mathematically:</p>
<p><span class="math display">\[
|0\rangle \overset{H}{\rightarrow} \frac{|0\rangle + |1\rangle}{\sqrt 2}
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{H}{\rightarrow} \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{H}{\rightarrow} \frac{(\alpha + \beta)}{\sqrt 2}|0\rangle + \frac{(\alpha - \beta)}{\sqrt 2}|1\rangle
\]</span></p>
<p>Notice that <span class="math inline">\(\frac{|0\rangle + |1\rangle}{\sqrt 2}\)</span> and <span class="math inline">\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)</span> are so important because they can be seen as an alternative basis, that they deserve their own symbols:</p>
<p><span class="math display">\[
|+\rangle= \frac{|0\rangle + |1\rangle}{\sqrt 2}
\]</span></p>
<p><span class="math display">\[
|-\rangle= \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]</span></p>
<p>To use the Hadamard gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">circuit.h(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/HGate.png" /></p>
<p>The matrix reprenstation of the Hadamard gate is:</p>
<p><span class="math display">\[
H = \frac{1}{\sqrt 2}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(H\)</span> is that <span class="math inline">\(H = H^{\dagger}\)</span>, thus <span class="math inline">\(H\)</span> is the inverse gate of itself! That means that if we apply twice the Hadamard gate to a qubit, we will still have the same qubit.</p>
<h2 id="executing-a-circuit-in-qiskit">Executing a circuit in Qiskit</h2>
<p>In Qiskit, we need a backend to execute a quantum circuit. That backend might be either a real quantum computer or a simulator. The syntax to run a circuit is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">job <span class="op">=</span> execute(circuit, backend, shots<span class="op">=</span>n_times_to_execute)</a></code></pre></div>
<p>There are three key simulators in Qiskit that you must be aware of:</p>
<ul>
<li><em>qasm_simulator:</em> simulates the circuit and performs measurements</li>
<li><em>unitary_simulator:</em> simulates the circuit and outputs the unitary matrix that represents it</li>
<li><em>statevector_simulator:</em> simulates the circuit and outputs the state of the qubit</li>
</ul>
<p>The syntax to obtain the specific backend with the simulator we want is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">simulator <span class="op">=</span> Aer.get_backend(backend_name)</a></code></pre></div>
<p>Notice that after running the circuit either in a simulator in a real device, we would want the results! The code snippet below describes how to obtain it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">result <span class="op">=</span> job.result()</a>
<a class="sourceLine" id="cb9-2" title="2">result.get_unitary()  <span class="co"># if the backend is unitary_simulator</span></a>
<a class="sourceLine" id="cb9-3" title="3">result.get_statevecor() <span class="co"># if the backend  is statevector_simulator</span></a></code></pre></div>
<p>Jupyter notebooks exemplifying the process are given below:</p>
<p><script type="application/javascript" src="https://gist.github.com/IvanIsCoding/47754335e473c34203300387ba1e4ba5.js"></script>
 <script type="application/javascript" src="https://gist.github.com/IvanIsCoding/3aa86987a0bed84d09796bc19228bd73.js"></script>
</p>
<h2 id="measurements">Measurements</h2>
<p>Even though qubits are a superposition of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>, when a measurement is made, the output will be either 0 or 1. For a given qubit <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span>, there is a <span class="math inline">\(|\alpha^{2}|\)</span> probability that the measurement will be 0 and a <span class="math inline">\(|\beta^{2}|\)</span> probability that the measurement will be 1.</p>
<p>Because the sum of the probabilities of all events is equal to one, we may write:</p>
<p><span class="math display">\[
|\alpha^{2}| + |\beta^{2}| = 1
\]</span></p>
<p>In Qiskit, a measurement can be made using the following syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1">circuit.measure(target_qubit, target_classical_bit)</a></code></pre></div>
<p>After executing the job in a real quantum computer or in a simulator, the obtained measurements will be available in a dictionary where the key is the measurement and the value is the count of the measurements:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1">result <span class="op">=</span> job.result()</a>
<a class="sourceLine" id="cb11-2" title="2">measurement_counts <span class="op">=</span> result.get_counts()</a></code></pre></div>
<p>In general, it is also useful to visualize the measurements using a histogram. That can be done through:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"><span class="im">from</span> qiskit.visualization <span class="im">import</span> plot_histogram</a>
<a class="sourceLine" id="cb12-2" title="2">plot_histogram(measurement_counts)</a></code></pre></div>
<p>A Jupyter notebook exemplifying the measurement process is given below:</p>
<script type="application/javascript" src="https://gist.github.com/IvanIsCoding/8a86d679f371f7d87341f985f43d40f6.js"></script>

<h2 id="multiple-qubits">Multiple qubits</h2>
<p>So far we have discussed only systems with exactly one qubit! However, quantum circuits are generally composed of multiple qubits. For example, for a two-qubit system, there are four states: <span class="math inline">\(|00\rangle\)</span>, <span class="math inline">\(|01\rangle\)</span>, <span class="math inline">\(|10\rangle\)</span> and <span class="math inline">\(|11\rangle\)</span>. A 2-qubit system can be described then as:</p>
<p><span class="math display">\[
|\psi\rangle = \alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle
\]</span></p>
<p>A system of n qubits will have <span class="math inline">\(2^{n}\)</span> states, hence using the ket notation is more convenient than writing matrices with <span class="math inline">\(2^{n}\)</span> entries.</p>
<p>For multiple qubit system, it is also common to use the tensor product (<span class="math inline">\(\otimes\)</span>) to describe the state. If <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span> is a single qubit and <span class="math inline">\(|\phi\rangle\)</span> is a qubit, then we define:</p>
<p><span class="math display">\[
|\psi\rangle \otimes |\phi\rangle = \begin{bmatrix}\alpha|\phi\rangle \\ \beta|\phi\rangle\end{bmatrix}
\]</span></p>
<p>Sometimes also written <span class="math inline">\(|\psi\rangle|\phi\rangle\)</span>. Notice that <span class="math inline">\(|00\rangle = |0\rangle \otimes |0\rangle\)</span>. The same apply for more qubits: <span class="math inline">\(|011\rangle = |0\rangle \otimes |1\rangle \otimes |1\rangle\)</span>.</p>
<p>To make it clearer, an example is useful. If <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span> and <span class="math inline">\(|\phi\rangle = \gamma|0\rangle + \delta|1\rangle\)</span>, then:</p>
<p><span class="math display">\[
|\psi\rangle \otimes |\phi\rangle = \alpha\gamma|00\rangle + \alpha\delta|01\rangle + \beta\gamma|10\rangle + \beta\delta|11\rangle
\]</span></p>
<p>One last remark is: not every state can be written as a tensor product of qubits! Those states are called entangled. An example of an entangled state is:</p>
<p><span class="math display">\[
|\Phi^{+}\rangle = \frac{|00\rangle + |11\rangle}{\sqrt 2}
\]</span></p>
<h2 id="multiple-qubit-gates">Multiple-qubit gates</h2>
<p>In the first gate section, we discussed gates that operated on a single qubit. In this section, we will discuss gates that operate on two or more qubits. They are still unitary gates:</p>
<p><span class="math display">\[
UU^{\dagger} = I
\]</span></p>
<p>Their dimensions, however, are different. A gate that operates on n qubits has dimensions of <span class="math inline">\(2^{n} \times 2^{n}\)</span>. It is also relevant to know how to write single-qubit gates for multiple qubit systems: they are written using the tensor product such as <span class="math inline">\(H \otimes Z\)</span>: in this example, we apply the Hadamard gate to the first qubit and the Pauli-Z gate to the second qubit.</p>
<p>Again, there is an infinite number of multiple qubit gates. Some that deserve special attention and have a special place in Qiskit are:</p>
<h3 id="controlled-not-gate">Controlled NOT gate</h3>
<p>The Controlled NOT gate applies the NOT gate (Pauli-X gate) to a target qubit based on a control qubit. If the control qubit is 1, then <span class="math inline">\(X\)</span> is applied to the target. Otherwise, the target is not affected. Mathematically, considering the first qubit as control and the second one as a target:</p>
<p><span class="math display">\[
|00\rangle \overset{CX}\rightarrow |00\rangle
\]</span></p>
<p><span class="math display">\[
|01\rangle \overset{CX}\rightarrow |01\rangle 
\]</span></p>
<p><span class="math display">\[
|10\rangle \overset{CX}\rightarrow |11\rangle 
\]</span></p>
<p><span class="math display">\[
|11\rangle \overset{CX}\rightarrow |10\rangle 
\]</span></p>
<p><span class="math display">\[
\alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle \overset{CX}\rightarrow \alpha|00\rangle + \beta|01\rangle + \delta|10\rangle + \gamma|11\rangle
\]</span></p>
<p>To use the CNOT gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1">circuit.cx(control, target)</a></code></pre></div>
<p>Graphically, it looks like:</p>
<p><img src="/img/Quantum1/CXGate.png" /></p>
<p>Because of the properties of the <span class="math inline">\(X\)</span> gate, the CNOT gate is the inverse of itself. Hence, if we apply twice CNOT to the same two qubits, the target qubit will not change.</p>
<p>In addition, it is worth mentioning that any gate can be made conditional using CNOT. Thus, there also exists the Controlled Z and Controlled Y gates. In Qiskit, they are available through:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">circuit.cz(control, target)</a>
<a class="sourceLine" id="cb14-2" title="2">circuit.cy(control, target)</a></code></pre></div>
<h3 id="toffoli-gate">Toffoli gate</h3>
<p>The Toffoli gate is the quantum equivalent of the logical AND gate. Even though it computes <span class="math inline">\(a \wedge b\)</span>, it needs an extra qubit: <span class="math inline">\(|a\rangle|b\rangle \rightarrow |a\rangle|a \wedge b\rangle\)</span> is not described by an unitary matrix. Thus, the Toffoli gates uses an extra qubit such that <span class="math inline">\(|a\rangle|b\rangle|0\rangle \rightarrow |a\rangle|b\rangle|a \wedge b\rangle\)</span>.</p>
<p>Because we need to handle the case when the working qubit is <span class="math inline">\(|1\rangle\)</span>, the Toffoli gate is described by:</p>
<p><span class="math display">\[
|a\rangle|b\rangle|c\rangle \overset{CCX}\rightarrow |a\rangle|b\rangle|c \oplus (a \wedge b)\rangle
\]</span></p>
<p>To use the Toffoli gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1">circuit.ccx(control_a, control_b, target_qubit)</a></code></pre></div>
<p>Graphically, it looks like:</p>
<p><img src="/img/Quantum1/Q1C1.png" /></p>
<p>Because of the properties of <span class="math inline">\(\oplus\)</span>, the Toffoli is the inverse of itself. Thus, if we apply twice the Toffoli gate to the same 3 qubits, the working qubit will not change.</p>
<p>To consolidate those ideas, here is a Jupyter notebook that uses multiple-qubit gates:</p>
<script type="application/javascript" src="https://gist.github.com/IvanIsCoding/89356c91607ed73fec75f7b0db33cf25.js"></script>

<h2 id="uncomputation">Uncomputation</h2>
<p>As we discussed in the previous session, we have seen that for calculating the AND of qubits <span class="math inline">\(|a\rangle\)</span> and <span class="math inline">\(|b\rangle\)</span>, we need a working qubit to store <span class="math inline">\(|a \wedge b\rangle\)</span>.</p>
<p>It turns out that sometimes, to compute a generic function <span class="math inline">\(f(a, b)\)</span>, we may need even more working qubits to store intermediate results.</p>
<p>For example, imagine that you want to compute <span class="math inline">\(a \wedge b \wedge c\)</span>, the AND of three variables. You would need a qubit to compute <span class="math inline">\(a \wedge b\)</span> and then another qubit to compute <span class="math inline">\((a \wedge b) \wedge c\)</span>.</p>
<p>Notice that we have very little interest in saving <span class="math inline">\(a \wedge b\)</span>. In general, it is a good idea to clean the results (i.e. to reverse the qubit to <span class="math inline">\(|0\rangle\)</span>), because:</p>
<ul>
<li>We want to reuse resources</li>
<li>It makes measurements more accurate (more qubits = more complex systems = harder measurements)</li>
</ul>
<p>That process of cleaning is called uncomputation.</p>
<p>Because <span class="math inline">\((a \wedge b) \oplus (a \wedge b) = 0\)</span>, that is the inverse of the Toffoli gate is the Toffoli gate itself, then we may build the following circuit to calculate the AND of three qubits using uncomputation:</p>
<p><img src="/img/Quantum1/Q1C3.png" /></p>
<p>In the circuit above, we use an intermediary qubit <span class="math inline">\(|a \wedge b \rangle\)</span> to help us achieve <span class="math inline">\(|a \wedge b \wedge c\rangle\)</span>, and then immediately clean it afterward. That way, the intermediary qubit goes back to <span class="math inline">\(|0\rangle\)</span> and can be reused later if necessary.</p>
<p>The Qiskit code that implements the calculation of the AND of three qubits is provided bellow, building exactly the circuit we described:</p>
<script type="application/javascript" src="https://gist.github.com/IvanIsCoding/0fd6cc6a2a892dd9d3b59e59cfa0f2a2.js"></script>


    </div>

    





<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/quantum/">quantum</a>
  
</div>














  






  
  
  
    
  
  
  <div class="media author-card content-widget-hr">
    

    <div class="media-body">
      <h5 class="card-title"><a href="https://ivaniscoding.github.io/">Ivan Carvalho</a></h5>
      <h6 class="card-subtitle">Software Developer</h6>
      <p class="card-text">Python enthusiast, competitive programmer, quantum computing apprentice. Always looking for a challenge.</p>
      <ul class="network-icon" aria-hidden="true">
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://www.linkedin.com/in/ivan-carvalho/" target="_blank" rel="noopener">
        <i class="fab fa-linkedin"></i>
      </a>
    </li>
  
    
    
    
      
    
    
    
    
    
      
    
    <li>
      <a href="https://github.com/IvanIsCoding" target="_blank" rel="noopener">
        <i class="fab fa-github"></i>
      </a>
    </li>
  
</ul>

    </div>
  </div>









  
  



  </div>
</article>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>

      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js" integrity="sha256-1zu+3BnLYV9LdiY85uXMzii3bdrkelyp37e0ZyTAQh0=" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/r.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.5.1/leaflet.js" integrity="sha256-EErZamuLefUnbMBQbsEqu1USa+btR2oIlCpBJbyD4/g=" crossorigin="anonymous"></script>
    

    
    
    <script>const code_highlighting = true;</script>
    

    

    
    

    

    
    

    
    

    
    

    
    
    
    
    
    
    
    
    
    
    
    
    <script src="/js/academic.min.e5c8525332f417fe3589df9a6b25b6c4.js"></script>

    






  
  
  <div class="container">
    <footer class="site-footer">
  

  <p class="powered-by">
    

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" class="back-to-top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

  </div>
  

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

</body>
</html>
