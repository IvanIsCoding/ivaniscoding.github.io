<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.55.6" />

    
    
    

<title>Quantum #1 - Basic Quantum Computing • Ivan Carvalho</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Quantum #1 - Basic Quantum Computing"/>
<meta name="twitter:description" content="Hands-on quantum computing with Qiskit"/>

<meta property="og:title" content="Quantum #1 - Basic Quantum Computing" />
<meta property="og:description" content="Hands-on quantum computing with Qiskit" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ivaniscoding.github.io/posts/quantum1/" />
<meta property="article:published_time" content="2019-12-11T20:00:00-08:00"/>
<meta property="article:modified_time" content="2019-12-30T22:38:00-08:00"/><meta property="og:site_name" content="Ivan Carvalho" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.6a83d62c39a364f036df4db1ecd564645635d6c7fc182425cb501218fec485f5.css" integrity="sha256-aoPWLDmjZPA2302x7NVkZFY11sf8GCQly1ASGP7EhfU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    
</head>


    <body class="theme-base-0d layout-reverse">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://ivaniscoding.github.io/">Ivan Carvalho</a>
      </span>
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Ivan Carvalho</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/index.html">
						<span>About</span>
					</a>
				</li>
			 
		
	</ul>
</div>

        <section class="social">
	
	
	
	<a href="https://github.com/ivaniscoding" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	<a href="https://linkedin.com/in/ivan-carvalho" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    
<article>
  <header>
    <h1>Quantum #1 - Basic Quantum Computing</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Dec 11, 2019
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/quantum">QUANTUM</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/quantum">quantum</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 12 min read
</div>


  </header>
  
  
  <div class="post">
    <p>This is the first post of a series of posts about Quantum Computing with <a href="https://qiskit.org/">Qiskit</a>. The area is very new and the SDK is changing constantly, but hopefully, the series can help you learn a bit about quantum and help me reinforce a couple concepts.</p>
<p>The goal of this post is to introduce a more hands-on approach to quantum computing using Qiskit. For a friendly introduction to quantum computing in general, I recommend the essay <a href="https://quantum.country/qcvc">Quantum computing for the very curious</a> by Matuschak and Nielsen.</p>
<h2 id="the-qubit">The qubit</h2>
<p>Quantum computers are made of qubits like classical computers are made of bits. However, qubits vectors and thus they have components. There are two very important qubits <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span> that relate to their classical 0 and 1 counterparts. In vector notation, they are:</p>
<p><span class="math display">\[
|0\rangle = \begin{bmatrix}1 \\ 0\end{bmatrix}
\]</span></p>
<p><span class="math display">\[
|1\rangle = \begin{bmatrix}0 \\ 1\end{bmatrix}
\]</span></p>
<p>In general, every qubit <span class="math inline">\(|\psi\rangle\)</span> has a <span class="math inline">\(|0\rangle\)</span> component and a <span class="math inline">\(|1\rangle\)</span> component, that is:</p>
<p><span class="math display">\[
|\psi\rangle = \alpha|0\rangle + \beta|1\rangle
\]</span></p>
<p>We can also write that superposition (or linear combination) in the matrix form.</p>
<p><span class="math display">\[
|\psi\rangle = \begin{bmatrix}\alpha \\ \beta\end{bmatrix}
\]</span></p>
<p>It is important to remember that <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> may be complex numbers! Thus, the imaginary number <span class="math inline">\(i\)</span> may appear in the components. For example, following qubit is valid:</p>
<p><span class="math display">\[
|\psi\rangle = \begin{bmatrix}\frac{1 + i}{\sqrt 2} \\ 0\end{bmatrix}
\]</span></p>
<p>Lastly, one key factor for qubits is that they are unitary vectors that is:</p>
<p><span class="math display">\[
|| |\psi\rangle || = 1
\]</span></p>
<p>Thus, we may visualize a qubit as a 3d vector in a sphere of radius 1:</p>
<p><img src="/img/Quantum1/BlocSphere.png" /></p>
<h2 id="quantum-gates-quantum-circuits">Quantum gates &amp; Quantum Circuits</h2>
<p>A quantum circuit is a collection of qubits and classical bits. The building blocks of quantum circuits are quantum gates: they modify qubits and allow quantum computing to achieve arbitrary qubit states as we discussed before.</p>
<p>In Qiskit, a quantum circuit can be initialized by:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="im">from</span> qiskit <span class="im">import</span> <span class="op">*</span></a>
<a class="sourceLine" id="cb1-2" title="2">circuit <span class="op">=</span> QuantumCircuit(n_qubits, n_classical_bits)</a></code></pre></div>
<p>In general, a gate <span class="math inline">\(U\)</span> can be added to a circuit by:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">circuit.u(target_qubit)</a></code></pre></div>
<p>A fact to notice is that there is an infinite number of qubit gates! A gate is any device that takes a qubit <span class="math inline">\(|\psi\rangle\)</span> and outputs another valid qubit <span class="math inline">\(|\phi\rangle\)</span>. In general, we have that a gate <span class="math inline">\(U\)</span> can be represented by a matrix:</p>
<p><span class="math display">\[
U = \begin{bmatrix} a &amp; b \\ c &amp; d\end{bmatrix}
\]</span></p>
<p>By applying the gate <span class="math inline">\(U\)</span> to a qubit <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span>, we obtain:</p>
<p><span class="math display">\[
|\phi\rangle = U|\psi\rangle = (a\cdot\alpha + b\cdot\beta)|0\rangle + (c\cdot\alpha + d\cdot\beta)|1\rangle
\]</span></p>
<p>Notice that <span class="math inline">\(U\)</span> must preserve the length of <span class="math inline">\(|\psi\rangle\)</span> in order for <span class="math inline">\(|\phi\rangle\)</span> to be a valid qubit! Thus <span class="math inline">\(U\)</span> is a special type of matrix called a unitary matrix. Mathematically:</p>
<p><span class="math display">\[
UU^{\dag} = I
\]</span></p>
<p>Where <span class="math inline">\(U^{\dag}\)</span> is the <a href="https://en.wikipedia.org/wiki/Conjugate_transpose">conjugate transpose</a>. It is important to see that <span class="math inline">\(U^{\dag}\)</span> can undo the transformation from <span class="math inline">\(U\)</span>: it takes <span class="math inline">\(|\phi\rangle\)</span> to <span class="math inline">\(|\psi\rangle\)</span>.</p>
<p>Because of the matrix multiplication property of the gates, applying multiple quantum gates such as <span class="math inline">\(U_{a}\)</span> and then <span class="math inline">\(U_{b}\)</span> is equivalent to applying a gate <span class="math inline">\(G\)</span> such that:</p>
<p><span class="math display">\[
G = U_{a}U_{b}
\]</span></p>
<p>It is important to notice that gate composition also implies gate decomposition. The quantum gate you are applying might be a synthesis of other easier to implement gates in real life such that <span class="math inline">\(G = U_{a}U_{b}U_{c}\)</span>.</p>
<p>Even though there is an infinite amount of gates, some are very famous because they are more used than others and have a special place in quantum computing and Qiskit. They are:</p>
<h3 id="the-pauli-x-gate">The Pauli-X gate</h3>
<p>The Pauli-X gate is the quantum equivalent of the NOT gate, that is it takes 0 to 1 and 1 to 0. Mathematically:</p>
<p><span class="math display">\[
|0\rangle \overset{X}{\rightarrow} |1\rangle
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{X}{\rightarrow} |0\rangle
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{X}{\rightarrow} \beta|0\rangle + \alpha|1\rangle
\]</span></p>
<p>To use the Pauli-X gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">circuit.x(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/XGate.png" /></p>
<p>Because <span class="math inline">\(X\)</span> is a gate, it can be written as a matrix as we discussed before:</p>
<p><span class="math display">\[
X = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 0\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(X\)</span> is that <span class="math inline">\(X = X^{\dag}\)</span>, thus <span class="math inline">\(X\)</span> is the inverse gate of itself! That means that if we apply twice the Pauli-X Gate to a qubit, we will still have the same qubit.</p>
<h3 id="the-pauli-z-gate">The Pauli-Z gate</h3>
<p>The Pauli-Z gate is a quantum gate that leaves the <span class="math inline">\(|0\rangle\)</span> component intact but flips the sign of the <span class="math inline">\(|1\rangle\)</span> component. Mathematically:</p>
<p><span class="math display">\[
|0\rangle \overset{Z}{\rightarrow} |0\rangle
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{Z}{\rightarrow} -|1\rangle
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{Z}{\rightarrow} \alpha|0\rangle - \beta|1\rangle
\]</span></p>
<p>To use the Pauli-Z gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">circuit.z(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/ZGate.png" /></p>
<p>The matrix representation of <span class="math inline">\(Z\)</span> is:</p>
<p><span class="math display">\[
Z = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; -1\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(Z\)</span> is that <span class="math inline">\(Z = Z^{\dag}\)</span>, thus <span class="math inline">\(Z\)</span> is the inverse gate of itself! That means that if we apply twice the Pauli-Z Gate to a qubit, we will still have the same qubit.</p>
<h3 id="the-pauli-y-gate">The Pauli-Y gate</h3>
<p>The Pauli-Y gate is a gate that has only pure imaginary entries. It is similar to the <span class="math inline">\(X\)</span> gate but has its entries multiplied by <span class="math inline">\(i\)</span> and the top term is <span class="math inline">\(-i\)</span>. Mathematically, it acts as follows:</p>
<p><span class="math display">\[
|0\rangle \overset{Y}{\rightarrow} -i|1\rangle
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{Y}{\rightarrow} i|0\rangle
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{Y}{\rightarrow} -i\beta|0\rangle + i\alpha|1\rangle
\]</span></p>
<p>To use the Pauli-Y gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">circuit.y(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/YGate.png" /></p>
<p>The matrix representation of <span class="math inline">\(Y\)</span> is:</p>
<p><span class="math display">\[
Y = \begin{bmatrix} 0 &amp; -i \\ i &amp; 0\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(Y\)</span> is that <span class="math inline">\(Y = Y^{\dag}\)</span>, thus <span class="math inline">\(Y\)</span> is the inverse gate of itself! That means that if we apply twice the Pauli-Y Gate to a qubit, we will still have the same qubit.</p>
<h3 id="the-hadamard-gate">The Hadamard gate</h3>
<p>The Hadamard gate is a gate to generate superposition, and it is hard to find a classical equivalent of it: it is a quantum gate by nature. Given <span class="math inline">\(|0\rangle\)</span>, it generates a mix of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>, and does the same for <span class="math inline">\(|1\rangle\)</span>. Mathematically:</p>
<p><span class="math display">\[
|0\rangle \overset{H}{\rightarrow} \frac{|0\rangle + |1\rangle}{\sqrt 2}
\]</span></p>
<p><span class="math display">\[
|1\rangle \overset{H}{\rightarrow} \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]</span></p>
<p><span class="math display">\[
\alpha|0\rangle + \beta|1\rangle \overset{H}{\rightarrow} \frac{(\alpha + \beta)}{\sqrt 2}|0\rangle + \frac{(\alpha - \beta)}{\sqrt 2}|1\rangle
\]</span></p>
<p>Notice that <span class="math inline">\(\frac{|0\rangle + |1\rangle}{\sqrt 2}\)</span> and <span class="math inline">\(\frac{|0\rangle - |1\rangle}{\sqrt 2}\)</span> are so important because they can be seen as an alternative basis, that they deserve their own symbols:</p>
<p><span class="math display">\[
|+\rangle= \frac{|0\rangle + |1\rangle}{\sqrt 2}
\]</span></p>
<p><span class="math display">\[
|-\rangle= \frac{|0\rangle - |1\rangle}{\sqrt 2}
\]</span></p>
<p>To use the Hadamard gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">circuit.h(target_qubit)</a></code></pre></div>
<p>Graphically, the gate is represented as:</p>
<p><img src="/img/Quantum1/HGate.png" /></p>
<p>The matrix reprenstation of the Hadamard gate is:</p>
<p><span class="math display">\[
H = \frac{1}{\sqrt 2}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1\end{bmatrix}
\]</span></p>
<p>An important property of <span class="math inline">\(H\)</span> is that <span class="math inline">\(H = H^{\dag}\)</span>, thus <span class="math inline">\(H\)</span> is the inverse gate of itself! That means that if we apply twice the Hadamard gate to a qubit, we will still have the same qubit.</p>
<h2 id="executing-a-circuit-in-qiskit">Executing a circuit in Qiskit</h2>
<p>In Qiskit, we need a backend to execute a quantum circuit. That backend might be either a real quantum computer or a simulator. The syntax to run a circuit is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1">job <span class="op">=</span> execute(circuit, backend, shots<span class="op">=</span>n_times_to_execute)</a></code></pre></div>
<p>There are three key simulators in Qiskit that you must be aware of:</p>
<ul>
<li><em>qasm_simulator:</em> simulates the circuit and performs measurements</li>
<li><em>unitary_simulator:</em> simulates the circuit and outputs the unitary matrix that represents it</li>
<li><em>statevector_simulator:</em> simulates the circuit and outputs the state of the qubit</li>
</ul>
<p>The syntax to obtain the specific backend with the simulator we want is:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">simulator <span class="op">=</span> Aer.get_backend(backend_name)</a></code></pre></div>
<p>Notice that after running the circuit either in a simulator in a real device, we would want the results! The code snippet below describes how to obtain it:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1">result <span class="op">=</span> job.result()</a>
<a class="sourceLine" id="cb9-2" title="2">result.get_unitary()  <span class="co"># if the backend is unitary_simulator</span></a>
<a class="sourceLine" id="cb9-3" title="3">result.get_statevecor() <span class="co"># if the backend  is statevector_simulator</span></a></code></pre></div>
<p>Jupyter notebooks exemplifying the process are given below:</p>
<p><script type="application/javascript" src="//gist.github.com/IvanIsCoding/47754335e473c34203300387ba1e4ba5.js"></script> <script type="application/javascript" src="//gist.github.com/IvanIsCoding/3aa86987a0bed84d09796bc19228bd73.js"></script></p>
<h2 id="measurements">Measurements</h2>
<p>Even though qubits are a superposition of <span class="math inline">\(|0\rangle\)</span> and <span class="math inline">\(|1\rangle\)</span>, when a measurement is made, the output will be either 0 or 1. For a given qubit <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span>, there is a <span class="math inline">\(|\alpha^{2}|\)</span> probability that the measurement will be 0 and a <span class="math inline">\(|\beta^{2}|\)</span> probability that the measurement will be 1.</p>
<p>Because the sum of the probabilities of all events is equal to one, we may write:</p>
<p><span class="math display">\[
|\alpha^{2}| + |\beta^{2}| = 1
\]</span></p>
<p>In Qiskit, a measurement can be made using the following syntax:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1">circuit.measure(target_qubit, target_classical_bit)</a></code></pre></div>
<p>After executing the job in a real quantum computer or in a simulator, the obtained measurements will be available in a dictionary where the key is the measurement and the value is the count of the measurements:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1">result <span class="op">=</span> job.result()</a>
<a class="sourceLine" id="cb11-2" title="2">measurement_counts <span class="op">=</span> result.get_counts()</a></code></pre></div>
<p>In general, it is also useful to visualize the measurements using a histogram. That can be done through:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"><span class="im">from</span> qiskit.visualization <span class="im">import</span> plot_histogram</a>
<a class="sourceLine" id="cb12-2" title="2">plot_histogram(measurement_counts)</a></code></pre></div>
<p>A Jupyter notebook exemplifying the measurement process is given below:</p>
<script type="application/javascript" src="//gist.github.com/IvanIsCoding/8a86d679f371f7d87341f985f43d40f6.js"></script>
<h2 id="multiple-qubits">Multiple qubits</h2>
<p>So far we have discussed only systems with exactly one qubit! However, quantum circuits are generally composed of multiple qubits. For example, for a two-qubit system, there are four states: <span class="math inline">\(|00\rangle\)</span>, <span class="math inline">\(|01\rangle\)</span>, <span class="math inline">\(|10\rangle\)</span> and <span class="math inline">\(|11\rangle\)</span>. A 2-qubit system can be described then as:</p>
<p><span class="math display">\[
|\psi\rangle = \alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle
\]</span></p>
<p>A system of n qubits will have <span class="math inline">\(2^{n}\)</span> states, hence using the ket notation is more convenient than writing matrices with <span class="math inline">\(2^{n}\)</span> entries.</p>
<p>For multiple qubit system, it is also common to use the tensor product (<span class="math inline">\(\otimes\)</span>) to describe the state. If <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span> is a single qubit and <span class="math inline">\(|\phi\rangle\)</span> is a qubit, then we define:</p>
<p><span class="math display">\[
|\psi\rangle \otimes |\phi\rangle = \begin{bmatrix}\alpha|\phi\rangle \\ \beta|\phi\rangle\end{bmatrix}
\]</span></p>
<p>Sometimes also written <span class="math inline">\(|\psi\rangle|\phi\rangle\)</span>. Notice that <span class="math inline">\(|00\rangle = |0\rangle \otimes |0\rangle\)</span>. The same apply for more qubits: <span class="math inline">\(|011\rangle = |0\rangle \otimes |1\rangle \otimes |1\rangle\)</span>.</p>
<p>To make it clearer, an example is useful. If <span class="math inline">\(|\psi\rangle = \alpha|0\rangle + \beta|1\rangle\)</span> and <span class="math inline">\(|\phi\rangle = \gamma|0\rangle + \delta|1\rangle\)</span>, then:</p>
<p><span class="math display">\[
|\psi\rangle \otimes |\phi\rangle = \alpha\gamma|00\rangle + \alpha\delta|01\rangle + \beta\gamma|10\rangle + \beta\delta|11\rangle
\]</span></p>
<p>One last remark is: not every state can be written as a tensor product of qubits! Those states are called entangled. An example of an entangled state is:</p>
<p><span class="math display">\[
|\Phi^{+}\rangle = \frac{|00\rangle + |11\rangle}{\sqrt 2}
\]</span></p>
<h2 id="multiple-qubit-gates">Multiple-qubit gates</h2>
<p>In the first gate section, we discussed gates that operated on a single qubit. In this section, we will discuss gates that operate on two or more qubits. They are still unitary gates:</p>
<p><span class="math display">\[
UU^{\dag} = I
\]</span></p>
<p>Their dimensions, however, are different. A gate that operates on n qubits has dimensions of <span class="math inline">\(2^{n} \times 2^{n}\)</span>. It is also relevant to know how to write single-qubit gates for multiple qubit systems: they are written using the tensor product such as <span class="math inline">\(H \otimes Z\)</span>: in this example, we apply the Hadamard gate to the first qubit and the Pauli-Z gate to the second qubit.</p>
<p>Again, there is an infinite number of multiple qubit gates. Some that deserve special attention and have a special place in Qiskit are:</p>
<h3 id="controlled-not-gate">Controlled NOT gate</h3>
<p>The Controlled NOT gate applies the NOT gate (Pauli-X gate) to a target qubit based on a control qubit. If the control qubit is 1, then <span class="math inline">\(X\)</span> is applied to the target. Otherwise, the target is not affected. Mathematically, considering the first qubit as control and the second one as a target:</p>
<p><span class="math display">\[
|00\rangle \overset{CX}\rightarrow |00\rangle
\]</span></p>
<p><span class="math display">\[
|01\rangle \overset{CX}\rightarrow |01\rangle 
\]</span></p>
<p><span class="math display">\[
|10\rangle \overset{CX}\rightarrow |11\rangle 
\]</span></p>
<p><span class="math display">\[
|11\rangle \overset{CX}\rightarrow |10\rangle 
\]</span></p>
<p><span class="math display">\[
\alpha|00\rangle + \beta|01\rangle + \gamma|10\rangle + \delta|11\rangle \overset{CX}\rightarrow \alpha|00\rangle + \beta|01\rangle + \delta|10\rangle + \gamma|11\rangle
\]</span></p>
<p>To use the CNOT gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1">circuit.cx(control, target)</a></code></pre></div>
<p>Graphically, it looks like:</p>
<p><img src="/img/Quantum1/CXGate.png" /></p>
<p>Because of the properties of the <span class="math inline">\(X\)</span> gate, the CNOT gate is the inverse of itself. Hence, if we apply twice CNOT to the same two qubits, the target qubit will not change.</p>
<p>In addition, it is worth mentioning that any gate can be made conditional using CNOT. Thus, there also exists the Controlled Z and Controlled Y gates. In Qiskit, they are available through:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">circuit.cz(control, target)</a>
<a class="sourceLine" id="cb14-2" title="2">circuit.cy(control, target)</a></code></pre></div>
<h3 id="toffoli-gate">Toffoli gate</h3>
<p>The Toffoli gate is the quantum equivalent of the logical AND gate. Even though it computes <span class="math inline">\(a \wedge b\)</span>, it needs an extra qubit: <span class="math inline">\(|a\rangle|b\rangle \rightarrow |a\rangle|a \wedge b\rangle\)</span> is not described by an unitary matrix. Thus, the Toffoli gates uses an extra qubit such that <span class="math inline">\(|a\rangle|b\rangle|0\rangle \rightarrow |a\rangle|b\rangle|a \wedge b\rangle\)</span>.</p>
<p>Because we need to handle the case when the working qubit is <span class="math inline">\(|1\rangle\)</span>, the Toffoli gate is described by:</p>
<p><span class="math display">\[
|a\rangle|b\rangle|c\rangle \overset{CCX}\rightarrow |a\rangle|b\rangle|c \oplus (a \wedge b)\rangle
\]</span></p>
<p>To use the Toffoli gate in Qiskit, it suffices to write:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb15-1" title="1">circuit.ccx(control_a, control_b, target_qubit)</a></code></pre></div>
<p>Graphically, it looks like:</p>
<p><img src="/img/Quantum1/Q1C1.png" /></p>
<p>Because of the properties of <span class="math inline">\(\oplus\)</span>, the Toffoli is the inverse of itself. Thus, if we apply twice the Toffoli gate to the same 3 qubits, the working qubit will not change.</p>
<p>To consolidate those ideas, here is a Jupyter notebook that uses multiple-qubit gates:</p>
<script type="application/javascript" src="//gist.github.com/IvanIsCoding/89356c91607ed73fec75f7b0db33cf25.js"></script>
<h2 id="uncomputation">Uncomputation</h2>
<p>As we discussed in the previous session, we have seen that for calculating the AND of qubits <span class="math inline">\(|a\rangle\)</span> and <span class="math inline">\(|b\rangle\)</span>, we need a working qubit to store <span class="math inline">\(|a \wedge b\rangle\)</span>.</p>
<p>It turns out that sometimes, to compute a generic function <span class="math inline">\(f(a, b)\)</span>, we may need even more working qubits to store intermediate results.</p>
<p>For example, imagine that you want to compute <span class="math inline">\(a \wedge b \wedge c\)</span>, the AND of three variables. You would need a qubit to compute <span class="math inline">\(a \wedge b\)</span> and then another qubit to compute <span class="math inline">\((a \wedge b) \wedge c\)</span>.</p>
<p>Notice that we have very little interest in saving <span class="math inline">\(a \wedge b\)</span>. In general, it is a good idea to clean the results (i.e. to reverse the qubit to <span class="math inline">\(|0\rangle\)</span>), because:</p>
<ul>
<li>We want to reuse resources</li>
<li>It makes measurements more accurate (more qubits = more complex systems = harder measurements)</li>
</ul>
<p>That process of cleaning is called uncomputation.</p>
<p>Because <span class="math inline">\((a \wedge b) \oplus (a \wedge b) = 0\)</span>, that is the inverse of the Toffoli gate is the Toffoli gate itself, then we may build the following circuit to calculate the AND of three qubits using uncomputation:</p>
<p><img src="/img/Quantum1/Q1C3.png" /></p>
<p>In the circuit above, we use an intermediary qubit <span class="math inline">\(|a \wedge b \rangle\)</span> to help us achieve <span class="math inline">\(|a \wedge b \wedge c\rangle\)</span>, and then immediately clean it afterward. That way, the intermediary qubit goes back to <span class="math inline">\(|0\rangle\)</span> and can be reused later if necessary.</p>
<p>The Qiskit code that implements the calculation of the AND of three qubits is provided bellow, building exactly the circuit we described:</p>
<script type="application/javascript" src="//gist.github.com/IvanIsCoding/0fd6cc6a2a892dd9d3b59e59cfa0f2a2.js"></script>

  </div>
  


  

  
    


</article>


        </div>
        
    

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-135472875-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
 <script>
  document.addEventListener("DOMContentLoaded", function() {
    renderMathInElement(document.body, {delimiters: [
      {left: "$$", right: "$$", display: true},
      {left: "$", right: "$", display: false}]
    });
  });
</script>



    



    </body>
</html>
