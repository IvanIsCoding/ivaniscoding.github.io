<!DOCTYPE html>
<html lang="en">
    
    


    <head>
    <link href="https://gmpg.org/xfn/11" rel="profile">
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta http-equiv="Cache-Control" content="public" />
<!-- Enable responsiveness on mobile devices -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="generator" content="Hugo 0.54.0" />

    
    
    

<title>Divide-and-conquer Techniques #1 - All But One Trick • Ivan&#39;s Blog</title>


<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Divide-and-conquer Techniques #1 - All But One Trick"/>
<meta name="twitter:description" content="An introduction to an useuful Divide-and-conquer technique: All But One Trick"/>

<meta property="og:title" content="Divide-and-conquer Techniques #1 - All But One Trick" />
<meta property="og:description" content="An introduction to an useuful Divide-and-conquer technique: All But One Trick" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ivaniscoding.github.io/posts/dctrick1/" />
<meta property="article:published_time" content="2019-03-03T10:00:00-08:00"/>
<meta property="article:modified_time" content="2019-03-03T10:00:00-08:00"/><meta property="og:site_name" content="Ivan&#39;s blog" />


    


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-dark.min.css">








<link rel="stylesheet" href="/scss/hyde-hyde.6a83d62c39a364f036df4db1ecd564645635d6c7fc182425cb501218fec485f5.css" integrity="sha256-aoPWLDmjZPA2302x7NVkZFY11sf8GCQly1ASGP7EhfU=">


<link rel="stylesheet" href="/scss/print.2744dcbf8a0b2e74f8a50e4b34e5f441be7cf93cc7de27029121c6a09f9e77bc.css" integrity="sha256-J0Tcv4oLLnT4pQ5LNOX0Qb58&#43;TzH3icCkSHGoJ&#43;ed7w=" media="print">



    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    <!-- Icons -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
    <link rel="shortcut icon" href="/favicon.png">
    

</head>


    <body class="theme-base-0d layout-reverse">
    
<div class="sidebar">
  <div class="container ">
    <div class="sidebar-about">
      <span class="site__title">
        <a href="https://ivaniscoding.github.io/">Ivan&#39;s Blog</a>
      </span>
      
      
      <p class="site__description">
        
      </p>
    </div>
    <div class="collapsible-menu">
      <input type="checkbox" id="menuToggle">
      <label for="menuToggle">Ivan&#39;s Blog</label>
      <div class="menu-content">
        <div>
	<ul class="sidebar-nav">
		 
		 
			 
				<li>
					<a href="/posts/">
						<span>Posts</span>
					</a>
				</li>
			 
		 
			 
				<li>
					<a href="/about/index.html">
						<span>About</span>
					</a>
				</li>
			 
		
		</li>
	</ul>
</div>

        <section class="social">
	
	
	
	<a href="https://github.com/ivaniscoding" rel="me"><i class="fab fa-github fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	<a href="https://linkedin.com/in/ivan-carvalho" rel="me"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a>
	
	
	
	
	
	
	
	
</section>

      </div>
    </div>
    

<div class="builtwith">
Built with <a href="https://gohugo.io">Hugo</a> ❤️ <a href="https://github.com/htr3n/hyde-hyde">hyde-hyde</a>.
</div>


  </div>
</div>

        <div class="content container">
            
    <article>
  <header>
    <h1>Divide-and-conquer Techniques #1 - All But One Trick</h1>
    
    
<div class="post__meta">
    
    
      <i class="fas fa-calendar-alt"></i> Mar 3, 2019
    
    
    
      
      
          in
          
          
              <a class="badge badge-category" href="/categories/divide-and-conquer">DIVIDE AND CONQUER</a>
              
          
      
    
    
    
      
      
          <br/>
           <i class="fas fa-tags"></i>
          
          <a class="badge badge-tag" href="/tags/algorithms">algorithms</a>
          
      
    
    
    <br/>
    <i class="fas fa-clock"></i> 5 min read
</div>


  </header>
  
  
  <div class="post">
    

<p>This is a post about one very interesting Divide-and-conquer technique. I call this the &ldquo;All but one&rdquo; trick because that&rsquo;s an accurate description
of what it can be used for. I learned about this in the <a href="http://maratona.ic.unicamp.br/BrazilianICPCSummerSchool2018/">Brazilian ICPC Summer School in 2018</a>, thanks to <a href="https://www.mimuw.edu.pl/~idziaszek/index.html">Tomasz Idziaszek</a> and thought it would be
a good addition to this blog. In this post, I will briefly explain the technique and show its application in one problem.</p>

<p>This is by no means a complete tutorial about Divide and Conquer and I will assume that the reader is at least familiar to some of the key concepts of the technique and the well-known applications such as <a href="https://en.wikipedia.org/wiki/Merge_sort">Merge Sort</a> and <a href="https://en.wikipedia.org/wiki/Binary_search">Binary Search</a>.</p>

<h1 id="the-problem-it-solves">The problem it solves</h1>

<p>This trick is useful to solve the following kind of problem: Imagine there is a structure <strong>S</strong> with <strong>N</strong> elements. To build <strong>S</strong>, you add elements one at a time. You would like to know what
<strong>S</strong> would look like if, for each element, we considered <strong>S</strong> without it. However, it is computationally expensive to remove an arbitrary single element.</p>

<p>A naive approach to this problem that is very straightforward is to rebuild <strong>S</strong> multiple times without each element. Even though this approach works,
a lot of computations are wasted because many times we have almost the same state for <strong>S</strong>. After analyzing this, a question arises: is there a more efficient way to do it?</p>

<p>If removing the last addition to <strong>S</strong> is fast, then the answer is yes. It uses a clever observation that follows nicely into a Divide-and-Conquer Algorithm.</p>

<h1 id="the-algorithm">The algorithm</h1>

<p>The idea for the algorithm can be described as follows: if we have a set of <strong>N</strong> elements, we split into two sets of roughly equal size. Then, for one of the halves, we will add all of its elements to <strong>S</strong>. Notice that by doing this, we arrive at the same conceptual problem for the other half: find <strong>S</strong> without a single element for each element.</p>

<p>Hence, we can continue the procedure until we arrive with a set of a single element. When that happens, we can answer the query about <strong>S</strong> without that element. The only missing point with that idea is that we need to answer the query for every element and not only for a single one. To solve this, we just need to change a few things when we recurse up.</p>

<p>The changes are:</p>

<ul>
<li><p>Remove all additions that were made in the step when we recurse up.</p></li>

<li><p>Add the elements of the half that were not added at first, and recurse to the half that was added at first.</p></li>

<li><p>Lastly, we need to undo those add operations when we recurse back to maintain the fact that calling the Divide and Conquer function does not alter the state of <strong>S</strong>.</p></li>
</ul>

<p>Now the algorithm works because we can guarantee that we will arrive at a situation with a single element for every element and that when that happens all the other elements will have been added to <strong>S</strong>.</p>

<p>If the operation of adding has a complexity of <strong>O(K)</strong> and the operation of undoing has a complexity of <strong>O(L)</strong>, then the algorithm has an overall complexity of <strong>O(N*(K+L)*log(N))</strong>. A pseudo-implementation of the algorithm is given below.</p>

<pre><code class="language-C++">void DivideAndConquer(int s, int e){

    // Base case: single element
    if(s == e){
        // Answer your query !
        return ;
    }

    int m = (s+e)/2; // we will split the set into two

    /* 
    First part: add elements of the right,
    recurse to the left and undo
    */

    for(int i = m+1; i&lt;=e; i++){
        // Adding elements of the right half
        add(i);
    }

    DivideAndConquer(s, m); // recursing to the left half

    for(int i = e; i&gt;=m+1; i--){
        // undo all the operations of addition
        undo();
    }

    /*
    Second part: add elements of the left,
    recurse to the right and undo
    */

    for(int i = s; i&lt;=m; i++){
        // Adding elements of the left half
        add(i);
    }

    DivideAndConquer(m+1, e); // recursing to the right half

    for(int i = m; i &gt;= s; i--){
        // undo all the operations of addition
        undo();
    }

}
</code></pre>

<h1 id="example-problem">Example Problem</h1>

<p>The problem we will analyze is Voltage from the Japanese Olympiad in Informatics Spring Camp (JOI SC 2014). You may find the problem statement and a place to submit <a href="https://dunjudge.me/analysis/problems/763/">here</a> and the original problem statement in Japanese <a href="https://www.ioi-jp.org/camp/2014/2014-sp-tasks/2014-sp-d3.pdf">here</a>.</p>

<p>A synthesis of the problem statement is : There is a circuit with <strong>N</strong> nodes and <strong>M</strong> resistors. Each node can be set either to low or high voltage, and current cannot flow through resistors connected to nodes of the same voltage. Calculate how many resistors can be removed such that if we remove only that resistors, there is current flowing in all other resistors.</p>

<h1 id="reduction-to-the-trick-and-solution">Reduction to the trick and solution</h1>

<p>The problem can be reduced to the following one: check if without an edge <strong>E</strong>, the graph is bipartite.</p>

<p>The structure to verify if a graph is bipartite while adding edges is a modified <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint Set Union-Find</a>. I will not be going into many details, but you may find more explanation about it in this <a href="https://discuss.codechef.com/questions/131944/bipartite-checking-using-dsu">CodeChef discussion</a>.</p>

<p>Removing an arbitrary edge from the DSU is fairly difficult, but removing the last one is not due to the stack-like structure of the DSU. Hence, the problem we have fits in the range of the applications of the trick and can be solved in <strong>O(N*log(N)^2)</strong>. The implementation using the technique follows:</p>

<script type="application/javascript" src="//gist.github.com/IvanIsCoding/d435ce4634fd54ff99428ee15e9730d7.js"></script>

  </div>
  


  

  
    


</article>


        </div>
        
    
  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-135472875-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


<script defer src="https://use.fontawesome.com/releases/v5.5.0/js/all.js" integrity="sha384-GqVMZRt5Gn7tB9D9q7ONtcp4gtHIUEW/yG7h98J7IpE3kpi+srfFyyB/04OV6pG0" crossorigin="anonymous"></script>


    
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.13.1/highlight.min.js"></script>
        
    
    <script type="text/javascript">
        
        hljs.initHighlightingOnLoad();
    </script>
    




    



    </body>
</html>
